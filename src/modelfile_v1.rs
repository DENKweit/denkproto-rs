// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `modelfile-v1.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:modelfile.v1.RegionFromEdge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RegionFromEdge {
    // message fields
    // @@protoc_insertion_point(field:modelfile.v1.RegionFromEdge.left)
    pub left: f64,
    // @@protoc_insertion_point(field:modelfile.v1.RegionFromEdge.right)
    pub right: f64,
    // @@protoc_insertion_point(field:modelfile.v1.RegionFromEdge.top)
    pub top: f64,
    // @@protoc_insertion_point(field:modelfile.v1.RegionFromEdge.bottom)
    pub bottom: f64,
    // special fields
    // @@protoc_insertion_point(special_field:modelfile.v1.RegionFromEdge.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RegionFromEdge {
    fn default() -> &'a RegionFromEdge {
        <RegionFromEdge as ::protobuf::Message>::default_instance()
    }
}

impl RegionFromEdge {
    pub fn new() -> RegionFromEdge {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "left",
            |m: &RegionFromEdge| { &m.left },
            |m: &mut RegionFromEdge| { &mut m.left },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "right",
            |m: &RegionFromEdge| { &m.right },
            |m: &mut RegionFromEdge| { &mut m.right },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "top",
            |m: &RegionFromEdge| { &m.top },
            |m: &mut RegionFromEdge| { &mut m.top },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bottom",
            |m: &RegionFromEdge| { &m.bottom },
            |m: &mut RegionFromEdge| { &mut m.bottom },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RegionFromEdge>(
            "RegionFromEdge",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RegionFromEdge {
    const NAME: &'static str = "RegionFromEdge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.left = is.read_double()?;
                },
                17 => {
                    self.right = is.read_double()?;
                },
                25 => {
                    self.top = is.read_double()?;
                },
                33 => {
                    self.bottom = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.left != 0. {
            my_size += 1 + 8;
        }
        if self.right != 0. {
            my_size += 1 + 8;
        }
        if self.top != 0. {
            my_size += 1 + 8;
        }
        if self.bottom != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.left != 0. {
            os.write_double(1, self.left)?;
        }
        if self.right != 0. {
            os.write_double(2, self.right)?;
        }
        if self.top != 0. {
            os.write_double(3, self.top)?;
        }
        if self.bottom != 0. {
            os.write_double(4, self.bottom)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RegionFromEdge {
        RegionFromEdge::new()
    }

    fn clear(&mut self) {
        self.left = 0.;
        self.right = 0.;
        self.top = 0.;
        self.bottom = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RegionFromEdge {
        static instance: RegionFromEdge = RegionFromEdge {
            left: 0.,
            right: 0.,
            top: 0.,
            bottom: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RegionFromEdge {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RegionFromEdge").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RegionFromEdge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegionFromEdge {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:modelfile.v1.FeatureClass)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FeatureClass {
    // message fields
    // @@protoc_insertion_point(field:modelfile.v1.FeatureClass.feature_uid)
    pub feature_uid: ::std::string::String,
    // @@protoc_insertion_point(field:modelfile.v1.FeatureClass.feature_name)
    pub feature_name: ::std::string::String,
    // @@protoc_insertion_point(field:modelfile.v1.FeatureClass.color)
    pub color: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:modelfile.v1.FeatureClass.feature_tag)
    pub feature_tag: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:modelfile.v1.FeatureClass.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FeatureClass {
    fn default() -> &'a FeatureClass {
        <FeatureClass as ::protobuf::Message>::default_instance()
    }
}

impl FeatureClass {
    pub fn new() -> FeatureClass {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "feature_uid",
            |m: &FeatureClass| { &m.feature_uid },
            |m: &mut FeatureClass| { &mut m.feature_uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "feature_name",
            |m: &FeatureClass| { &m.feature_name },
            |m: &mut FeatureClass| { &mut m.feature_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "color",
            |m: &FeatureClass| { &m.color },
            |m: &mut FeatureClass| { &mut m.color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "feature_tag",
            |m: &FeatureClass| { &m.feature_tag },
            |m: &mut FeatureClass| { &mut m.feature_tag },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FeatureClass>(
            "FeatureClass",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FeatureClass {
    const NAME: &'static str = "FeatureClass";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.feature_uid = is.read_string()?;
                },
                18 => {
                    self.feature_name = is.read_string()?;
                },
                26 => {
                    is.read_repeated_packed_int32_into(&mut self.color)?;
                },
                24 => {
                    self.color.push(is.read_int32()?);
                },
                34 => {
                    self.feature_tag = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.feature_uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.feature_uid);
        }
        if !self.feature_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.feature_name);
        }
        for value in &self.color {
            my_size += ::protobuf::rt::int32_size(3, *value);
        };
        if !self.feature_tag.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.feature_tag);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.feature_uid.is_empty() {
            os.write_string(1, &self.feature_uid)?;
        }
        if !self.feature_name.is_empty() {
            os.write_string(2, &self.feature_name)?;
        }
        for v in &self.color {
            os.write_int32(3, *v)?;
        };
        if !self.feature_tag.is_empty() {
            os.write_string(4, &self.feature_tag)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FeatureClass {
        FeatureClass::new()
    }

    fn clear(&mut self) {
        self.feature_uid.clear();
        self.feature_name.clear();
        self.color.clear();
        self.feature_tag.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FeatureClass {
        static instance: FeatureClass = FeatureClass {
            feature_uid: ::std::string::String::new(),
            feature_name: ::std::string::String::new(),
            color: ::std::vec::Vec::new(),
            feature_tag: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FeatureClass {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FeatureClass").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FeatureClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureClass {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:modelfile.v1.InputField)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct InputField {
    // message fields
    // @@protoc_insertion_point(field:modelfile.v1.InputField.label)
    pub label: ::std::string::String,
    // @@protoc_insertion_point(field:modelfile.v1.InputField.datatype)
    pub datatype: ::protobuf::EnumOrUnknown<DataType>,
    // @@protoc_insertion_point(field:modelfile.v1.InputField.image_w)
    pub image_w: i32,
    // @@protoc_insertion_point(field:modelfile.v1.InputField.image_h)
    pub image_h: i32,
    // @@protoc_insertion_point(field:modelfile.v1.InputField.image_c)
    pub image_c: i32,
    // @@protoc_insertion_point(field:modelfile.v1.InputField.region_of_interest)
    pub region_of_interest: ::std::vec::Vec<RegionFromEdge>,
    // @@protoc_insertion_point(field:modelfile.v1.InputField.training_image_w)
    pub training_image_w: i32,
    // @@protoc_insertion_point(field:modelfile.v1.InputField.training_image_h)
    pub training_image_h: i32,
    // @@protoc_insertion_point(field:modelfile.v1.InputField.training_image_c)
    pub training_image_c: i32,
    // special fields
    // @@protoc_insertion_point(special_field:modelfile.v1.InputField.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InputField {
    fn default() -> &'a InputField {
        <InputField as ::protobuf::Message>::default_instance()
    }
}

impl InputField {
    pub fn new() -> InputField {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "label",
            |m: &InputField| { &m.label },
            |m: &mut InputField| { &mut m.label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "datatype",
            |m: &InputField| { &m.datatype },
            |m: &mut InputField| { &mut m.datatype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "image_w",
            |m: &InputField| { &m.image_w },
            |m: &mut InputField| { &mut m.image_w },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "image_h",
            |m: &InputField| { &m.image_h },
            |m: &mut InputField| { &mut m.image_h },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "image_c",
            |m: &InputField| { &m.image_c },
            |m: &mut InputField| { &mut m.image_c },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "region_of_interest",
            |m: &InputField| { &m.region_of_interest },
            |m: &mut InputField| { &mut m.region_of_interest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "training_image_w",
            |m: &InputField| { &m.training_image_w },
            |m: &mut InputField| { &mut m.training_image_w },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "training_image_h",
            |m: &InputField| { &m.training_image_h },
            |m: &mut InputField| { &mut m.training_image_h },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "training_image_c",
            |m: &InputField| { &m.training_image_c },
            |m: &mut InputField| { &mut m.training_image_c },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InputField>(
            "InputField",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for InputField {
    const NAME: &'static str = "InputField";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.label = is.read_string()?;
                },
                16 => {
                    self.datatype = is.read_enum_or_unknown()?;
                },
                24 => {
                    self.image_w = is.read_int32()?;
                },
                32 => {
                    self.image_h = is.read_int32()?;
                },
                40 => {
                    self.image_c = is.read_int32()?;
                },
                50 => {
                    self.region_of_interest.push(is.read_message()?);
                },
                64 => {
                    self.training_image_w = is.read_int32()?;
                },
                72 => {
                    self.training_image_h = is.read_int32()?;
                },
                80 => {
                    self.training_image_c = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.label);
        }
        if self.datatype != ::protobuf::EnumOrUnknown::new(DataType::SCALAR_INT) {
            my_size += ::protobuf::rt::int32_size(2, self.datatype.value());
        }
        if self.image_w != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.image_w);
        }
        if self.image_h != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.image_h);
        }
        if self.image_c != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.image_c);
        }
        for value in &self.region_of_interest {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.training_image_w != 0 {
            my_size += ::protobuf::rt::int32_size(8, self.training_image_w);
        }
        if self.training_image_h != 0 {
            my_size += ::protobuf::rt::int32_size(9, self.training_image_h);
        }
        if self.training_image_c != 0 {
            my_size += ::protobuf::rt::int32_size(10, self.training_image_c);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.label.is_empty() {
            os.write_string(1, &self.label)?;
        }
        if self.datatype != ::protobuf::EnumOrUnknown::new(DataType::SCALAR_INT) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.datatype))?;
        }
        if self.image_w != 0 {
            os.write_int32(3, self.image_w)?;
        }
        if self.image_h != 0 {
            os.write_int32(4, self.image_h)?;
        }
        if self.image_c != 0 {
            os.write_int32(5, self.image_c)?;
        }
        for v in &self.region_of_interest {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if self.training_image_w != 0 {
            os.write_int32(8, self.training_image_w)?;
        }
        if self.training_image_h != 0 {
            os.write_int32(9, self.training_image_h)?;
        }
        if self.training_image_c != 0 {
            os.write_int32(10, self.training_image_c)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InputField {
        InputField::new()
    }

    fn clear(&mut self) {
        self.label.clear();
        self.datatype = ::protobuf::EnumOrUnknown::new(DataType::SCALAR_INT);
        self.image_w = 0;
        self.image_h = 0;
        self.image_c = 0;
        self.region_of_interest.clear();
        self.training_image_w = 0;
        self.training_image_h = 0;
        self.training_image_c = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InputField {
        static instance: InputField = InputField {
            label: ::std::string::String::new(),
            datatype: ::protobuf::EnumOrUnknown::from_i32(0),
            image_w: 0,
            image_h: 0,
            image_c: 0,
            region_of_interest: ::std::vec::Vec::new(),
            training_image_w: 0,
            training_image_h: 0,
            training_image_c: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for InputField {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("InputField").unwrap()).clone()
    }
}

impl ::std::fmt::Display for InputField {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InputField {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:modelfile.v1.OutputField)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OutputField {
    // message fields
    // @@protoc_insertion_point(field:modelfile.v1.OutputField.label)
    pub label: ::std::string::String,
    // @@protoc_insertion_point(field:modelfile.v1.OutputField.datatype)
    pub datatype: ::protobuf::EnumOrUnknown<DataType>,
    // @@protoc_insertion_point(field:modelfile.v1.OutputField.color)
    pub color: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:modelfile.v1.OutputField.image_w)
    pub image_w: i32,
    // @@protoc_insertion_point(field:modelfile.v1.OutputField.image_h)
    pub image_h: i32,
    // @@protoc_insertion_point(field:modelfile.v1.OutputField.image_c)
    pub image_c: i32,
    // @@protoc_insertion_point(field:modelfile.v1.OutputField.classes)
    pub classes: ::std::vec::Vec<FeatureClass>,
    // @@protoc_insertion_point(field:modelfile.v1.OutputField.max_queries)
    pub max_queries: i32,
    // @@protoc_insertion_point(field:modelfile.v1.OutputField.charset)
    pub charset: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:modelfile.v1.OutputField.charset_filter)
    pub charset_filter: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:modelfile.v1.OutputField.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OutputField {
    fn default() -> &'a OutputField {
        <OutputField as ::protobuf::Message>::default_instance()
    }
}

impl OutputField {
    pub fn new() -> OutputField {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "label",
            |m: &OutputField| { &m.label },
            |m: &mut OutputField| { &mut m.label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "datatype",
            |m: &OutputField| { &m.datatype },
            |m: &mut OutputField| { &mut m.datatype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "color",
            |m: &OutputField| { &m.color },
            |m: &mut OutputField| { &mut m.color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "image_w",
            |m: &OutputField| { &m.image_w },
            |m: &mut OutputField| { &mut m.image_w },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "image_h",
            |m: &OutputField| { &m.image_h },
            |m: &mut OutputField| { &mut m.image_h },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "image_c",
            |m: &OutputField| { &m.image_c },
            |m: &mut OutputField| { &mut m.image_c },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "classes",
            |m: &OutputField| { &m.classes },
            |m: &mut OutputField| { &mut m.classes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_queries",
            |m: &OutputField| { &m.max_queries },
            |m: &mut OutputField| { &mut m.max_queries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "charset",
            |m: &OutputField| { &m.charset },
            |m: &mut OutputField| { &mut m.charset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "charset_filter",
            |m: &OutputField| { &m.charset_filter },
            |m: &mut OutputField| { &mut m.charset_filter },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OutputField>(
            "OutputField",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OutputField {
    const NAME: &'static str = "OutputField";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.label = is.read_string()?;
                },
                16 => {
                    self.datatype = is.read_enum_or_unknown()?;
                },
                26 => {
                    is.read_repeated_packed_int32_into(&mut self.color)?;
                },
                24 => {
                    self.color.push(is.read_int32()?);
                },
                32 => {
                    self.image_w = is.read_int32()?;
                },
                40 => {
                    self.image_h = is.read_int32()?;
                },
                48 => {
                    self.image_c = is.read_int32()?;
                },
                58 => {
                    self.classes.push(is.read_message()?);
                },
                64 => {
                    self.max_queries = is.read_int32()?;
                },
                74 => {
                    self.charset = is.read_bytes()?;
                },
                82 => {
                    self.charset_filter = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.label);
        }
        if self.datatype != ::protobuf::EnumOrUnknown::new(DataType::SCALAR_INT) {
            my_size += ::protobuf::rt::int32_size(2, self.datatype.value());
        }
        for value in &self.color {
            my_size += ::protobuf::rt::int32_size(3, *value);
        };
        if self.image_w != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.image_w);
        }
        if self.image_h != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.image_h);
        }
        if self.image_c != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.image_c);
        }
        for value in &self.classes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.max_queries != 0 {
            my_size += ::protobuf::rt::int32_size(8, self.max_queries);
        }
        if !self.charset.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.charset);
        }
        if !self.charset_filter.is_empty() {
            my_size += ::protobuf::rt::bytes_size(10, &self.charset_filter);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.label.is_empty() {
            os.write_string(1, &self.label)?;
        }
        if self.datatype != ::protobuf::EnumOrUnknown::new(DataType::SCALAR_INT) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.datatype))?;
        }
        for v in &self.color {
            os.write_int32(3, *v)?;
        };
        if self.image_w != 0 {
            os.write_int32(4, self.image_w)?;
        }
        if self.image_h != 0 {
            os.write_int32(5, self.image_h)?;
        }
        if self.image_c != 0 {
            os.write_int32(6, self.image_c)?;
        }
        for v in &self.classes {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if self.max_queries != 0 {
            os.write_int32(8, self.max_queries)?;
        }
        if !self.charset.is_empty() {
            os.write_bytes(9, &self.charset)?;
        }
        if !self.charset_filter.is_empty() {
            os.write_bytes(10, &self.charset_filter)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OutputField {
        OutputField::new()
    }

    fn clear(&mut self) {
        self.label.clear();
        self.datatype = ::protobuf::EnumOrUnknown::new(DataType::SCALAR_INT);
        self.color.clear();
        self.image_w = 0;
        self.image_h = 0;
        self.image_c = 0;
        self.classes.clear();
        self.max_queries = 0;
        self.charset.clear();
        self.charset_filter.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OutputField {
        static instance: OutputField = OutputField {
            label: ::std::string::String::new(),
            datatype: ::protobuf::EnumOrUnknown::from_i32(0),
            color: ::std::vec::Vec::new(),
            image_w: 0,
            image_h: 0,
            image_c: 0,
            classes: ::std::vec::Vec::new(),
            max_queries: 0,
            charset: ::std::vec::Vec::new(),
            charset_filter: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OutputField {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OutputField").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OutputField {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OutputField {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:modelfile.v1.ModelFile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ModelFile {
    // message fields
    // @@protoc_insertion_point(field:modelfile.v1.ModelFile.protocol_version)
    pub protocol_version: ::std::string::String,
    // @@protoc_insertion_point(field:modelfile.v1.ModelFile.model)
    pub model: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:modelfile.v1.ModelFile.compression_method)
    pub compression_method: ::protobuf::EnumOrUnknown<CompressionMethod>,
    // @@protoc_insertion_point(field:modelfile.v1.ModelFile.model_hash_blake2b)
    pub model_hash_blake2b: ::std::string::String,
    // @@protoc_insertion_point(field:modelfile.v1.ModelFile.input)
    pub input: ::std::vec::Vec<InputField>,
    // @@protoc_insertion_point(field:modelfile.v1.ModelFile.output)
    pub output: ::std::vec::Vec<OutputField>,
    // @@protoc_insertion_point(field:modelfile.v1.ModelFile.tenant)
    pub tenant: ::std::string::String,
    // @@protoc_insertion_point(field:modelfile.v1.ModelFile.model_label)
    pub model_label: ::std::string::String,
    // @@protoc_insertion_point(field:modelfile.v1.ModelFile.model_tag)
    pub model_tag: ::std::string::String,
    // @@protoc_insertion_point(field:modelfile.v1.ModelFile.model_id)
    pub model_id: i32,
    // @@protoc_insertion_point(field:modelfile.v1.ModelFile.creation_timestamp)
    pub creation_timestamp: i64,
    // @@protoc_insertion_point(field:modelfile.v1.ModelFile.tenant_id)
    pub tenant_id: ::std::string::String,
    // @@protoc_insertion_point(field:modelfile.v1.ModelFile.onnx_version_major)
    pub onnx_version_major: i32,
    // @@protoc_insertion_point(field:modelfile.v1.ModelFile.onnx_version_minor)
    pub onnx_version_minor: i32,
    // @@protoc_insertion_point(field:modelfile.v1.ModelFile.model_uid)
    pub model_uid: ::std::string::String,
    // @@protoc_insertion_point(field:modelfile.v1.ModelFile.model_timestamp)
    pub model_timestamp: i64,
    // @@protoc_insertion_point(field:modelfile.v1.ModelFile.model_type)
    pub model_type: ::protobuf::EnumOrUnknown<ModelType>,
    // @@protoc_insertion_point(field:modelfile.v1.ModelFile.model_output_type)
    pub model_output_type: ::protobuf::EnumOrUnknown<ModelOutputType>,
    // @@protoc_insertion_point(field:modelfile.v1.ModelFile.file_type)
    pub file_type: ::protobuf::EnumOrUnknown<FileType>,
    // @@protoc_insertion_point(field:modelfile.v1.ModelFile.key)
    pub key: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:modelfile.v1.ModelFile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModelFile {
    fn default() -> &'a ModelFile {
        <ModelFile as ::protobuf::Message>::default_instance()
    }
}

impl ModelFile {
    pub fn new() -> ModelFile {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(20);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "protocol_version",
            |m: &ModelFile| { &m.protocol_version },
            |m: &mut ModelFile| { &mut m.protocol_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model",
            |m: &ModelFile| { &m.model },
            |m: &mut ModelFile| { &mut m.model },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "compression_method",
            |m: &ModelFile| { &m.compression_method },
            |m: &mut ModelFile| { &mut m.compression_method },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_hash_blake2b",
            |m: &ModelFile| { &m.model_hash_blake2b },
            |m: &mut ModelFile| { &mut m.model_hash_blake2b },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "input",
            |m: &ModelFile| { &m.input },
            |m: &mut ModelFile| { &mut m.input },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "output",
            |m: &ModelFile| { &m.output },
            |m: &mut ModelFile| { &mut m.output },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tenant",
            |m: &ModelFile| { &m.tenant },
            |m: &mut ModelFile| { &mut m.tenant },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_label",
            |m: &ModelFile| { &m.model_label },
            |m: &mut ModelFile| { &mut m.model_label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_tag",
            |m: &ModelFile| { &m.model_tag },
            |m: &mut ModelFile| { &mut m.model_tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &ModelFile| { &m.model_id },
            |m: &mut ModelFile| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "creation_timestamp",
            |m: &ModelFile| { &m.creation_timestamp },
            |m: &mut ModelFile| { &mut m.creation_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tenant_id",
            |m: &ModelFile| { &m.tenant_id },
            |m: &mut ModelFile| { &mut m.tenant_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "onnx_version_major",
            |m: &ModelFile| { &m.onnx_version_major },
            |m: &mut ModelFile| { &mut m.onnx_version_major },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "onnx_version_minor",
            |m: &ModelFile| { &m.onnx_version_minor },
            |m: &mut ModelFile| { &mut m.onnx_version_minor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_uid",
            |m: &ModelFile| { &m.model_uid },
            |m: &mut ModelFile| { &mut m.model_uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_timestamp",
            |m: &ModelFile| { &m.model_timestamp },
            |m: &mut ModelFile| { &mut m.model_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_type",
            |m: &ModelFile| { &m.model_type },
            |m: &mut ModelFile| { &mut m.model_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_output_type",
            |m: &ModelFile| { &m.model_output_type },
            |m: &mut ModelFile| { &mut m.model_output_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_type",
            |m: &ModelFile| { &m.file_type },
            |m: &mut ModelFile| { &mut m.file_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ModelFile| { &m.key },
            |m: &mut ModelFile| { &mut m.key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModelFile>(
            "ModelFile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModelFile {
    const NAME: &'static str = "ModelFile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.protocol_version = is.read_string()?;
                },
                18 => {
                    self.model = is.read_bytes()?;
                },
                24 => {
                    self.compression_method = is.read_enum_or_unknown()?;
                },
                34 => {
                    self.model_hash_blake2b = is.read_string()?;
                },
                42 => {
                    self.input.push(is.read_message()?);
                },
                50 => {
                    self.output.push(is.read_message()?);
                },
                58 => {
                    self.tenant = is.read_string()?;
                },
                66 => {
                    self.model_label = is.read_string()?;
                },
                74 => {
                    self.model_tag = is.read_string()?;
                },
                80 => {
                    self.model_id = is.read_int32()?;
                },
                88 => {
                    self.creation_timestamp = is.read_int64()?;
                },
                98 => {
                    self.tenant_id = is.read_string()?;
                },
                104 => {
                    self.onnx_version_major = is.read_int32()?;
                },
                112 => {
                    self.onnx_version_minor = is.read_int32()?;
                },
                122 => {
                    self.model_uid = is.read_string()?;
                },
                128 => {
                    self.model_timestamp = is.read_int64()?;
                },
                136 => {
                    self.model_type = is.read_enum_or_unknown()?;
                },
                144 => {
                    self.model_output_type = is.read_enum_or_unknown()?;
                },
                152 => {
                    self.file_type = is.read_enum_or_unknown()?;
                },
                162 => {
                    self.key = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.protocol_version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.protocol_version);
        }
        if !self.model.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.model);
        }
        if self.compression_method != ::protobuf::EnumOrUnknown::new(CompressionMethod::NONE) {
            my_size += ::protobuf::rt::int32_size(3, self.compression_method.value());
        }
        if !self.model_hash_blake2b.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.model_hash_blake2b);
        }
        for value in &self.input {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.output {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.tenant.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.tenant);
        }
        if !self.model_label.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.model_label);
        }
        if !self.model_tag.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.model_tag);
        }
        if self.model_id != 0 {
            my_size += ::protobuf::rt::int32_size(10, self.model_id);
        }
        if self.creation_timestamp != 0 {
            my_size += ::protobuf::rt::int64_size(11, self.creation_timestamp);
        }
        if !self.tenant_id.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.tenant_id);
        }
        if self.onnx_version_major != 0 {
            my_size += ::protobuf::rt::int32_size(13, self.onnx_version_major);
        }
        if self.onnx_version_minor != 0 {
            my_size += ::protobuf::rt::int32_size(14, self.onnx_version_minor);
        }
        if !self.model_uid.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.model_uid);
        }
        if self.model_timestamp != 0 {
            my_size += ::protobuf::rt::int64_size(16, self.model_timestamp);
        }
        if self.model_type != ::protobuf::EnumOrUnknown::new(ModelType::REGULAR) {
            my_size += ::protobuf::rt::int32_size(17, self.model_type.value());
        }
        if self.model_output_type != ::protobuf::EnumOrUnknown::new(ModelOutputType::TYPE_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(18, self.model_output_type.value());
        }
        if self.file_type != ::protobuf::EnumOrUnknown::new(FileType::FT_MODEL) {
            my_size += ::protobuf::rt::int32_size(19, self.file_type.value());
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(20, &self.key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.protocol_version.is_empty() {
            os.write_string(1, &self.protocol_version)?;
        }
        if !self.model.is_empty() {
            os.write_bytes(2, &self.model)?;
        }
        if self.compression_method != ::protobuf::EnumOrUnknown::new(CompressionMethod::NONE) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.compression_method))?;
        }
        if !self.model_hash_blake2b.is_empty() {
            os.write_string(4, &self.model_hash_blake2b)?;
        }
        for v in &self.input {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.output {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if !self.tenant.is_empty() {
            os.write_string(7, &self.tenant)?;
        }
        if !self.model_label.is_empty() {
            os.write_string(8, &self.model_label)?;
        }
        if !self.model_tag.is_empty() {
            os.write_string(9, &self.model_tag)?;
        }
        if self.model_id != 0 {
            os.write_int32(10, self.model_id)?;
        }
        if self.creation_timestamp != 0 {
            os.write_int64(11, self.creation_timestamp)?;
        }
        if !self.tenant_id.is_empty() {
            os.write_string(12, &self.tenant_id)?;
        }
        if self.onnx_version_major != 0 {
            os.write_int32(13, self.onnx_version_major)?;
        }
        if self.onnx_version_minor != 0 {
            os.write_int32(14, self.onnx_version_minor)?;
        }
        if !self.model_uid.is_empty() {
            os.write_string(15, &self.model_uid)?;
        }
        if self.model_timestamp != 0 {
            os.write_int64(16, self.model_timestamp)?;
        }
        if self.model_type != ::protobuf::EnumOrUnknown::new(ModelType::REGULAR) {
            os.write_enum(17, ::protobuf::EnumOrUnknown::value(&self.model_type))?;
        }
        if self.model_output_type != ::protobuf::EnumOrUnknown::new(ModelOutputType::TYPE_UNKNOWN) {
            os.write_enum(18, ::protobuf::EnumOrUnknown::value(&self.model_output_type))?;
        }
        if self.file_type != ::protobuf::EnumOrUnknown::new(FileType::FT_MODEL) {
            os.write_enum(19, ::protobuf::EnumOrUnknown::value(&self.file_type))?;
        }
        if !self.key.is_empty() {
            os.write_string(20, &self.key)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModelFile {
        ModelFile::new()
    }

    fn clear(&mut self) {
        self.protocol_version.clear();
        self.model.clear();
        self.compression_method = ::protobuf::EnumOrUnknown::new(CompressionMethod::NONE);
        self.model_hash_blake2b.clear();
        self.input.clear();
        self.output.clear();
        self.tenant.clear();
        self.model_label.clear();
        self.model_tag.clear();
        self.model_id = 0;
        self.creation_timestamp = 0;
        self.tenant_id.clear();
        self.onnx_version_major = 0;
        self.onnx_version_minor = 0;
        self.model_uid.clear();
        self.model_timestamp = 0;
        self.model_type = ::protobuf::EnumOrUnknown::new(ModelType::REGULAR);
        self.model_output_type = ::protobuf::EnumOrUnknown::new(ModelOutputType::TYPE_UNKNOWN);
        self.file_type = ::protobuf::EnumOrUnknown::new(FileType::FT_MODEL);
        self.key.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModelFile {
        static instance: ModelFile = ModelFile {
            protocol_version: ::std::string::String::new(),
            model: ::std::vec::Vec::new(),
            compression_method: ::protobuf::EnumOrUnknown::from_i32(0),
            model_hash_blake2b: ::std::string::String::new(),
            input: ::std::vec::Vec::new(),
            output: ::std::vec::Vec::new(),
            tenant: ::std::string::String::new(),
            model_label: ::std::string::String::new(),
            model_tag: ::std::string::String::new(),
            model_id: 0,
            creation_timestamp: 0,
            tenant_id: ::std::string::String::new(),
            onnx_version_major: 0,
            onnx_version_minor: 0,
            model_uid: ::std::string::String::new(),
            model_timestamp: 0,
            model_type: ::protobuf::EnumOrUnknown::from_i32(0),
            model_output_type: ::protobuf::EnumOrUnknown::from_i32(0),
            file_type: ::protobuf::EnumOrUnknown::from_i32(0),
            key: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModelFile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModelFile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModelFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelFile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:modelfile.v1.FileType)
pub enum FileType {
    // @@protoc_insertion_point(enum_value:modelfile.v1.FileType.FT_MODEL)
    FT_MODEL = 0,
    // @@protoc_insertion_point(enum_value:modelfile.v1.FileType.FT_VIZIOTIX_KEY)
    FT_VIZIOTIX_KEY = 1,
    // @@protoc_insertion_point(enum_value:modelfile.v1.FileType.FT_ZXING_KEY)
    FT_ZXING_KEY = 2,
}

impl ::protobuf::Enum for FileType {
    const NAME: &'static str = "FileType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FileType> {
        match value {
            0 => ::std::option::Option::Some(FileType::FT_MODEL),
            1 => ::std::option::Option::Some(FileType::FT_VIZIOTIX_KEY),
            2 => ::std::option::Option::Some(FileType::FT_ZXING_KEY),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<FileType> {
        match str {
            "FT_MODEL" => ::std::option::Option::Some(FileType::FT_MODEL),
            "FT_VIZIOTIX_KEY" => ::std::option::Option::Some(FileType::FT_VIZIOTIX_KEY),
            "FT_ZXING_KEY" => ::std::option::Option::Some(FileType::FT_ZXING_KEY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [FileType] = &[
        FileType::FT_MODEL,
        FileType::FT_VIZIOTIX_KEY,
        FileType::FT_ZXING_KEY,
    ];
}

impl ::protobuf::EnumFull for FileType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("FileType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for FileType {
    fn default() -> Self {
        FileType::FT_MODEL
    }
}

impl FileType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<FileType>("FileType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:modelfile.v1.CompressionMethod)
pub enum CompressionMethod {
    // @@protoc_insertion_point(enum_value:modelfile.v1.CompressionMethod.NONE)
    NONE = 0,
    // @@protoc_insertion_point(enum_value:modelfile.v1.CompressionMethod.GZIP)
    GZIP = 1,
    // @@protoc_insertion_point(enum_value:modelfile.v1.CompressionMethod.ZLIB)
    ZLIB = 2,
    // @@protoc_insertion_point(enum_value:modelfile.v1.CompressionMethod.LZMA)
    LZMA = 3,
    // @@protoc_insertion_point(enum_value:modelfile.v1.CompressionMethod.BZ2)
    BZ2 = 4,
}

impl ::protobuf::Enum for CompressionMethod {
    const NAME: &'static str = "CompressionMethod";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CompressionMethod> {
        match value {
            0 => ::std::option::Option::Some(CompressionMethod::NONE),
            1 => ::std::option::Option::Some(CompressionMethod::GZIP),
            2 => ::std::option::Option::Some(CompressionMethod::ZLIB),
            3 => ::std::option::Option::Some(CompressionMethod::LZMA),
            4 => ::std::option::Option::Some(CompressionMethod::BZ2),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CompressionMethod> {
        match str {
            "NONE" => ::std::option::Option::Some(CompressionMethod::NONE),
            "GZIP" => ::std::option::Option::Some(CompressionMethod::GZIP),
            "ZLIB" => ::std::option::Option::Some(CompressionMethod::ZLIB),
            "LZMA" => ::std::option::Option::Some(CompressionMethod::LZMA),
            "BZ2" => ::std::option::Option::Some(CompressionMethod::BZ2),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CompressionMethod] = &[
        CompressionMethod::NONE,
        CompressionMethod::GZIP,
        CompressionMethod::ZLIB,
        CompressionMethod::LZMA,
        CompressionMethod::BZ2,
    ];
}

impl ::protobuf::EnumFull for CompressionMethod {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CompressionMethod").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for CompressionMethod {
    fn default() -> Self {
        CompressionMethod::NONE
    }
}

impl CompressionMethod {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CompressionMethod>("CompressionMethod")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:modelfile.v1.DataType)
pub enum DataType {
    // @@protoc_insertion_point(enum_value:modelfile.v1.DataType.SCALAR_INT)
    SCALAR_INT = 0,
    // @@protoc_insertion_point(enum_value:modelfile.v1.DataType.SCALAR_FLOAT)
    SCALAR_FLOAT = 1,
    // @@protoc_insertion_point(enum_value:modelfile.v1.DataType.IMAGE_RAW_INT)
    IMAGE_RAW_INT = 2,
    // @@protoc_insertion_point(enum_value:modelfile.v1.DataType.IMAGE_RAW_FLOAT)
    IMAGE_RAW_FLOAT = 3,
    // @@protoc_insertion_point(enum_value:modelfile.v1.DataType.IMAGE_PNG)
    IMAGE_PNG = 4,
    // @@protoc_insertion_point(enum_value:modelfile.v1.DataType.IMAGE_JPG)
    IMAGE_JPG = 5,
    // @@protoc_insertion_point(enum_value:modelfile.v1.DataType.IMAGE_TIF)
    IMAGE_TIF = 6,
    // @@protoc_insertion_point(enum_value:modelfile.v1.DataType.BOUNDING_BOX_LIST)
    BOUNDING_BOX_LIST = 7,
    // @@protoc_insertion_point(enum_value:modelfile.v1.DataType.BOUNDING_BOX_LIST_SEGMENTATION)
    BOUNDING_BOX_LIST_SEGMENTATION = 8,
    // @@protoc_insertion_point(enum_value:modelfile.v1.DataType.BOUNDING_BOX_LIST_SEGMENTATION_HIGH_RES)
    BOUNDING_BOX_LIST_SEGMENTATION_HIGH_RES = 9,
    // @@protoc_insertion_point(enum_value:modelfile.v1.DataType.OPTICAL_CHARACTER_RECOGNITION)
    OPTICAL_CHARACTER_RECOGNITION = 10,
    // @@protoc_insertion_point(enum_value:modelfile.v1.DataType.BARCODES)
    BARCODES = 11,
}

impl ::protobuf::Enum for DataType {
    const NAME: &'static str = "DataType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DataType> {
        match value {
            0 => ::std::option::Option::Some(DataType::SCALAR_INT),
            1 => ::std::option::Option::Some(DataType::SCALAR_FLOAT),
            2 => ::std::option::Option::Some(DataType::IMAGE_RAW_INT),
            3 => ::std::option::Option::Some(DataType::IMAGE_RAW_FLOAT),
            4 => ::std::option::Option::Some(DataType::IMAGE_PNG),
            5 => ::std::option::Option::Some(DataType::IMAGE_JPG),
            6 => ::std::option::Option::Some(DataType::IMAGE_TIF),
            7 => ::std::option::Option::Some(DataType::BOUNDING_BOX_LIST),
            8 => ::std::option::Option::Some(DataType::BOUNDING_BOX_LIST_SEGMENTATION),
            9 => ::std::option::Option::Some(DataType::BOUNDING_BOX_LIST_SEGMENTATION_HIGH_RES),
            10 => ::std::option::Option::Some(DataType::OPTICAL_CHARACTER_RECOGNITION),
            11 => ::std::option::Option::Some(DataType::BARCODES),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DataType> {
        match str {
            "SCALAR_INT" => ::std::option::Option::Some(DataType::SCALAR_INT),
            "SCALAR_FLOAT" => ::std::option::Option::Some(DataType::SCALAR_FLOAT),
            "IMAGE_RAW_INT" => ::std::option::Option::Some(DataType::IMAGE_RAW_INT),
            "IMAGE_RAW_FLOAT" => ::std::option::Option::Some(DataType::IMAGE_RAW_FLOAT),
            "IMAGE_PNG" => ::std::option::Option::Some(DataType::IMAGE_PNG),
            "IMAGE_JPG" => ::std::option::Option::Some(DataType::IMAGE_JPG),
            "IMAGE_TIF" => ::std::option::Option::Some(DataType::IMAGE_TIF),
            "BOUNDING_BOX_LIST" => ::std::option::Option::Some(DataType::BOUNDING_BOX_LIST),
            "BOUNDING_BOX_LIST_SEGMENTATION" => ::std::option::Option::Some(DataType::BOUNDING_BOX_LIST_SEGMENTATION),
            "BOUNDING_BOX_LIST_SEGMENTATION_HIGH_RES" => ::std::option::Option::Some(DataType::BOUNDING_BOX_LIST_SEGMENTATION_HIGH_RES),
            "OPTICAL_CHARACTER_RECOGNITION" => ::std::option::Option::Some(DataType::OPTICAL_CHARACTER_RECOGNITION),
            "BARCODES" => ::std::option::Option::Some(DataType::BARCODES),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DataType] = &[
        DataType::SCALAR_INT,
        DataType::SCALAR_FLOAT,
        DataType::IMAGE_RAW_INT,
        DataType::IMAGE_RAW_FLOAT,
        DataType::IMAGE_PNG,
        DataType::IMAGE_JPG,
        DataType::IMAGE_TIF,
        DataType::BOUNDING_BOX_LIST,
        DataType::BOUNDING_BOX_LIST_SEGMENTATION,
        DataType::BOUNDING_BOX_LIST_SEGMENTATION_HIGH_RES,
        DataType::OPTICAL_CHARACTER_RECOGNITION,
        DataType::BARCODES,
    ];
}

impl ::protobuf::EnumFull for DataType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DataType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DataType {
    fn default() -> Self {
        DataType::SCALAR_INT
    }
}

impl DataType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DataType>("DataType")
    }
}

///  Keep in sync with results.proto
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:modelfile.v1.ModelType)
pub enum ModelType {
    // @@protoc_insertion_point(enum_value:modelfile.v1.ModelType.REGULAR)
    REGULAR = 0,
    // @@protoc_insertion_point(enum_value:modelfile.v1.ModelType.AREA_DEFINITION)
    AREA_DEFINITION = 1,
}

impl ::protobuf::Enum for ModelType {
    const NAME: &'static str = "ModelType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ModelType> {
        match value {
            0 => ::std::option::Option::Some(ModelType::REGULAR),
            1 => ::std::option::Option::Some(ModelType::AREA_DEFINITION),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ModelType> {
        match str {
            "REGULAR" => ::std::option::Option::Some(ModelType::REGULAR),
            "AREA_DEFINITION" => ::std::option::Option::Some(ModelType::AREA_DEFINITION),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ModelType] = &[
        ModelType::REGULAR,
        ModelType::AREA_DEFINITION,
    ];
}

impl ::protobuf::EnumFull for ModelType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ModelType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ModelType {
    fn default() -> Self {
        ModelType::REGULAR
    }
}

impl ModelType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ModelType>("ModelType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:modelfile.v1.ModelOutputType)
pub enum ModelOutputType {
    // @@protoc_insertion_point(enum_value:modelfile.v1.ModelOutputType.TYPE_UNKNOWN)
    TYPE_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:modelfile.v1.ModelOutputType.TYPE_CLASSIFICATION)
    TYPE_CLASSIFICATION = 1,
    // @@protoc_insertion_point(enum_value:modelfile.v1.ModelOutputType.TYPE_SEGMENTATION)
    TYPE_SEGMENTATION = 2,
    // @@protoc_insertion_point(enum_value:modelfile.v1.ModelOutputType.TYPE_INSTANCE_SEGMENTATION)
    TYPE_INSTANCE_SEGMENTATION = 3,
    // @@protoc_insertion_point(enum_value:modelfile.v1.ModelOutputType.TYPE_OBJECT_DETECTION)
    TYPE_OBJECT_DETECTION = 4,
    // @@protoc_insertion_point(enum_value:modelfile.v1.ModelOutputType.TYPE_ANOMALY_DETECTION)
    TYPE_ANOMALY_DETECTION = 5,
    // @@protoc_insertion_point(enum_value:modelfile.v1.ModelOutputType.TYPE_OPTICAL_CHARACTER_RECOGNITION)
    TYPE_OPTICAL_CHARACTER_RECOGNITION = 6,
}

impl ::protobuf::Enum for ModelOutputType {
    const NAME: &'static str = "ModelOutputType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ModelOutputType> {
        match value {
            0 => ::std::option::Option::Some(ModelOutputType::TYPE_UNKNOWN),
            1 => ::std::option::Option::Some(ModelOutputType::TYPE_CLASSIFICATION),
            2 => ::std::option::Option::Some(ModelOutputType::TYPE_SEGMENTATION),
            3 => ::std::option::Option::Some(ModelOutputType::TYPE_INSTANCE_SEGMENTATION),
            4 => ::std::option::Option::Some(ModelOutputType::TYPE_OBJECT_DETECTION),
            5 => ::std::option::Option::Some(ModelOutputType::TYPE_ANOMALY_DETECTION),
            6 => ::std::option::Option::Some(ModelOutputType::TYPE_OPTICAL_CHARACTER_RECOGNITION),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ModelOutputType> {
        match str {
            "TYPE_UNKNOWN" => ::std::option::Option::Some(ModelOutputType::TYPE_UNKNOWN),
            "TYPE_CLASSIFICATION" => ::std::option::Option::Some(ModelOutputType::TYPE_CLASSIFICATION),
            "TYPE_SEGMENTATION" => ::std::option::Option::Some(ModelOutputType::TYPE_SEGMENTATION),
            "TYPE_INSTANCE_SEGMENTATION" => ::std::option::Option::Some(ModelOutputType::TYPE_INSTANCE_SEGMENTATION),
            "TYPE_OBJECT_DETECTION" => ::std::option::Option::Some(ModelOutputType::TYPE_OBJECT_DETECTION),
            "TYPE_ANOMALY_DETECTION" => ::std::option::Option::Some(ModelOutputType::TYPE_ANOMALY_DETECTION),
            "TYPE_OPTICAL_CHARACTER_RECOGNITION" => ::std::option::Option::Some(ModelOutputType::TYPE_OPTICAL_CHARACTER_RECOGNITION),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ModelOutputType] = &[
        ModelOutputType::TYPE_UNKNOWN,
        ModelOutputType::TYPE_CLASSIFICATION,
        ModelOutputType::TYPE_SEGMENTATION,
        ModelOutputType::TYPE_INSTANCE_SEGMENTATION,
        ModelOutputType::TYPE_OBJECT_DETECTION,
        ModelOutputType::TYPE_ANOMALY_DETECTION,
        ModelOutputType::TYPE_OPTICAL_CHARACTER_RECOGNITION,
    ];
}

impl ::protobuf::EnumFull for ModelOutputType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ModelOutputType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ModelOutputType {
    fn default() -> Self {
        ModelOutputType::TYPE_UNKNOWN
    }
}

impl ModelOutputType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ModelOutputType>("ModelOutputType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x12modelfile-v1.proto\x12\x0cmodelfile.v1\"d\n\x0eRegionFromEdge\x12\
    \x12\n\x04left\x18\x01\x20\x01(\x01R\x04left\x12\x14\n\x05right\x18\x02\
    \x20\x01(\x01R\x05right\x12\x10\n\x03top\x18\x03\x20\x01(\x01R\x03top\
    \x12\x16\n\x06bottom\x18\x04\x20\x01(\x01R\x06bottom\"\x89\x01\n\x0cFeat\
    ureClass\x12\x1f\n\x0bfeature_uid\x18\x01\x20\x01(\tR\nfeatureUid\x12!\n\
    \x0cfeature_name\x18\x02\x20\x01(\tR\x0bfeatureName\x12\x14\n\x05color\
    \x18\x03\x20\x03(\x05R\x05color\x12\x1f\n\x0bfeature_tag\x18\x04\x20\x01\
    (\tR\nfeatureTag\"\xeb\x02\n\nInputField\x12\x14\n\x05label\x18\x01\x20\
    \x01(\tR\x05label\x122\n\x08datatype\x18\x02\x20\x01(\x0e2\x16.modelfile\
    .v1.DataTypeR\x08datatype\x12\x17\n\x07image_w\x18\x03\x20\x01(\x05R\x06\
    imageW\x12\x17\n\x07image_h\x18\x04\x20\x01(\x05R\x06imageH\x12\x17\n\
    \x07image_c\x18\x05\x20\x01(\x05R\x06imageC\x12J\n\x12region_of_interest\
    \x18\x06\x20\x03(\x0b2\x1c.modelfile.v1.RegionFromEdgeR\x10regionOfInter\
    est\x12(\n\x10training_image_w\x18\x08\x20\x01(\x05R\x0etrainingImageW\
    \x12(\n\x10training_image_h\x18\t\x20\x01(\x05R\x0etrainingImageH\x12(\n\
    \x10training_image_c\x18\n\x20\x01(\x05R\x0etrainingImageC\"\xd0\x02\n\
    \x0bOutputField\x12\x14\n\x05label\x18\x01\x20\x01(\tR\x05label\x122\n\
    \x08datatype\x18\x02\x20\x01(\x0e2\x16.modelfile.v1.DataTypeR\x08datatyp\
    e\x12\x14\n\x05color\x18\x03\x20\x03(\x05R\x05color\x12\x17\n\x07image_w\
    \x18\x04\x20\x01(\x05R\x06imageW\x12\x17\n\x07image_h\x18\x05\x20\x01(\
    \x05R\x06imageH\x12\x17\n\x07image_c\x18\x06\x20\x01(\x05R\x06imageC\x12\
    4\n\x07classes\x18\x07\x20\x03(\x0b2\x1a.modelfile.v1.FeatureClassR\x07c\
    lasses\x12\x1f\n\x0bmax_queries\x18\x08\x20\x01(\x05R\nmaxQueries\x12\
    \x18\n\x07charset\x18\t\x20\x01(\x0cR\x07charset\x12%\n\x0echarset_filte\
    r\x18\n\x20\x01(\x0cR\rcharsetFilter\"\xd6\x06\n\tModelFile\x12)\n\x10pr\
    otocol_version\x18\x01\x20\x01(\tR\x0fprotocolVersion\x12\x14\n\x05model\
    \x18\x02\x20\x01(\x0cR\x05model\x12N\n\x12compression_method\x18\x03\x20\
    \x01(\x0e2\x1f.modelfile.v1.CompressionMethodR\x11compressionMethod\x12,\
    \n\x12model_hash_blake2b\x18\x04\x20\x01(\tR\x10modelHashBlake2b\x12.\n\
    \x05input\x18\x05\x20\x03(\x0b2\x18.modelfile.v1.InputFieldR\x05input\
    \x121\n\x06output\x18\x06\x20\x03(\x0b2\x19.modelfile.v1.OutputFieldR\
    \x06output\x12\x16\n\x06tenant\x18\x07\x20\x01(\tR\x06tenant\x12\x1f\n\
    \x0bmodel_label\x18\x08\x20\x01(\tR\nmodelLabel\x12\x1b\n\tmodel_tag\x18\
    \t\x20\x01(\tR\x08modelTag\x12\x19\n\x08model_id\x18\n\x20\x01(\x05R\x07\
    modelId\x12-\n\x12creation_timestamp\x18\x0b\x20\x01(\x03R\x11creationTi\
    mestamp\x12\x1b\n\ttenant_id\x18\x0c\x20\x01(\tR\x08tenantId\x12,\n\x12o\
    nnx_version_major\x18\r\x20\x01(\x05R\x10onnxVersionMajor\x12,\n\x12onnx\
    _version_minor\x18\x0e\x20\x01(\x05R\x10onnxVersionMinor\x12\x1b\n\tmode\
    l_uid\x18\x0f\x20\x01(\tR\x08modelUid\x12'\n\x0fmodel_timestamp\x18\x10\
    \x20\x01(\x03R\x0emodelTimestamp\x126\n\nmodel_type\x18\x11\x20\x01(\x0e\
    2\x17.modelfile.v1.ModelTypeR\tmodelType\x12I\n\x11model_output_type\x18\
    \x12\x20\x01(\x0e2\x1d.modelfile.v1.ModelOutputTypeR\x0fmodelOutputType\
    \x123\n\tfile_type\x18\x13\x20\x01(\x0e2\x16.modelfile.v1.FileTypeR\x08f\
    ileType\x12\x10\n\x03key\x18\x14\x20\x01(\tR\x03key*?\n\x08FileType\x12\
    \x0c\n\x08FT_MODEL\x10\0\x12\x13\n\x0fFT_VIZIOTIX_KEY\x10\x01\x12\x10\n\
    \x0cFT_ZXING_KEY\x10\x02*D\n\x11CompressionMethod\x12\x08\n\x04NONE\x10\
    \0\x12\x08\n\x04GZIP\x10\x01\x12\x08\n\x04ZLIB\x10\x02\x12\x08\n\x04LZMA\
    \x10\x03\x12\x07\n\x03BZ2\x10\x04*\x9a\x02\n\x08DataType\x12\x0e\n\nSCAL\
    AR_INT\x10\0\x12\x10\n\x0cSCALAR_FLOAT\x10\x01\x12\x11\n\rIMAGE_RAW_INT\
    \x10\x02\x12\x13\n\x0fIMAGE_RAW_FLOAT\x10\x03\x12\r\n\tIMAGE_PNG\x10\x04\
    \x12\r\n\tIMAGE_JPG\x10\x05\x12\r\n\tIMAGE_TIF\x10\x06\x12\x15\n\x11BOUN\
    DING_BOX_LIST\x10\x07\x12\"\n\x1eBOUNDING_BOX_LIST_SEGMENTATION\x10\x08\
    \x12+\n'BOUNDING_BOX_LIST_SEGMENTATION_HIGH_RES\x10\t\x12!\n\x1dOPTICAL_\
    CHARACTER_RECOGNITION\x10\n\x12\x0c\n\x08BARCODES\x10\x0b*-\n\tModelType\
    \x12\x0b\n\x07REGULAR\x10\0\x12\x13\n\x0fAREA_DEFINITION\x10\x01*\xd2\
    \x01\n\x0fModelOutputType\x12\x10\n\x0cTYPE_UNKNOWN\x10\0\x12\x17\n\x13T\
    YPE_CLASSIFICATION\x10\x01\x12\x15\n\x11TYPE_SEGMENTATION\x10\x02\x12\
    \x1e\n\x1aTYPE_INSTANCE_SEGMENTATION\x10\x03\x12\x19\n\x15TYPE_OBJECT_DE\
    TECTION\x10\x04\x12\x1a\n\x16TYPE_ANOMALY_DETECTION\x10\x05\x12&\n\"TYPE\
    _OPTICAL_CHARACTER_RECOGNITION\x10\x06B5Z\x19denkproto-go/modelfile/v1\
    \xaa\x02\x17DENK.Proto.Modelfile.V1J\xac#\n\x06\x12\x04\x03\0t\x01\n=\n\
    \x01\x0c\x12\x03\x03\0\x1223\x20Definition\x20of\x20Model\x20File\x20Str\
    ucture\r\n\x20Version\x200.2\r\n\n\x08\n\x01\x02\x12\x03\x05\0\x15\n\x08\
    \n\x01\x08\x12\x03\x07\00\n\t\n\x02\x08\x0b\x12\x03\x07\00\n\x08\n\x01\
    \x08\x12\x03\t\04\n\t\n\x02\x08%\x12\x03\t\04\n\n\n\x02\x05\0\x12\x04\
    \x0b\0\x0f\x01\n\n\n\x03\x05\0\x01\x12\x03\x0b\x05\r\n\x0b\n\x04\x05\0\
    \x02\0\x12\x03\x0c\x08\x1c\n\x0c\n\x05\x05\0\x02\0\x01\x12\x03\x0c\x08\
    \x10\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\x0c\x1a\x1b\n\x0b\n\x04\x05\0\
    \x02\x01\x12\x03\r\x08\x1c\n\x0c\n\x05\x05\0\x02\x01\x01\x12\x03\r\x08\
    \x17\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\r\x1a\x1b\n\x0b\n\x04\x05\0\
    \x02\x02\x12\x03\x0e\x08\x1c\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\x0e\
    \x08\x14\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\x0e\x1a\x1b\n\n\n\x02\x05\
    \x01\x12\x04\x11\0\x17\x01\n\n\n\x03\x05\x01\x01\x12\x03\x11\x05\x16\n\
    \x0b\n\x04\x05\x01\x02\0\x12\x03\x12\x08\x11\n\x0c\n\x05\x05\x01\x02\0\
    \x01\x12\x03\x12\x08\x0c\n\x0c\n\x05\x05\x01\x02\0\x02\x12\x03\x12\x0f\
    \x10\n\x0b\n\x04\x05\x01\x02\x01\x12\x03\x13\x08\x11\n\x0c\n\x05\x05\x01\
    \x02\x01\x01\x12\x03\x13\x08\x0c\n\x0c\n\x05\x05\x01\x02\x01\x02\x12\x03\
    \x13\x0f\x10\n\x0b\n\x04\x05\x01\x02\x02\x12\x03\x14\x08\x11\n\x0c\n\x05\
    \x05\x01\x02\x02\x01\x12\x03\x14\x08\x0c\n\x0c\n\x05\x05\x01\x02\x02\x02\
    \x12\x03\x14\x0f\x10\n\x0b\n\x04\x05\x01\x02\x03\x12\x03\x15\x08\x11\n\
    \x0c\n\x05\x05\x01\x02\x03\x01\x12\x03\x15\x08\x0c\n\x0c\n\x05\x05\x01\
    \x02\x03\x02\x12\x03\x15\x0f\x10\n\x0b\n\x04\x05\x01\x02\x04\x12\x03\x16\
    \x08\x11\n\x0c\n\x05\x05\x01\x02\x04\x01\x12\x03\x16\x08\x0b\n\x0c\n\x05\
    \x05\x01\x02\x04\x02\x12\x03\x16\x0f\x10\n\n\n\x02\x05\x02\x12\x04\x19\0\
    &\x01\n\n\n\x03\x05\x02\x01\x12\x03\x19\x05\r\n\x16\n\x04\x05\x02\x02\0\
    \x12\x03\x1a\x085\"\t\x20UNUSED\r\n\n\x0c\n\x05\x05\x02\x02\0\x01\x12\
    \x03\x1a\x08\x12\n\x0c\n\x05\x05\x02\x02\0\x02\x12\x03\x1a34\n\x20\n\x04\
    \x05\x02\x02\x01\x12\x03\x1b\x085\"\x13\x20image\x20classifier\r\n\n\x0c\
    \n\x05\x05\x02\x02\x01\x01\x12\x03\x1b\x08\x14\n\x0c\n\x05\x05\x02\x02\
    \x01\x02\x12\x03\x1b34\n\x16\n\x04\x05\x02\x02\x02\x12\x03\x1c\x085\"\t\
    \x20UNUSED\r\n\n\x0c\n\x05\x05\x02\x02\x02\x01\x12\x03\x1c\x08\x15\n\x0c\
    \n\x05\x05\x02\x02\x02\x02\x12\x03\x1c34\nD\n\x04\x05\x02\x02\x03\x12\
    \x03\x1d\x085\"7\x20segmentation\x20map\x20for\x20models\x20with\x20one\
    \x20segmentationmap\r\n\n\x0c\n\x05\x05\x02\x02\x03\x01\x12\x03\x1d\x08\
    \x17\n\x0c\n\x05\x05\x02\x02\x03\x02\x12\x03\x1d34\n\x16\n\x04\x05\x02\
    \x02\x04\x12\x03\x1e\x085\"\t\x20UNUSED\r\n\n\x0c\n\x05\x05\x02\x02\x04\
    \x01\x12\x03\x1e\x08\x11\n\x0c\n\x05\x05\x02\x02\x04\x02\x12\x03\x1e34\n\
    \x16\n\x04\x05\x02\x02\x05\x12\x03\x1f\x085\"\t\x20UNUSED\r\n\n\x0c\n\
    \x05\x05\x02\x02\x05\x01\x12\x03\x1f\x08\x11\n\x0c\n\x05\x05\x02\x02\x05\
    \x02\x12\x03\x1f34\n\x16\n\x04\x05\x02\x02\x06\x12\x03\x20\x085\"\t\x20U\
    NUSED\r\n\n\x0c\n\x05\x05\x02\x02\x06\x01\x12\x03\x20\x08\x11\n\x0c\n\
    \x05\x05\x02\x02\x06\x02\x12\x03\x2034\n\x0b\n\x04\x05\x02\x02\x07\x12\
    \x03!\x085\n\x0c\n\x05\x05\x02\x02\x07\x01\x12\x03!\x08\x19\n\x0c\n\x05\
    \x05\x02\x02\x07\x02\x12\x03!34\n\x0b\n\x04\x05\x02\x02\x08\x12\x03\"\
    \x085\n\x0c\n\x05\x05\x02\x02\x08\x01\x12\x03\"\x08&\n\x0c\n\x05\x05\x02\
    \x02\x08\x02\x12\x03\"34\n\x0b\n\x04\x05\x02\x02\t\x12\x03#\x085\n\x0c\n\
    \x05\x05\x02\x02\t\x01\x12\x03#\x08/\n\x0c\n\x05\x05\x02\x02\t\x02\x12\
    \x03#34\n\x0b\n\x04\x05\x02\x02\n\x12\x03$\x085\n\x0c\n\x05\x05\x02\x02\
    \n\x01\x12\x03$\x08%\n\x0c\n\x05\x05\x02\x02\n\x02\x12\x03$24\n\x0b\n\
    \x04\x05\x02\x02\x0b\x12\x03%\x085\n\x0c\n\x05\x05\x02\x02\x0b\x01\x12\
    \x03%\x08\x10\n\x0c\n\x05\x05\x02\x02\x0b\x02\x12\x03%24\n.\n\x02\x05\
    \x03\x12\x04)\0,\x01\x1a\"\x20Keep\x20in\x20sync\x20with\x20results.prot\
    o\r\n\n\n\n\x03\x05\x03\x01\x12\x03)\x05\x0e\n\x0b\n\x04\x05\x03\x02\0\
    \x12\x03*\x08\x1c\n\x0c\n\x05\x05\x03\x02\0\x01\x12\x03*\x08\x0f\n\x0c\n\
    \x05\x05\x03\x02\0\x02\x12\x03*\x1a\x1b\n\x0b\n\x04\x05\x03\x02\x01\x12\
    \x03+\x08\x1c\n\x0c\n\x05\x05\x03\x02\x01\x01\x12\x03+\x08\x17\n\x0c\n\
    \x05\x05\x03\x02\x01\x02\x12\x03+\x1a\x1b\n\n\n\x02\x05\x04\x12\x04.\06\
    \x01\n\n\n\x03\x05\x04\x01\x12\x03.\x05\x14\n\x0b\n\x04\x05\x04\x02\0\
    \x12\x03/\x08/\n\x0c\n\x05\x05\x04\x02\0\x01\x12\x03/\x08\x14\n\x0c\n\
    \x05\x05\x04\x02\0\x02\x12\x03/-.\n\x0b\n\x04\x05\x04\x02\x01\x12\x030\
    \x08/\n\x0c\n\x05\x05\x04\x02\x01\x01\x12\x030\x08\x1b\n\x0c\n\x05\x05\
    \x04\x02\x01\x02\x12\x030-.\n\x0b\n\x04\x05\x04\x02\x02\x12\x031\x08/\n\
    \x0c\n\x05\x05\x04\x02\x02\x01\x12\x031\x08\x19\n\x0c\n\x05\x05\x04\x02\
    \x02\x02\x12\x031-.\n\x0b\n\x04\x05\x04\x02\x03\x12\x032\x08/\n\x0c\n\
    \x05\x05\x04\x02\x03\x01\x12\x032\x08\"\n\x0c\n\x05\x05\x04\x02\x03\x02\
    \x12\x032-.\n\x0b\n\x04\x05\x04\x02\x04\x12\x033\x08/\n\x0c\n\x05\x05\
    \x04\x02\x04\x01\x12\x033\x08\x1d\n\x0c\n\x05\x05\x04\x02\x04\x02\x12\
    \x033-.\n\x0b\n\x04\x05\x04\x02\x05\x12\x034\x08/\n\x0c\n\x05\x05\x04\
    \x02\x05\x01\x12\x034\x08\x1e\n\x0c\n\x05\x05\x04\x02\x05\x02\x12\x034-.\
    \n\x0b\n\x04\x05\x04\x02\x06\x12\x035\x08/\n\x0c\n\x05\x05\x04\x02\x06\
    \x01\x12\x035\x08*\n\x0c\n\x05\x05\x04\x02\x06\x02\x12\x035-.\n\n\n\x02\
    \x04\0\x12\x048\0=\x01\n\n\n\x03\x04\0\x01\x12\x038\x08\x16\n\x0b\n\x04\
    \x04\0\x02\0\x12\x039\x08\x1a\n\x0c\n\x05\x04\0\x02\0\x05\x12\x039\x08\
    \x0e\n\x0c\n\x05\x04\0\x02\0\x01\x12\x039\x0f\x13\n\x0c\n\x05\x04\0\x02\
    \0\x03\x12\x039\x18\x19\n\x0b\n\x04\x04\0\x02\x01\x12\x03:\x08\x1a\n\x0c\
    \n\x05\x04\0\x02\x01\x05\x12\x03:\x08\x0e\n\x0c\n\x05\x04\0\x02\x01\x01\
    \x12\x03:\x0f\x14\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03:\x18\x19\n\x0b\n\
    \x04\x04\0\x02\x02\x12\x03;\x08\x1a\n\x0c\n\x05\x04\0\x02\x02\x05\x12\
    \x03;\x08\x0e\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03;\x0f\x12\n\x0c\n\x05\
    \x04\0\x02\x02\x03\x12\x03;\x18\x19\n\x0b\n\x04\x04\0\x02\x03\x12\x03<\
    \x08\x1a\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03<\x08\x0e\n\x0c\n\x05\x04\
    \0\x02\x03\x01\x12\x03<\x0f\x15\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03<\
    \x18\x19\n\n\n\x02\x04\x01\x12\x04?\0D\x01\n\n\n\x03\x04\x01\x01\x12\x03\
    ?\x08\x14\n\x0b\n\x04\x04\x01\x02\0\x12\x03@\x11)\n\x0c\n\x05\x04\x01\
    \x02\0\x05\x12\x03@\x11\x17\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03@\x18#\
    \n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03@'(\n\x0b\n\x04\x04\x01\x02\x01\
    \x12\x03A\x11)\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03A\x11\x17\n\x0c\n\
    \x05\x04\x01\x02\x01\x01\x12\x03A\x18$\n\x0c\n\x05\x04\x01\x02\x01\x03\
    \x12\x03A'(\n\x0b\n\x04\x04\x01\x02\x02\x12\x03B\x08)\n\x0c\n\x05\x04\
    \x01\x02\x02\x04\x12\x03B\x08\x10\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\
    \x03B\x11\x16\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03B\x18\x1d\n\x0c\n\
    \x05\x04\x01\x02\x02\x03\x12\x03B'(\n\x0b\n\x04\x04\x01\x02\x03\x12\x03C\
    \x11)\n\x0c\n\x05\x04\x01\x02\x03\x05\x12\x03C\x11\x17\n\x0c\n\x05\x04\
    \x01\x02\x03\x01\x12\x03C\x18#\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03C'\
    (\n\n\n\x02\x04\x02\x12\x04F\0P\x01\n\n\n\x03\x04\x02\x01\x12\x03F\x08\
    \x12\n\x0b\n\x04\x04\x02\x02\0\x12\x03G\x118\n\x0c\n\x05\x04\x02\x02\0\
    \x05\x12\x03G\x11\x17\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03G\x20%\n\x0c\
    \n\x05\x04\x02\x02\0\x03\x12\x03G67\n\x0b\n\x04\x04\x02\x02\x01\x12\x03H\
    \x118\n\x0c\n\x05\x04\x02\x02\x01\x06\x12\x03H\x11\x19\n\x0c\n\x05\x04\
    \x02\x02\x01\x01\x12\x03H\x20(\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03H6\
    7\nZ\n\x04\x04\x02\x02\x02\x12\x03I\x118\"M\x20Expectations\x20of\x20net\
    work\x20(image\x20restrictions\x20so\x20that\x20it\x20runs\x20without\
    \x20error)\r\n\n\x0c\n\x05\x04\x02\x02\x02\x05\x12\x03I\x11\x16\n\x0c\n\
    \x05\x04\x02\x02\x02\x01\x12\x03I\x20'\n\x0c\n\x05\x04\x02\x02\x02\x03\
    \x12\x03I67\n\x0b\n\x04\x04\x02\x02\x03\x12\x03J\x118\n\x0c\n\x05\x04\
    \x02\x02\x03\x05\x12\x03J\x11\x16\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\
    \x03J\x20'\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03J67\n\x0b\n\x04\x04\
    \x02\x02\x04\x12\x03K\x118\n\x0c\n\x05\x04\x02\x02\x04\x05\x12\x03K\x11\
    \x16\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x03K\x20'\n\x0c\n\x05\x04\x02\
    \x02\x04\x03\x12\x03K67\n\x0b\n\x04\x04\x02\x02\x05\x12\x03L\x088\n\x0c\
    \n\x05\x04\x02\x02\x05\x04\x12\x03L\x08\x10\n\x0c\n\x05\x04\x02\x02\x05\
    \x06\x12\x03L\x11\x1f\n\x0c\n\x05\x04\x02\x02\x05\x01\x12\x03L\x202\n\
    \x0c\n\x05\x04\x02\x02\x05\x03\x12\x03L67\nB\n\x04\x04\x02\x02\x06\x12\
    \x03M\x118\"5\x20Image\x20size\x20with\x20which\x20the\x20network\x20has\
    \x20been\x20trained\r\n\n\x0c\n\x05\x04\x02\x02\x06\x05\x12\x03M\x11\x16\
    \n\x0c\n\x05\x04\x02\x02\x06\x01\x12\x03M\x200\n\x0c\n\x05\x04\x02\x02\
    \x06\x03\x12\x03M67\n\x0b\n\x04\x04\x02\x02\x07\x12\x03N\x118\n\x0c\n\
    \x05\x04\x02\x02\x07\x05\x12\x03N\x11\x16\n\x0c\n\x05\x04\x02\x02\x07\
    \x01\x12\x03N\x200\n\x0c\n\x05\x04\x02\x02\x07\x03\x12\x03N67\n\x0b\n\
    \x04\x04\x02\x02\x08\x12\x03O\x118\n\x0c\n\x05\x04\x02\x02\x08\x05\x12\
    \x03O\x11\x16\n\x0c\n\x05\x04\x02\x02\x08\x01\x12\x03O\x200\n\x0c\n\x05\
    \x04\x02\x02\x08\x03\x12\x03O57\n\n\n\x02\x04\x03\x12\x04R\0]\x01\n\n\n\
    \x03\x04\x03\x01\x12\x03R\x08\x13\n\x0b\n\x04\x04\x03\x02\0\x12\x03S\x11\
    2\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03S\x11\x17\n\x0c\n\x05\x04\x03\x02\
    \0\x01\x12\x03S\x1e#\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03S01\n\x0b\n\
    \x04\x04\x03\x02\x01\x12\x03T\x112\n\x0c\n\x05\x04\x03\x02\x01\x06\x12\
    \x03T\x11\x19\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03T\x1e&\n\x0c\n\x05\
    \x04\x03\x02\x01\x03\x12\x03T01\n\x0b\n\x04\x04\x03\x02\x02\x12\x03U\x08\
    2\n\x0c\n\x05\x04\x03\x02\x02\x04\x12\x03U\x08\x10\n\x0c\n\x05\x04\x03\
    \x02\x02\x05\x12\x03U\x11\x16\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03U\
    \x1e#\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03U01\n\x0b\n\x04\x04\x03\x02\
    \x03\x12\x03V\x112\n\x0c\n\x05\x04\x03\x02\x03\x05\x12\x03V\x11\x16\n\
    \x0c\n\x05\x04\x03\x02\x03\x01\x12\x03V\x1e%\n\x0c\n\x05\x04\x03\x02\x03\
    \x03\x12\x03V01\n\x0b\n\x04\x04\x03\x02\x04\x12\x03W\x112\n\x0c\n\x05\
    \x04\x03\x02\x04\x05\x12\x03W\x11\x16\n\x0c\n\x05\x04\x03\x02\x04\x01\
    \x12\x03W\x1e%\n\x0c\n\x05\x04\x03\x02\x04\x03\x12\x03W01\n\x0b\n\x04\
    \x04\x03\x02\x05\x12\x03X\x112\n\x0c\n\x05\x04\x03\x02\x05\x05\x12\x03X\
    \x11\x16\n\x0c\n\x05\x04\x03\x02\x05\x01\x12\x03X\x1e%\n\x0c\n\x05\x04\
    \x03\x02\x05\x03\x12\x03X01\n\x0b\n\x04\x04\x03\x02\x06\x12\x03Y\x082\n\
    \x0c\n\x05\x04\x03\x02\x06\x04\x12\x03Y\x08\x10\n\x0c\n\x05\x04\x03\x02\
    \x06\x06\x12\x03Y\x11\x1d\n\x0c\n\x05\x04\x03\x02\x06\x01\x12\x03Y\x1e%\
    \n\x0c\n\x05\x04\x03\x02\x06\x03\x12\x03Y01\n\x0b\n\x04\x04\x03\x02\x07\
    \x12\x03Z\x112\n\x0c\n\x05\x04\x03\x02\x07\x05\x12\x03Z\x11\x16\n\x0c\n\
    \x05\x04\x03\x02\x07\x01\x12\x03Z\x1e)\n\x0c\n\x05\x04\x03\x02\x07\x03\
    \x12\x03Z01\n\x0b\n\x04\x04\x03\x02\x08\x12\x03[\x19:\n\x0c\n\x05\x04\
    \x03\x02\x08\x05\x12\x03[\x19\x1e\n\x0c\n\x05\x04\x03\x02\x08\x01\x12\
    \x03[&-\n\x0c\n\x05\x04\x03\x02\x08\x03\x12\x03[89\n\x0b\n\x04\x04\x03\
    \x02\t\x12\x03\\\x19:\n\x0c\n\x05\x04\x03\x02\t\x05\x12\x03\\\x19\x1e\n\
    \x0c\n\x05\x04\x03\x02\t\x01\x12\x03\\&4\n\x0c\n\x05\x04\x03\x02\t\x03\
    \x12\x03\\79\n\n\n\x02\x04\x04\x12\x04_\0t\x01\n\n\n\x03\x04\x04\x01\x12\
    \x03_\x08\x11\n\x0b\n\x04\x04\x04\x02\0\x12\x03`\x11;\n\x0c\n\x05\x04\
    \x04\x02\0\x05\x12\x03`\x11\x17\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03`#3\
    \n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03`9:\n\x0b\n\x04\x04\x04\x02\x01\
    \x12\x03a\x11;\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03a\x11\x16\n\x0c\n\
    \x05\x04\x04\x02\x01\x01\x12\x03a#(\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\
    \x03a9:\n\x0b\n\x04\x04\x04\x02\x02\x12\x03b\x11;\n\x0c\n\x05\x04\x04\
    \x02\x02\x06\x12\x03b\x11\"\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03b#5\n\
    \x0c\n\x05\x04\x04\x02\x02\x03\x12\x03b9:\n\x0b\n\x04\x04\x04\x02\x03\
    \x12\x03c\x11;\n\x0c\n\x05\x04\x04\x02\x03\x05\x12\x03c\x11\x17\n\x0c\n\
    \x05\x04\x04\x02\x03\x01\x12\x03c#5\n\x0c\n\x05\x04\x04\x02\x03\x03\x12\
    \x03c9:\n\x0b\n\x04\x04\x04\x02\x04\x12\x03d\x08;\n\x0c\n\x05\x04\x04\
    \x02\x04\x04\x12\x03d\x08\x10\n\x0c\n\x05\x04\x04\x02\x04\x06\x12\x03d\
    \x11\x1b\n\x0c\n\x05\x04\x04\x02\x04\x01\x12\x03d#(\n\x0c\n\x05\x04\x04\
    \x02\x04\x03\x12\x03d9:\n\x0b\n\x04\x04\x04\x02\x05\x12\x03e\x08;\n\x0c\
    \n\x05\x04\x04\x02\x05\x04\x12\x03e\x08\x10\n\x0c\n\x05\x04\x04\x02\x05\
    \x06\x12\x03e\x11\x1c\n\x0c\n\x05\x04\x04\x02\x05\x01\x12\x03e#)\n\x0c\n\
    \x05\x04\x04\x02\x05\x03\x12\x03e9:\n\x0b\n\x04\x04\x04\x02\x06\x12\x03f\
    \x11;\n\x0c\n\x05\x04\x04\x02\x06\x05\x12\x03f\x11\x17\n\x0c\n\x05\x04\
    \x04\x02\x06\x01\x12\x03f#)\n\x0c\n\x05\x04\x04\x02\x06\x03\x12\x03f9:\n\
    \x0b\n\x04\x04\x04\x02\x07\x12\x03g\x11;\n\x0c\n\x05\x04\x04\x02\x07\x05\
    \x12\x03g\x11\x17\n\x0c\n\x05\x04\x04\x02\x07\x01\x12\x03g#.\n\x0c\n\x05\
    \x04\x04\x02\x07\x03\x12\x03g9:\n\x0b\n\x04\x04\x04\x02\x08\x12\x03h\x11\
    ;\n\x0c\n\x05\x04\x04\x02\x08\x05\x12\x03h\x11\x17\n\x0c\n\x05\x04\x04\
    \x02\x08\x01\x12\x03h#,\n\x0c\n\x05\x04\x04\x02\x08\x03\x12\x03h9:\n\x0b\
    \n\x04\x04\x04\x02\t\x12\x03i\x11;\n\x0c\n\x05\x04\x04\x02\t\x05\x12\x03\
    i\x11\x16\n\x0c\n\x05\x04\x04\x02\t\x01\x12\x03i#+\n\x0c\n\x05\x04\x04\
    \x02\t\x03\x12\x03i8:\n\x0b\n\x04\x04\x04\x02\n\x12\x03j\x11;\n\x0c\n\
    \x05\x04\x04\x02\n\x05\x12\x03j\x11\x16\n\x0c\n\x05\x04\x04\x02\n\x01\
    \x12\x03j#5\n\x0c\n\x05\x04\x04\x02\n\x03\x12\x03j8:\n\x0b\n\x04\x04\x04\
    \x02\x0b\x12\x03k\x11;\n\x0c\n\x05\x04\x04\x02\x0b\x05\x12\x03k\x11\x17\
    \n\x0c\n\x05\x04\x04\x02\x0b\x01\x12\x03k#,\n\x0c\n\x05\x04\x04\x02\x0b\
    \x03\x12\x03k8:\n\x0b\n\x04\x04\x04\x02\x0c\x12\x03l\x11;\n\x0c\n\x05\
    \x04\x04\x02\x0c\x05\x12\x03l\x11\x16\n\x0c\n\x05\x04\x04\x02\x0c\x01\
    \x12\x03l#5\n\x0c\n\x05\x04\x04\x02\x0c\x03\x12\x03l8:\n\x0b\n\x04\x04\
    \x04\x02\r\x12\x03m\x11;\n\x0c\n\x05\x04\x04\x02\r\x05\x12\x03m\x11\x16\
    \n\x0c\n\x05\x04\x04\x02\r\x01\x12\x03m#5\n\x0c\n\x05\x04\x04\x02\r\x03\
    \x12\x03m8:\n\x0b\n\x04\x04\x04\x02\x0e\x12\x03n\x19C\n\x0c\n\x05\x04\
    \x04\x02\x0e\x05\x12\x03n\x19\x1f\n\x0c\n\x05\x04\x04\x02\x0e\x01\x12\
    \x03n+4\n\x0c\n\x05\x04\x04\x02\x0e\x03\x12\x03n@B\n\x0b\n\x04\x04\x04\
    \x02\x0f\x12\x03o\x19C\n\x0c\n\x05\x04\x04\x02\x0f\x05\x12\x03o\x19\x1e\
    \n\x0c\n\x05\x04\x04\x02\x0f\x01\x12\x03o+:\n\x0c\n\x05\x04\x04\x02\x0f\
    \x03\x12\x03o@B\n\x0b\n\x04\x04\x04\x02\x10\x12\x03p\x19C\n\x0c\n\x05\
    \x04\x04\x02\x10\x06\x12\x03p\x19\"\n\x0c\n\x05\x04\x04\x02\x10\x01\x12\
    \x03p+5\n\x0c\n\x05\x04\x04\x02\x10\x03\x12\x03p@B\n\x0b\n\x04\x04\x04\
    \x02\x11\x12\x03q\x19C\n\x0c\n\x05\x04\x04\x02\x11\x06\x12\x03q\x19(\n\
    \x0c\n\x05\x04\x04\x02\x11\x01\x12\x03q+<\n\x0c\n\x05\x04\x04\x02\x11\
    \x03\x12\x03q@B\n\x0b\n\x04\x04\x04\x02\x12\x12\x03r\x19C\n\x0c\n\x05\
    \x04\x04\x02\x12\x06\x12\x03r\x19!\n\x0c\n\x05\x04\x04\x02\x12\x01\x12\
    \x03r+4\n\x0c\n\x05\x04\x04\x02\x12\x03\x12\x03r@B\n\x0b\n\x04\x04\x04\
    \x02\x13\x12\x03s\x19C\n\x0c\n\x05\x04\x04\x02\x13\x05\x12\x03s\x19\x1f\
    \n\x0c\n\x05\x04\x04\x02\x13\x01\x12\x03s+.\n\x0c\n\x05\x04\x04\x02\x13\
    \x03\x12\x03s@Bb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(5);
            messages.push(RegionFromEdge::generated_message_descriptor_data());
            messages.push(FeatureClass::generated_message_descriptor_data());
            messages.push(InputField::generated_message_descriptor_data());
            messages.push(OutputField::generated_message_descriptor_data());
            messages.push(ModelFile::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(5);
            enums.push(FileType::generated_enum_descriptor_data());
            enums.push(CompressionMethod::generated_enum_descriptor_data());
            enums.push(DataType::generated_enum_descriptor_data());
            enums.push(ModelType::generated_enum_descriptor_data());
            enums.push(ModelOutputType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
