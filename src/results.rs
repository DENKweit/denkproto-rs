// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `results.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:results.DefectAddress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DefectAddress {
    // message fields
    // @@protoc_insertion_point(field:results.DefectAddress.dataset_index)
    pub dataset_index: i32,
    // @@protoc_insertion_point(field:results.DefectAddress.model_id)
    pub model_id: i32,
    // @@protoc_insertion_point(field:results.DefectAddress.feature_index)
    pub feature_index: i32,
    // @@protoc_insertion_point(field:results.DefectAddress.overlap_area)
    pub overlap_area: f64,
    // @@protoc_insertion_point(field:results.DefectAddress.overlap_ratio)
    pub overlap_ratio: f64,
    // @@protoc_insertion_point(field:results.DefectAddress.overlap_ratio_of_other)
    pub overlap_ratio_of_other: f64,
    // @@protoc_insertion_point(field:results.DefectAddress.feature_uid)
    pub feature_uid: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:results.DefectAddress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DefectAddress {
    fn default() -> &'a DefectAddress {
        <DefectAddress as ::protobuf::Message>::default_instance()
    }
}

impl DefectAddress {
    pub fn new() -> DefectAddress {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dataset_index",
            |m: &DefectAddress| { &m.dataset_index },
            |m: &mut DefectAddress| { &mut m.dataset_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &DefectAddress| { &m.model_id },
            |m: &mut DefectAddress| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "feature_index",
            |m: &DefectAddress| { &m.feature_index },
            |m: &mut DefectAddress| { &mut m.feature_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "overlap_area",
            |m: &DefectAddress| { &m.overlap_area },
            |m: &mut DefectAddress| { &mut m.overlap_area },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "overlap_ratio",
            |m: &DefectAddress| { &m.overlap_ratio },
            |m: &mut DefectAddress| { &mut m.overlap_ratio },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "overlap_ratio_of_other",
            |m: &DefectAddress| { &m.overlap_ratio_of_other },
            |m: &mut DefectAddress| { &mut m.overlap_ratio_of_other },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "feature_uid",
            |m: &DefectAddress| { &m.feature_uid },
            |m: &mut DefectAddress| { &mut m.feature_uid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DefectAddress>(
            "DefectAddress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DefectAddress {
    const NAME: &'static str = "DefectAddress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dataset_index = is.read_int32()?;
                },
                16 => {
                    self.model_id = is.read_int32()?;
                },
                24 => {
                    self.feature_index = is.read_int32()?;
                },
                33 => {
                    self.overlap_area = is.read_double()?;
                },
                41 => {
                    self.overlap_ratio = is.read_double()?;
                },
                49 => {
                    self.overlap_ratio_of_other = is.read_double()?;
                },
                58 => {
                    self.feature_uid = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.dataset_index != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.dataset_index);
        }
        if self.model_id != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.model_id);
        }
        if self.feature_index != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.feature_index);
        }
        if self.overlap_area != 0. {
            my_size += 1 + 8;
        }
        if self.overlap_ratio != 0. {
            my_size += 1 + 8;
        }
        if self.overlap_ratio_of_other != 0. {
            my_size += 1 + 8;
        }
        if !self.feature_uid.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.feature_uid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.dataset_index != 0 {
            os.write_int32(1, self.dataset_index)?;
        }
        if self.model_id != 0 {
            os.write_int32(2, self.model_id)?;
        }
        if self.feature_index != 0 {
            os.write_int32(3, self.feature_index)?;
        }
        if self.overlap_area != 0. {
            os.write_double(4, self.overlap_area)?;
        }
        if self.overlap_ratio != 0. {
            os.write_double(5, self.overlap_ratio)?;
        }
        if self.overlap_ratio_of_other != 0. {
            os.write_double(6, self.overlap_ratio_of_other)?;
        }
        if !self.feature_uid.is_empty() {
            os.write_string(7, &self.feature_uid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DefectAddress {
        DefectAddress::new()
    }

    fn clear(&mut self) {
        self.dataset_index = 0;
        self.model_id = 0;
        self.feature_index = 0;
        self.overlap_area = 0.;
        self.overlap_ratio = 0.;
        self.overlap_ratio_of_other = 0.;
        self.feature_uid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DefectAddress {
        static instance: DefectAddress = DefectAddress {
            dataset_index: 0,
            model_id: 0,
            feature_index: 0,
            overlap_area: 0.,
            overlap_ratio: 0.,
            overlap_ratio_of_other: 0.,
            feature_uid: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DefectAddress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DefectAddress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DefectAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DefectAddress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:results.RowRLC)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RowRLC {
    // message fields
    // @@protoc_insertion_point(field:results.RowRLC.offset_x)
    pub offset_x: i32,
    // @@protoc_insertion_point(field:results.RowRLC.offset_y)
    pub offset_y: i32,
    // @@protoc_insertion_point(field:results.RowRLC.length)
    pub length: i32,
    // special fields
    // @@protoc_insertion_point(special_field:results.RowRLC.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RowRLC {
    fn default() -> &'a RowRLC {
        <RowRLC as ::protobuf::Message>::default_instance()
    }
}

impl RowRLC {
    pub fn new() -> RowRLC {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "offset_x",
            |m: &RowRLC| { &m.offset_x },
            |m: &mut RowRLC| { &mut m.offset_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "offset_y",
            |m: &RowRLC| { &m.offset_y },
            |m: &mut RowRLC| { &mut m.offset_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "length",
            |m: &RowRLC| { &m.length },
            |m: &mut RowRLC| { &mut m.length },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RowRLC>(
            "RowRLC",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RowRLC {
    const NAME: &'static str = "RowRLC";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.offset_x = is.read_int32()?;
                },
                16 => {
                    self.offset_y = is.read_int32()?;
                },
                24 => {
                    self.length = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.offset_x != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.offset_x);
        }
        if self.offset_y != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.offset_y);
        }
        if self.length != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.length);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.offset_x != 0 {
            os.write_int32(1, self.offset_x)?;
        }
        if self.offset_y != 0 {
            os.write_int32(2, self.offset_y)?;
        }
        if self.length != 0 {
            os.write_int32(3, self.length)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RowRLC {
        RowRLC::new()
    }

    fn clear(&mut self) {
        self.offset_x = 0;
        self.offset_y = 0;
        self.length = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RowRLC {
        static instance: RowRLC = RowRLC {
            offset_x: 0,
            offset_y: 0,
            length: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RowRLC {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RowRLC").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RowRLC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RowRLC {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:results.OcrCharacter)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OcrCharacter {
    // message fields
    // @@protoc_insertion_point(field:results.OcrCharacter.character)
    pub character: ::std::string::String,
    // @@protoc_insertion_point(field:results.OcrCharacter.probability)
    pub probability: f64,
    // special fields
    // @@protoc_insertion_point(special_field:results.OcrCharacter.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OcrCharacter {
    fn default() -> &'a OcrCharacter {
        <OcrCharacter as ::protobuf::Message>::default_instance()
    }
}

impl OcrCharacter {
    pub fn new() -> OcrCharacter {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "character",
            |m: &OcrCharacter| { &m.character },
            |m: &mut OcrCharacter| { &mut m.character },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "probability",
            |m: &OcrCharacter| { &m.probability },
            |m: &mut OcrCharacter| { &mut m.probability },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OcrCharacter>(
            "OcrCharacter",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OcrCharacter {
    const NAME: &'static str = "OcrCharacter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.character = is.read_string()?;
                },
                17 => {
                    self.probability = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.character.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.character);
        }
        if self.probability != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.character.is_empty() {
            os.write_string(1, &self.character)?;
        }
        if self.probability != 0. {
            os.write_double(2, self.probability)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OcrCharacter {
        OcrCharacter::new()
    }

    fn clear(&mut self) {
        self.character.clear();
        self.probability = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OcrCharacter {
        static instance: OcrCharacter = OcrCharacter {
            character: ::std::string::String::new(),
            probability: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OcrCharacter {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OcrCharacter").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OcrCharacter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OcrCharacter {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:results.OcrCharacterPosition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OcrCharacterPosition {
    // message fields
    // @@protoc_insertion_point(field:results.OcrCharacterPosition.ocr_character)
    pub ocr_character: ::std::vec::Vec<OcrCharacter>,
    // special fields
    // @@protoc_insertion_point(special_field:results.OcrCharacterPosition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OcrCharacterPosition {
    fn default() -> &'a OcrCharacterPosition {
        <OcrCharacterPosition as ::protobuf::Message>::default_instance()
    }
}

impl OcrCharacterPosition {
    pub fn new() -> OcrCharacterPosition {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ocr_character",
            |m: &OcrCharacterPosition| { &m.ocr_character },
            |m: &mut OcrCharacterPosition| { &mut m.ocr_character },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OcrCharacterPosition>(
            "OcrCharacterPosition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OcrCharacterPosition {
    const NAME: &'static str = "OcrCharacterPosition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ocr_character.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ocr_character {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.ocr_character {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OcrCharacterPosition {
        OcrCharacterPosition::new()
    }

    fn clear(&mut self) {
        self.ocr_character.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OcrCharacterPosition {
        static instance: OcrCharacterPosition = OcrCharacterPosition {
            ocr_character: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OcrCharacterPosition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OcrCharacterPosition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OcrCharacterPosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OcrCharacterPosition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:results.Point)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Point {
    // message fields
    // @@protoc_insertion_point(field:results.Point.x)
    pub x: f64,
    // @@protoc_insertion_point(field:results.Point.y)
    pub y: f64,
    // special fields
    // @@protoc_insertion_point(special_field:results.Point.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Point {
    fn default() -> &'a Point {
        <Point as ::protobuf::Message>::default_instance()
    }
}

impl Point {
    pub fn new() -> Point {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "x",
            |m: &Point| { &m.x },
            |m: &mut Point| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "y",
            |m: &Point| { &m.y },
            |m: &mut Point| { &mut m.y },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Point>(
            "Point",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Point {
    const NAME: &'static str = "Point";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.x = is.read_double()?;
                },
                17 => {
                    self.y = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.x != 0. {
            my_size += 1 + 8;
        }
        if self.y != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.x != 0. {
            os.write_double(1, self.x)?;
        }
        if self.y != 0. {
            os.write_double(2, self.y)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Point {
        Point::new()
    }

    fn clear(&mut self) {
        self.x = 0.;
        self.y = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Point {
        static instance: Point = Point {
            x: 0.,
            y: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Point {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Point").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Point {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Point {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:results.MinimalBoundingBox)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MinimalBoundingBox {
    // message fields
    // @@protoc_insertion_point(field:results.MinimalBoundingBox.center_x)
    pub center_x: f64,
    // @@protoc_insertion_point(field:results.MinimalBoundingBox.center_y)
    pub center_y: f64,
    // @@protoc_insertion_point(field:results.MinimalBoundingBox.width)
    pub width: f64,
    // @@protoc_insertion_point(field:results.MinimalBoundingBox.height)
    pub height: f64,
    // @@protoc_insertion_point(field:results.MinimalBoundingBox.angle)
    pub angle: f64,
    // special fields
    // @@protoc_insertion_point(special_field:results.MinimalBoundingBox.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MinimalBoundingBox {
    fn default() -> &'a MinimalBoundingBox {
        <MinimalBoundingBox as ::protobuf::Message>::default_instance()
    }
}

impl MinimalBoundingBox {
    pub fn new() -> MinimalBoundingBox {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "center_x",
            |m: &MinimalBoundingBox| { &m.center_x },
            |m: &mut MinimalBoundingBox| { &mut m.center_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "center_y",
            |m: &MinimalBoundingBox| { &m.center_y },
            |m: &mut MinimalBoundingBox| { &mut m.center_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "width",
            |m: &MinimalBoundingBox| { &m.width },
            |m: &mut MinimalBoundingBox| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "height",
            |m: &MinimalBoundingBox| { &m.height },
            |m: &mut MinimalBoundingBox| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "angle",
            |m: &MinimalBoundingBox| { &m.angle },
            |m: &mut MinimalBoundingBox| { &mut m.angle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MinimalBoundingBox>(
            "MinimalBoundingBox",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MinimalBoundingBox {
    const NAME: &'static str = "MinimalBoundingBox";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.center_x = is.read_double()?;
                },
                17 => {
                    self.center_y = is.read_double()?;
                },
                25 => {
                    self.width = is.read_double()?;
                },
                33 => {
                    self.height = is.read_double()?;
                },
                41 => {
                    self.angle = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.center_x != 0. {
            my_size += 1 + 8;
        }
        if self.center_y != 0. {
            my_size += 1 + 8;
        }
        if self.width != 0. {
            my_size += 1 + 8;
        }
        if self.height != 0. {
            my_size += 1 + 8;
        }
        if self.angle != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.center_x != 0. {
            os.write_double(1, self.center_x)?;
        }
        if self.center_y != 0. {
            os.write_double(2, self.center_y)?;
        }
        if self.width != 0. {
            os.write_double(3, self.width)?;
        }
        if self.height != 0. {
            os.write_double(4, self.height)?;
        }
        if self.angle != 0. {
            os.write_double(5, self.angle)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MinimalBoundingBox {
        MinimalBoundingBox::new()
    }

    fn clear(&mut self) {
        self.center_x = 0.;
        self.center_y = 0.;
        self.width = 0.;
        self.height = 0.;
        self.angle = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MinimalBoundingBox {
        static instance: MinimalBoundingBox = MinimalBoundingBox {
            center_x: 0.,
            center_y: 0.,
            width: 0.,
            height: 0.,
            angle: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MinimalBoundingBox {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MinimalBoundingBox").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MinimalBoundingBox {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MinimalBoundingBox {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:results.FeatureField)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FeatureField {
    // message fields
    // @@protoc_insertion_point(field:results.FeatureField.label)
    pub label: ::std::string::String,
    // @@protoc_insertion_point(field:results.FeatureField.show)
    pub show: bool,
    // @@protoc_insertion_point(field:results.FeatureField.color)
    pub color: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:results.FeatureField.rect_x)
    pub rect_x: i32,
    // @@protoc_insertion_point(field:results.FeatureField.rect_y)
    pub rect_y: i32,
    // @@protoc_insertion_point(field:results.FeatureField.rect_w)
    pub rect_w: i32,
    // @@protoc_insertion_point(field:results.FeatureField.rect_h)
    pub rect_h: i32,
    // @@protoc_insertion_point(field:results.FeatureField.probability)
    pub probability: f64,
    // @@protoc_insertion_point(field:results.FeatureField.area)
    pub area: f64,
    // @@protoc_insertion_point(field:results.FeatureField.length)
    pub length: f64,
    // @@protoc_insertion_point(field:results.FeatureField.width)
    pub width: f64,
    // @@protoc_insertion_point(field:results.FeatureField.mean_gray)
    pub mean_gray: f64,
    // @@protoc_insertion_point(field:results.FeatureField.max_gray)
    pub max_gray: f64,
    // @@protoc_insertion_point(field:results.FeatureField.min_gray)
    pub min_gray: f64,
    // @@protoc_insertion_point(field:results.FeatureField.in_area)
    pub in_area: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:results.FeatureField.overlaps_with)
    pub overlaps_with: ::std::vec::Vec<DefectAddress>,
    // @@protoc_insertion_point(field:results.FeatureField.rect_x_mm)
    pub rect_x_mm: f64,
    // @@protoc_insertion_point(field:results.FeatureField.rect_y_mm)
    pub rect_y_mm: f64,
    // @@protoc_insertion_point(field:results.FeatureField.rect_w_mm)
    pub rect_w_mm: f64,
    // @@protoc_insertion_point(field:results.FeatureField.rect_h_mm)
    pub rect_h_mm: f64,
    // @@protoc_insertion_point(field:results.FeatureField.row_rlc)
    pub row_rlc: ::std::vec::Vec<RowRLC>,
    // @@protoc_insertion_point(field:results.FeatureField.ocr_character_position)
    pub ocr_character_position: ::std::vec::Vec<OcrCharacterPosition>,
    // @@protoc_insertion_point(field:results.FeatureField.minimal_bounding_box)
    pub minimal_bounding_box: ::protobuf::MessageField<MinimalBoundingBox>,
    // @@protoc_insertion_point(field:results.FeatureField.minimal_bounding_box_point)
    pub minimal_bounding_box_point: ::std::vec::Vec<Point>,
    // @@protoc_insertion_point(field:results.FeatureField.write_protected_label)
    pub write_protected_label: bool,
    // special fields
    // @@protoc_insertion_point(special_field:results.FeatureField.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FeatureField {
    fn default() -> &'a FeatureField {
        <FeatureField as ::protobuf::Message>::default_instance()
    }
}

impl FeatureField {
    pub fn new() -> FeatureField {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(25);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "label",
            |m: &FeatureField| { &m.label },
            |m: &mut FeatureField| { &mut m.label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "show",
            |m: &FeatureField| { &m.show },
            |m: &mut FeatureField| { &mut m.show },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "color",
            |m: &FeatureField| { &m.color },
            |m: &mut FeatureField| { &mut m.color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rect_x",
            |m: &FeatureField| { &m.rect_x },
            |m: &mut FeatureField| { &mut m.rect_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rect_y",
            |m: &FeatureField| { &m.rect_y },
            |m: &mut FeatureField| { &mut m.rect_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rect_w",
            |m: &FeatureField| { &m.rect_w },
            |m: &mut FeatureField| { &mut m.rect_w },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rect_h",
            |m: &FeatureField| { &m.rect_h },
            |m: &mut FeatureField| { &mut m.rect_h },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "probability",
            |m: &FeatureField| { &m.probability },
            |m: &mut FeatureField| { &mut m.probability },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "area",
            |m: &FeatureField| { &m.area },
            |m: &mut FeatureField| { &mut m.area },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "length",
            |m: &FeatureField| { &m.length },
            |m: &mut FeatureField| { &mut m.length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "width",
            |m: &FeatureField| { &m.width },
            |m: &mut FeatureField| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mean_gray",
            |m: &FeatureField| { &m.mean_gray },
            |m: &mut FeatureField| { &mut m.mean_gray },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_gray",
            |m: &FeatureField| { &m.max_gray },
            |m: &mut FeatureField| { &mut m.max_gray },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "min_gray",
            |m: &FeatureField| { &m.min_gray },
            |m: &mut FeatureField| { &mut m.min_gray },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "in_area",
            |m: &FeatureField| { &m.in_area },
            |m: &mut FeatureField| { &mut m.in_area },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "overlaps_with",
            |m: &FeatureField| { &m.overlaps_with },
            |m: &mut FeatureField| { &mut m.overlaps_with },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rect_x_mm",
            |m: &FeatureField| { &m.rect_x_mm },
            |m: &mut FeatureField| { &mut m.rect_x_mm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rect_y_mm",
            |m: &FeatureField| { &m.rect_y_mm },
            |m: &mut FeatureField| { &mut m.rect_y_mm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rect_w_mm",
            |m: &FeatureField| { &m.rect_w_mm },
            |m: &mut FeatureField| { &mut m.rect_w_mm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rect_h_mm",
            |m: &FeatureField| { &m.rect_h_mm },
            |m: &mut FeatureField| { &mut m.rect_h_mm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "row_rlc",
            |m: &FeatureField| { &m.row_rlc },
            |m: &mut FeatureField| { &mut m.row_rlc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ocr_character_position",
            |m: &FeatureField| { &m.ocr_character_position },
            |m: &mut FeatureField| { &mut m.ocr_character_position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MinimalBoundingBox>(
            "minimal_bounding_box",
            |m: &FeatureField| { &m.minimal_bounding_box },
            |m: &mut FeatureField| { &mut m.minimal_bounding_box },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "minimal_bounding_box_point",
            |m: &FeatureField| { &m.minimal_bounding_box_point },
            |m: &mut FeatureField| { &mut m.minimal_bounding_box_point },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "write_protected_label",
            |m: &FeatureField| { &m.write_protected_label },
            |m: &mut FeatureField| { &mut m.write_protected_label },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FeatureField>(
            "FeatureField",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FeatureField {
    const NAME: &'static str = "FeatureField";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.label = is.read_string()?;
                },
                16 => {
                    self.show = is.read_bool()?;
                },
                26 => {
                    is.read_repeated_packed_int32_into(&mut self.color)?;
                },
                24 => {
                    self.color.push(is.read_int32()?);
                },
                32 => {
                    self.rect_x = is.read_int32()?;
                },
                40 => {
                    self.rect_y = is.read_int32()?;
                },
                48 => {
                    self.rect_w = is.read_int32()?;
                },
                56 => {
                    self.rect_h = is.read_int32()?;
                },
                65 => {
                    self.probability = is.read_double()?;
                },
                73 => {
                    self.area = is.read_double()?;
                },
                81 => {
                    self.length = is.read_double()?;
                },
                89 => {
                    self.width = is.read_double()?;
                },
                97 => {
                    self.mean_gray = is.read_double()?;
                },
                105 => {
                    self.max_gray = is.read_double()?;
                },
                113 => {
                    self.min_gray = is.read_double()?;
                },
                122 => {
                    is.read_repeated_packed_int32_into(&mut self.in_area)?;
                },
                120 => {
                    self.in_area.push(is.read_int32()?);
                },
                130 => {
                    self.overlaps_with.push(is.read_message()?);
                },
                137 => {
                    self.rect_x_mm = is.read_double()?;
                },
                145 => {
                    self.rect_y_mm = is.read_double()?;
                },
                153 => {
                    self.rect_w_mm = is.read_double()?;
                },
                161 => {
                    self.rect_h_mm = is.read_double()?;
                },
                170 => {
                    self.row_rlc.push(is.read_message()?);
                },
                178 => {
                    self.ocr_character_position.push(is.read_message()?);
                },
                186 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.minimal_bounding_box)?;
                },
                194 => {
                    self.minimal_bounding_box_point.push(is.read_message()?);
                },
                200 => {
                    self.write_protected_label = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.label);
        }
        if self.show != false {
            my_size += 1 + 1;
        }
        for value in &self.color {
            my_size += ::protobuf::rt::int32_size(3, *value);
        };
        if self.rect_x != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.rect_x);
        }
        if self.rect_y != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.rect_y);
        }
        if self.rect_w != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.rect_w);
        }
        if self.rect_h != 0 {
            my_size += ::protobuf::rt::int32_size(7, self.rect_h);
        }
        if self.probability != 0. {
            my_size += 1 + 8;
        }
        if self.area != 0. {
            my_size += 1 + 8;
        }
        if self.length != 0. {
            my_size += 1 + 8;
        }
        if self.width != 0. {
            my_size += 1 + 8;
        }
        if self.mean_gray != 0. {
            my_size += 1 + 8;
        }
        if self.max_gray != 0. {
            my_size += 1 + 8;
        }
        if self.min_gray != 0. {
            my_size += 1 + 8;
        }
        for value in &self.in_area {
            my_size += ::protobuf::rt::int32_size(15, *value);
        };
        for value in &self.overlaps_with {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.rect_x_mm != 0. {
            my_size += 2 + 8;
        }
        if self.rect_y_mm != 0. {
            my_size += 2 + 8;
        }
        if self.rect_w_mm != 0. {
            my_size += 2 + 8;
        }
        if self.rect_h_mm != 0. {
            my_size += 2 + 8;
        }
        for value in &self.row_rlc {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.ocr_character_position {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.minimal_bounding_box.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.minimal_bounding_box_point {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.write_protected_label != false {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.label.is_empty() {
            os.write_string(1, &self.label)?;
        }
        if self.show != false {
            os.write_bool(2, self.show)?;
        }
        for v in &self.color {
            os.write_int32(3, *v)?;
        };
        if self.rect_x != 0 {
            os.write_int32(4, self.rect_x)?;
        }
        if self.rect_y != 0 {
            os.write_int32(5, self.rect_y)?;
        }
        if self.rect_w != 0 {
            os.write_int32(6, self.rect_w)?;
        }
        if self.rect_h != 0 {
            os.write_int32(7, self.rect_h)?;
        }
        if self.probability != 0. {
            os.write_double(8, self.probability)?;
        }
        if self.area != 0. {
            os.write_double(9, self.area)?;
        }
        if self.length != 0. {
            os.write_double(10, self.length)?;
        }
        if self.width != 0. {
            os.write_double(11, self.width)?;
        }
        if self.mean_gray != 0. {
            os.write_double(12, self.mean_gray)?;
        }
        if self.max_gray != 0. {
            os.write_double(13, self.max_gray)?;
        }
        if self.min_gray != 0. {
            os.write_double(14, self.min_gray)?;
        }
        for v in &self.in_area {
            os.write_int32(15, *v)?;
        };
        for v in &self.overlaps_with {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        };
        if self.rect_x_mm != 0. {
            os.write_double(17, self.rect_x_mm)?;
        }
        if self.rect_y_mm != 0. {
            os.write_double(18, self.rect_y_mm)?;
        }
        if self.rect_w_mm != 0. {
            os.write_double(19, self.rect_w_mm)?;
        }
        if self.rect_h_mm != 0. {
            os.write_double(20, self.rect_h_mm)?;
        }
        for v in &self.row_rlc {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        };
        for v in &self.ocr_character_position {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        };
        if let Some(v) = self.minimal_bounding_box.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        for v in &self.minimal_bounding_box_point {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        };
        if self.write_protected_label != false {
            os.write_bool(25, self.write_protected_label)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FeatureField {
        FeatureField::new()
    }

    fn clear(&mut self) {
        self.label.clear();
        self.show = false;
        self.color.clear();
        self.rect_x = 0;
        self.rect_y = 0;
        self.rect_w = 0;
        self.rect_h = 0;
        self.probability = 0.;
        self.area = 0.;
        self.length = 0.;
        self.width = 0.;
        self.mean_gray = 0.;
        self.max_gray = 0.;
        self.min_gray = 0.;
        self.in_area.clear();
        self.overlaps_with.clear();
        self.rect_x_mm = 0.;
        self.rect_y_mm = 0.;
        self.rect_w_mm = 0.;
        self.rect_h_mm = 0.;
        self.row_rlc.clear();
        self.ocr_character_position.clear();
        self.minimal_bounding_box.clear();
        self.minimal_bounding_box_point.clear();
        self.write_protected_label = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FeatureField {
        static instance: FeatureField = FeatureField {
            label: ::std::string::String::new(),
            show: false,
            color: ::std::vec::Vec::new(),
            rect_x: 0,
            rect_y: 0,
            rect_w: 0,
            rect_h: 0,
            probability: 0.,
            area: 0.,
            length: 0.,
            width: 0.,
            mean_gray: 0.,
            max_gray: 0.,
            min_gray: 0.,
            in_area: ::std::vec::Vec::new(),
            overlaps_with: ::std::vec::Vec::new(),
            rect_x_mm: 0.,
            rect_y_mm: 0.,
            rect_w_mm: 0.,
            rect_h_mm: 0.,
            row_rlc: ::std::vec::Vec::new(),
            ocr_character_position: ::std::vec::Vec::new(),
            minimal_bounding_box: ::protobuf::MessageField::none(),
            minimal_bounding_box_point: ::std::vec::Vec::new(),
            write_protected_label: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FeatureField {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FeatureField").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FeatureField {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureField {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  requires complementary array of type "datatype"
// @@protoc_insertion_point(message:results.MapField)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MapField {
    // message fields
    // @@protoc_insertion_point(field:results.MapField.label)
    pub label: ::std::string::String,
    // @@protoc_insertion_point(field:results.MapField.show)
    pub show: bool,
    // @@protoc_insertion_point(field:results.MapField.color)
    pub color: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:results.MapField.datatype)
    pub datatype: ::protobuf::EnumOrUnknown<MapDataType>,
    // @@protoc_insertion_point(field:results.MapField.image_w)
    pub image_w: i32,
    // @@protoc_insertion_point(field:results.MapField.image_h)
    pub image_h: i32,
    // @@protoc_insertion_point(field:results.MapField.image_c)
    pub image_c: i32,
    // @@protoc_insertion_point(field:results.MapField.start_position)
    pub start_position: i32,
    // @@protoc_insertion_point(field:results.MapField.end_position)
    pub end_position: i32,
    // special fields
    // @@protoc_insertion_point(special_field:results.MapField.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MapField {
    fn default() -> &'a MapField {
        <MapField as ::protobuf::Message>::default_instance()
    }
}

impl MapField {
    pub fn new() -> MapField {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "label",
            |m: &MapField| { &m.label },
            |m: &mut MapField| { &mut m.label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "show",
            |m: &MapField| { &m.show },
            |m: &mut MapField| { &mut m.show },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "color",
            |m: &MapField| { &m.color },
            |m: &mut MapField| { &mut m.color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "datatype",
            |m: &MapField| { &m.datatype },
            |m: &mut MapField| { &mut m.datatype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "image_w",
            |m: &MapField| { &m.image_w },
            |m: &mut MapField| { &mut m.image_w },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "image_h",
            |m: &MapField| { &m.image_h },
            |m: &mut MapField| { &mut m.image_h },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "image_c",
            |m: &MapField| { &m.image_c },
            |m: &mut MapField| { &mut m.image_c },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "start_position",
            |m: &MapField| { &m.start_position },
            |m: &mut MapField| { &mut m.start_position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "end_position",
            |m: &MapField| { &m.end_position },
            |m: &mut MapField| { &mut m.end_position },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MapField>(
            "MapField",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MapField {
    const NAME: &'static str = "MapField";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.label = is.read_string()?;
                },
                16 => {
                    self.show = is.read_bool()?;
                },
                26 => {
                    is.read_repeated_packed_int32_into(&mut self.color)?;
                },
                24 => {
                    self.color.push(is.read_int32()?);
                },
                32 => {
                    self.datatype = is.read_enum_or_unknown()?;
                },
                40 => {
                    self.image_w = is.read_int32()?;
                },
                48 => {
                    self.image_h = is.read_int32()?;
                },
                56 => {
                    self.image_c = is.read_int32()?;
                },
                64 => {
                    self.start_position = is.read_int32()?;
                },
                72 => {
                    self.end_position = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.label.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.label);
        }
        if self.show != false {
            my_size += 1 + 1;
        }
        for value in &self.color {
            my_size += ::protobuf::rt::int32_size(3, *value);
        };
        if self.datatype != ::protobuf::EnumOrUnknown::new(MapDataType::MAP_INT8) {
            my_size += ::protobuf::rt::int32_size(4, self.datatype.value());
        }
        if self.image_w != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.image_w);
        }
        if self.image_h != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.image_h);
        }
        if self.image_c != 0 {
            my_size += ::protobuf::rt::int32_size(7, self.image_c);
        }
        if self.start_position != 0 {
            my_size += ::protobuf::rt::int32_size(8, self.start_position);
        }
        if self.end_position != 0 {
            my_size += ::protobuf::rt::int32_size(9, self.end_position);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.label.is_empty() {
            os.write_string(1, &self.label)?;
        }
        if self.show != false {
            os.write_bool(2, self.show)?;
        }
        for v in &self.color {
            os.write_int32(3, *v)?;
        };
        if self.datatype != ::protobuf::EnumOrUnknown::new(MapDataType::MAP_INT8) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.datatype))?;
        }
        if self.image_w != 0 {
            os.write_int32(5, self.image_w)?;
        }
        if self.image_h != 0 {
            os.write_int32(6, self.image_h)?;
        }
        if self.image_c != 0 {
            os.write_int32(7, self.image_c)?;
        }
        if self.start_position != 0 {
            os.write_int32(8, self.start_position)?;
        }
        if self.end_position != 0 {
            os.write_int32(9, self.end_position)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MapField {
        MapField::new()
    }

    fn clear(&mut self) {
        self.label.clear();
        self.show = false;
        self.color.clear();
        self.datatype = ::protobuf::EnumOrUnknown::new(MapDataType::MAP_INT8);
        self.image_w = 0;
        self.image_h = 0;
        self.image_c = 0;
        self.start_position = 0;
        self.end_position = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MapField {
        static instance: MapField = MapField {
            label: ::std::string::String::new(),
            show: false,
            color: ::std::vec::Vec::new(),
            datatype: ::protobuf::EnumOrUnknown::from_i32(0),
            image_w: 0,
            image_h: 0,
            image_c: 0,
            start_position: 0,
            end_position: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MapField {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MapField").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MapField {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MapField {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:results.ResultField)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ResultField {
    // message fields
    // @@protoc_insertion_point(field:results.ResultField.model_label)
    pub model_label: ::std::string::String,
    // @@protoc_insertion_point(field:results.ResultField.model_tag)
    pub model_tag: ::std::string::String,
    // @@protoc_insertion_point(field:results.ResultField.model_id)
    pub model_id: i32,
    // @@protoc_insertion_point(field:results.ResultField.classifier)
    pub classifier: f64,
    // @@protoc_insertion_point(field:results.ResultField.evaluation_time_ms)
    pub evaluation_time_ms: f64,
    // @@protoc_insertion_point(field:results.ResultField.post_processing_time_ms)
    pub post_processing_time_ms: f64,
    // @@protoc_insertion_point(field:results.ResultField.result_map)
    pub result_map: ::std::vec::Vec<MapField>,
    // @@protoc_insertion_point(field:results.ResultField.feature)
    pub feature: ::std::vec::Vec<FeatureField>,
    // @@protoc_insertion_point(field:results.ResultField.tenant)
    pub tenant: ::std::string::String,
    // @@protoc_insertion_point(field:results.ResultField.tenant_id)
    pub tenant_id: ::std::string::String,
    // @@protoc_insertion_point(field:results.ResultField.onnx_version_major)
    pub onnx_version_major: i32,
    // @@protoc_insertion_point(field:results.ResultField.onnx_version_minor)
    pub onnx_version_minor: i32,
    // @@protoc_insertion_point(field:results.ResultField.feature_uid)
    pub feature_uid: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:results.ResultField.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ResultField {
    fn default() -> &'a ResultField {
        <ResultField as ::protobuf::Message>::default_instance()
    }
}

impl ResultField {
    pub fn new() -> ResultField {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_label",
            |m: &ResultField| { &m.model_label },
            |m: &mut ResultField| { &mut m.model_label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_tag",
            |m: &ResultField| { &m.model_tag },
            |m: &mut ResultField| { &mut m.model_tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_id",
            |m: &ResultField| { &m.model_id },
            |m: &mut ResultField| { &mut m.model_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "classifier",
            |m: &ResultField| { &m.classifier },
            |m: &mut ResultField| { &mut m.classifier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "evaluation_time_ms",
            |m: &ResultField| { &m.evaluation_time_ms },
            |m: &mut ResultField| { &mut m.evaluation_time_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "post_processing_time_ms",
            |m: &ResultField| { &m.post_processing_time_ms },
            |m: &mut ResultField| { &mut m.post_processing_time_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "result_map",
            |m: &ResultField| { &m.result_map },
            |m: &mut ResultField| { &mut m.result_map },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "feature",
            |m: &ResultField| { &m.feature },
            |m: &mut ResultField| { &mut m.feature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tenant",
            |m: &ResultField| { &m.tenant },
            |m: &mut ResultField| { &mut m.tenant },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tenant_id",
            |m: &ResultField| { &m.tenant_id },
            |m: &mut ResultField| { &mut m.tenant_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "onnx_version_major",
            |m: &ResultField| { &m.onnx_version_major },
            |m: &mut ResultField| { &mut m.onnx_version_major },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "onnx_version_minor",
            |m: &ResultField| { &m.onnx_version_minor },
            |m: &mut ResultField| { &mut m.onnx_version_minor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "feature_uid",
            |m: &ResultField| { &m.feature_uid },
            |m: &mut ResultField| { &mut m.feature_uid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResultField>(
            "ResultField",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ResultField {
    const NAME: &'static str = "ResultField";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.model_label = is.read_string()?;
                },
                18 => {
                    self.model_tag = is.read_string()?;
                },
                24 => {
                    self.model_id = is.read_int32()?;
                },
                33 => {
                    self.classifier = is.read_double()?;
                },
                41 => {
                    self.evaluation_time_ms = is.read_double()?;
                },
                49 => {
                    self.post_processing_time_ms = is.read_double()?;
                },
                58 => {
                    self.result_map.push(is.read_message()?);
                },
                66 => {
                    self.feature.push(is.read_message()?);
                },
                74 => {
                    self.tenant = is.read_string()?;
                },
                82 => {
                    self.tenant_id = is.read_string()?;
                },
                88 => {
                    self.onnx_version_major = is.read_int32()?;
                },
                96 => {
                    self.onnx_version_minor = is.read_int32()?;
                },
                106 => {
                    self.feature_uid = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.model_label.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.model_label);
        }
        if !self.model_tag.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_tag);
        }
        if self.model_id != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.model_id);
        }
        if self.classifier != 0. {
            my_size += 1 + 8;
        }
        if self.evaluation_time_ms != 0. {
            my_size += 1 + 8;
        }
        if self.post_processing_time_ms != 0. {
            my_size += 1 + 8;
        }
        for value in &self.result_map {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.feature {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.tenant.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.tenant);
        }
        if !self.tenant_id.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.tenant_id);
        }
        if self.onnx_version_major != 0 {
            my_size += ::protobuf::rt::int32_size(11, self.onnx_version_major);
        }
        if self.onnx_version_minor != 0 {
            my_size += ::protobuf::rt::int32_size(12, self.onnx_version_minor);
        }
        if !self.feature_uid.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.feature_uid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.model_label.is_empty() {
            os.write_string(1, &self.model_label)?;
        }
        if !self.model_tag.is_empty() {
            os.write_string(2, &self.model_tag)?;
        }
        if self.model_id != 0 {
            os.write_int32(3, self.model_id)?;
        }
        if self.classifier != 0. {
            os.write_double(4, self.classifier)?;
        }
        if self.evaluation_time_ms != 0. {
            os.write_double(5, self.evaluation_time_ms)?;
        }
        if self.post_processing_time_ms != 0. {
            os.write_double(6, self.post_processing_time_ms)?;
        }
        for v in &self.result_map {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        for v in &self.feature {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        if !self.tenant.is_empty() {
            os.write_string(9, &self.tenant)?;
        }
        if !self.tenant_id.is_empty() {
            os.write_string(10, &self.tenant_id)?;
        }
        if self.onnx_version_major != 0 {
            os.write_int32(11, self.onnx_version_major)?;
        }
        if self.onnx_version_minor != 0 {
            os.write_int32(12, self.onnx_version_minor)?;
        }
        if !self.feature_uid.is_empty() {
            os.write_string(13, &self.feature_uid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ResultField {
        ResultField::new()
    }

    fn clear(&mut self) {
        self.model_label.clear();
        self.model_tag.clear();
        self.model_id = 0;
        self.classifier = 0.;
        self.evaluation_time_ms = 0.;
        self.post_processing_time_ms = 0.;
        self.result_map.clear();
        self.feature.clear();
        self.tenant.clear();
        self.tenant_id.clear();
        self.onnx_version_major = 0;
        self.onnx_version_minor = 0;
        self.feature_uid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ResultField {
        static instance: ResultField = ResultField {
            model_label: ::std::string::String::new(),
            model_tag: ::std::string::String::new(),
            model_id: 0,
            classifier: 0.,
            evaluation_time_ms: 0.,
            post_processing_time_ms: 0.,
            result_map: ::std::vec::Vec::new(),
            feature: ::std::vec::Vec::new(),
            tenant: ::std::string::String::new(),
            tenant_id: ::std::string::String::new(),
            onnx_version_major: 0,
            onnx_version_minor: 0,
            feature_uid: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ResultField {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ResultField").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ResultField {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResultField {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:results.Summary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Summary {
    // message fields
    // @@protoc_insertion_point(field:results.Summary.image_class)
    pub image_class: i32,
    // @@protoc_insertion_point(field:results.Summary.class_code)
    pub class_code: ::std::string::String,
    // @@protoc_insertion_point(field:results.Summary.most_relevant_defect)
    pub most_relevant_defect: ::std::string::String,
    // @@protoc_insertion_point(field:results.Summary.relevant_defects_json)
    pub relevant_defects_json: ::std::string::String,
    // @@protoc_insertion_point(field:results.Summary.feature_table_json)
    pub feature_table_json: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:results.Summary.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Summary {
    fn default() -> &'a Summary {
        <Summary as ::protobuf::Message>::default_instance()
    }
}

impl Summary {
    pub fn new() -> Summary {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "image_class",
            |m: &Summary| { &m.image_class },
            |m: &mut Summary| { &mut m.image_class },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "class_code",
            |m: &Summary| { &m.class_code },
            |m: &mut Summary| { &mut m.class_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "most_relevant_defect",
            |m: &Summary| { &m.most_relevant_defect },
            |m: &mut Summary| { &mut m.most_relevant_defect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "relevant_defects_json",
            |m: &Summary| { &m.relevant_defects_json },
            |m: &mut Summary| { &mut m.relevant_defects_json },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "feature_table_json",
            |m: &Summary| { &m.feature_table_json },
            |m: &mut Summary| { &mut m.feature_table_json },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Summary>(
            "Summary",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Summary {
    const NAME: &'static str = "Summary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.image_class = is.read_int32()?;
                },
                18 => {
                    self.class_code = is.read_string()?;
                },
                26 => {
                    self.most_relevant_defect = is.read_string()?;
                },
                34 => {
                    self.relevant_defects_json = is.read_string()?;
                },
                42 => {
                    self.feature_table_json = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.image_class != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.image_class);
        }
        if !self.class_code.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.class_code);
        }
        if !self.most_relevant_defect.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.most_relevant_defect);
        }
        if !self.relevant_defects_json.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.relevant_defects_json);
        }
        if !self.feature_table_json.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.feature_table_json);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.image_class != 0 {
            os.write_int32(1, self.image_class)?;
        }
        if !self.class_code.is_empty() {
            os.write_string(2, &self.class_code)?;
        }
        if !self.most_relevant_defect.is_empty() {
            os.write_string(3, &self.most_relevant_defect)?;
        }
        if !self.relevant_defects_json.is_empty() {
            os.write_string(4, &self.relevant_defects_json)?;
        }
        if !self.feature_table_json.is_empty() {
            os.write_string(5, &self.feature_table_json)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Summary {
        Summary::new()
    }

    fn clear(&mut self) {
        self.image_class = 0;
        self.class_code.clear();
        self.most_relevant_defect.clear();
        self.relevant_defects_json.clear();
        self.feature_table_json.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Summary {
        static instance: Summary = Summary {
            image_class: 0,
            class_code: ::std::string::String::new(),
            most_relevant_defect: ::std::string::String::new(),
            relevant_defects_json: ::std::string::String::new(),
            feature_table_json: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Summary {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Summary").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Summary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Summary {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:results.FeatureInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FeatureInfo {
    // message fields
    // @@protoc_insertion_point(field:results.FeatureInfo.feature_uid)
    pub feature_uid: ::std::string::String,
    // @@protoc_insertion_point(field:results.FeatureInfo.feature_name)
    pub feature_name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:results.FeatureInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FeatureInfo {
    fn default() -> &'a FeatureInfo {
        <FeatureInfo as ::protobuf::Message>::default_instance()
    }
}

impl FeatureInfo {
    pub fn new() -> FeatureInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "feature_uid",
            |m: &FeatureInfo| { &m.feature_uid },
            |m: &mut FeatureInfo| { &mut m.feature_uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "feature_name",
            |m: &FeatureInfo| { &m.feature_name },
            |m: &mut FeatureInfo| { &mut m.feature_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FeatureInfo>(
            "FeatureInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FeatureInfo {
    const NAME: &'static str = "FeatureInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.feature_uid = is.read_string()?;
                },
                18 => {
                    self.feature_name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.feature_uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.feature_uid);
        }
        if !self.feature_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.feature_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.feature_uid.is_empty() {
            os.write_string(1, &self.feature_uid)?;
        }
        if !self.feature_name.is_empty() {
            os.write_string(2, &self.feature_name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FeatureInfo {
        FeatureInfo::new()
    }

    fn clear(&mut self) {
        self.feature_uid.clear();
        self.feature_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FeatureInfo {
        static instance: FeatureInfo = FeatureInfo {
            feature_uid: ::std::string::String::new(),
            feature_name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FeatureInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FeatureInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FeatureInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeatureInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:results.ModelInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ModelInfo {
    // message fields
    // @@protoc_insertion_point(field:results.ModelInfo.model_uid)
    pub model_uid: ::std::string::String,
    // @@protoc_insertion_point(field:results.ModelInfo.model_name)
    pub model_name: ::std::string::String,
    // @@protoc_insertion_point(field:results.ModelInfo.features)
    pub features: ::std::vec::Vec<FeatureInfo>,
    // @@protoc_insertion_point(field:results.ModelInfo.tenant)
    pub tenant: ::std::string::String,
    // @@protoc_insertion_point(field:results.ModelInfo.tenant_uid)
    pub tenant_uid: ::std::string::String,
    // @@protoc_insertion_point(field:results.ModelInfo.onnx_version_major)
    pub onnx_version_major: i32,
    // @@protoc_insertion_point(field:results.ModelInfo.onnx_version_minor)
    pub onnx_version_minor: i32,
    // @@protoc_insertion_point(field:results.ModelInfo.model_type)
    pub model_type: ::protobuf::EnumOrUnknown<ModelType>,
    // @@protoc_insertion_point(field:results.ModelInfo.model_output_type)
    pub model_output_type: ::protobuf::EnumOrUnknown<ModelOutputType>,
    // special fields
    // @@protoc_insertion_point(special_field:results.ModelInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModelInfo {
    fn default() -> &'a ModelInfo {
        <ModelInfo as ::protobuf::Message>::default_instance()
    }
}

impl ModelInfo {
    pub fn new() -> ModelInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_uid",
            |m: &ModelInfo| { &m.model_uid },
            |m: &mut ModelInfo| { &mut m.model_uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_name",
            |m: &ModelInfo| { &m.model_name },
            |m: &mut ModelInfo| { &mut m.model_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "features",
            |m: &ModelInfo| { &m.features },
            |m: &mut ModelInfo| { &mut m.features },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tenant",
            |m: &ModelInfo| { &m.tenant },
            |m: &mut ModelInfo| { &mut m.tenant },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tenant_uid",
            |m: &ModelInfo| { &m.tenant_uid },
            |m: &mut ModelInfo| { &mut m.tenant_uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "onnx_version_major",
            |m: &ModelInfo| { &m.onnx_version_major },
            |m: &mut ModelInfo| { &mut m.onnx_version_major },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "onnx_version_minor",
            |m: &ModelInfo| { &m.onnx_version_minor },
            |m: &mut ModelInfo| { &mut m.onnx_version_minor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_type",
            |m: &ModelInfo| { &m.model_type },
            |m: &mut ModelInfo| { &mut m.model_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model_output_type",
            |m: &ModelInfo| { &m.model_output_type },
            |m: &mut ModelInfo| { &mut m.model_output_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModelInfo>(
            "ModelInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModelInfo {
    const NAME: &'static str = "ModelInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.model_uid = is.read_string()?;
                },
                18 => {
                    self.model_name = is.read_string()?;
                },
                26 => {
                    self.features.push(is.read_message()?);
                },
                34 => {
                    self.tenant = is.read_string()?;
                },
                42 => {
                    self.tenant_uid = is.read_string()?;
                },
                48 => {
                    self.onnx_version_major = is.read_int32()?;
                },
                56 => {
                    self.onnx_version_minor = is.read_int32()?;
                },
                64 => {
                    self.model_type = is.read_enum_or_unknown()?;
                },
                72 => {
                    self.model_output_type = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.model_uid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.model_uid);
        }
        if !self.model_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.model_name);
        }
        for value in &self.features {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.tenant.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.tenant);
        }
        if !self.tenant_uid.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.tenant_uid);
        }
        if self.onnx_version_major != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.onnx_version_major);
        }
        if self.onnx_version_minor != 0 {
            my_size += ::protobuf::rt::int32_size(7, self.onnx_version_minor);
        }
        if self.model_type != ::protobuf::EnumOrUnknown::new(ModelType::REGULAR) {
            my_size += ::protobuf::rt::int32_size(8, self.model_type.value());
        }
        if self.model_output_type != ::protobuf::EnumOrUnknown::new(ModelOutputType::TYPE_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(9, self.model_output_type.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.model_uid.is_empty() {
            os.write_string(1, &self.model_uid)?;
        }
        if !self.model_name.is_empty() {
            os.write_string(2, &self.model_name)?;
        }
        for v in &self.features {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if !self.tenant.is_empty() {
            os.write_string(4, &self.tenant)?;
        }
        if !self.tenant_uid.is_empty() {
            os.write_string(5, &self.tenant_uid)?;
        }
        if self.onnx_version_major != 0 {
            os.write_int32(6, self.onnx_version_major)?;
        }
        if self.onnx_version_minor != 0 {
            os.write_int32(7, self.onnx_version_minor)?;
        }
        if self.model_type != ::protobuf::EnumOrUnknown::new(ModelType::REGULAR) {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&self.model_type))?;
        }
        if self.model_output_type != ::protobuf::EnumOrUnknown::new(ModelOutputType::TYPE_UNKNOWN) {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&self.model_output_type))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModelInfo {
        ModelInfo::new()
    }

    fn clear(&mut self) {
        self.model_uid.clear();
        self.model_name.clear();
        self.features.clear();
        self.tenant.clear();
        self.tenant_uid.clear();
        self.onnx_version_major = 0;
        self.onnx_version_minor = 0;
        self.model_type = ::protobuf::EnumOrUnknown::new(ModelType::REGULAR);
        self.model_output_type = ::protobuf::EnumOrUnknown::new(ModelOutputType::TYPE_UNKNOWN);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModelInfo {
        static instance: ModelInfo = ModelInfo {
            model_uid: ::std::string::String::new(),
            model_name: ::std::string::String::new(),
            features: ::std::vec::Vec::new(),
            tenant: ::std::string::String::new(),
            tenant_uid: ::std::string::String::new(),
            onnx_version_major: 0,
            onnx_version_minor: 0,
            model_type: ::protobuf::EnumOrUnknown::from_i32(0),
            model_output_type: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModelInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModelInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModelInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:results.Results)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Results {
    // message fields
    // @@protoc_insertion_point(field:results.Results.output)
    pub output: ::std::vec::Vec<ResultField>,
    // @@protoc_insertion_point(field:results.Results.original_image_w)
    pub original_image_w: i32,
    // @@protoc_insertion_point(field:results.Results.original_image_h)
    pub original_image_h: i32,
    // @@protoc_insertion_point(field:results.Results.original_image_c)
    pub original_image_c: i32,
    // @@protoc_insertion_point(field:results.Results.original_image_w_mm)
    pub original_image_w_mm: f64,
    // @@protoc_insertion_point(field:results.Results.original_image_h_mm)
    pub original_image_h_mm: f64,
    // @@protoc_insertion_point(field:results.Results.original_image_c_mm)
    pub original_image_c_mm: f64,
    // @@protoc_insertion_point(field:results.Results.mean_gray_active_area)
    pub mean_gray_active_area: f64,
    // @@protoc_insertion_point(field:results.Results.result_summary)
    pub result_summary: ::protobuf::MessageField<Summary>,
    // @@protoc_insertion_point(field:results.Results.min_gray_active_area)
    pub min_gray_active_area: f64,
    // @@protoc_insertion_point(field:results.Results.max_gray_active_area)
    pub max_gray_active_area: f64,
    // @@protoc_insertion_point(field:results.Results.available_models)
    pub available_models: ::std::vec::Vec<ModelInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:results.Results.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Results {
    fn default() -> &'a Results {
        <Results as ::protobuf::Message>::default_instance()
    }
}

impl Results {
    pub fn new() -> Results {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "output",
            |m: &Results| { &m.output },
            |m: &mut Results| { &mut m.output },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "original_image_w",
            |m: &Results| { &m.original_image_w },
            |m: &mut Results| { &mut m.original_image_w },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "original_image_h",
            |m: &Results| { &m.original_image_h },
            |m: &mut Results| { &mut m.original_image_h },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "original_image_c",
            |m: &Results| { &m.original_image_c },
            |m: &mut Results| { &mut m.original_image_c },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "original_image_w_mm",
            |m: &Results| { &m.original_image_w_mm },
            |m: &mut Results| { &mut m.original_image_w_mm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "original_image_h_mm",
            |m: &Results| { &m.original_image_h_mm },
            |m: &mut Results| { &mut m.original_image_h_mm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "original_image_c_mm",
            |m: &Results| { &m.original_image_c_mm },
            |m: &mut Results| { &mut m.original_image_c_mm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mean_gray_active_area",
            |m: &Results| { &m.mean_gray_active_area },
            |m: &mut Results| { &mut m.mean_gray_active_area },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Summary>(
            "result_summary",
            |m: &Results| { &m.result_summary },
            |m: &mut Results| { &mut m.result_summary },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "min_gray_active_area",
            |m: &Results| { &m.min_gray_active_area },
            |m: &mut Results| { &mut m.min_gray_active_area },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_gray_active_area",
            |m: &Results| { &m.max_gray_active_area },
            |m: &mut Results| { &mut m.max_gray_active_area },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "available_models",
            |m: &Results| { &m.available_models },
            |m: &mut Results| { &mut m.available_models },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Results>(
            "Results",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Results {
    const NAME: &'static str = "Results";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.output.push(is.read_message()?);
                },
                16 => {
                    self.original_image_w = is.read_int32()?;
                },
                24 => {
                    self.original_image_h = is.read_int32()?;
                },
                32 => {
                    self.original_image_c = is.read_int32()?;
                },
                41 => {
                    self.original_image_w_mm = is.read_double()?;
                },
                49 => {
                    self.original_image_h_mm = is.read_double()?;
                },
                57 => {
                    self.original_image_c_mm = is.read_double()?;
                },
                65 => {
                    self.mean_gray_active_area = is.read_double()?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.result_summary)?;
                },
                81 => {
                    self.min_gray_active_area = is.read_double()?;
                },
                89 => {
                    self.max_gray_active_area = is.read_double()?;
                },
                98 => {
                    self.available_models.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.output {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.original_image_w != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.original_image_w);
        }
        if self.original_image_h != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.original_image_h);
        }
        if self.original_image_c != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.original_image_c);
        }
        if self.original_image_w_mm != 0. {
            my_size += 1 + 8;
        }
        if self.original_image_h_mm != 0. {
            my_size += 1 + 8;
        }
        if self.original_image_c_mm != 0. {
            my_size += 1 + 8;
        }
        if self.mean_gray_active_area != 0. {
            my_size += 1 + 8;
        }
        if let Some(v) = self.result_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.min_gray_active_area != 0. {
            my_size += 1 + 8;
        }
        if self.max_gray_active_area != 0. {
            my_size += 1 + 8;
        }
        for value in &self.available_models {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.output {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.original_image_w != 0 {
            os.write_int32(2, self.original_image_w)?;
        }
        if self.original_image_h != 0 {
            os.write_int32(3, self.original_image_h)?;
        }
        if self.original_image_c != 0 {
            os.write_int32(4, self.original_image_c)?;
        }
        if self.original_image_w_mm != 0. {
            os.write_double(5, self.original_image_w_mm)?;
        }
        if self.original_image_h_mm != 0. {
            os.write_double(6, self.original_image_h_mm)?;
        }
        if self.original_image_c_mm != 0. {
            os.write_double(7, self.original_image_c_mm)?;
        }
        if self.mean_gray_active_area != 0. {
            os.write_double(8, self.mean_gray_active_area)?;
        }
        if let Some(v) = self.result_summary.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if self.min_gray_active_area != 0. {
            os.write_double(10, self.min_gray_active_area)?;
        }
        if self.max_gray_active_area != 0. {
            os.write_double(11, self.max_gray_active_area)?;
        }
        for v in &self.available_models {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Results {
        Results::new()
    }

    fn clear(&mut self) {
        self.output.clear();
        self.original_image_w = 0;
        self.original_image_h = 0;
        self.original_image_c = 0;
        self.original_image_w_mm = 0.;
        self.original_image_h_mm = 0.;
        self.original_image_c_mm = 0.;
        self.mean_gray_active_area = 0.;
        self.result_summary.clear();
        self.min_gray_active_area = 0.;
        self.max_gray_active_area = 0.;
        self.available_models.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Results {
        static instance: Results = Results {
            output: ::std::vec::Vec::new(),
            original_image_w: 0,
            original_image_h: 0,
            original_image_c: 0,
            original_image_w_mm: 0.,
            original_image_h_mm: 0.,
            original_image_c_mm: 0.,
            mean_gray_active_area: 0.,
            result_summary: ::protobuf::MessageField::none(),
            min_gray_active_area: 0.,
            max_gray_active_area: 0.,
            available_models: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Results {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Results").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Results {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Results {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  deprecated
// @@protoc_insertion_point(message:results.ModelOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ModelOptions {
    // message fields
    // @@protoc_insertion_point(field:results.ModelOptions.deactivated)
    pub deactivated: bool,
    // @@protoc_insertion_point(field:results.ModelOptions.minSegmentationThreshold)
    pub minSegmentationThreshold: f64,
    // @@protoc_insertion_point(field:results.ModelOptions.minGrayValue)
    pub minGrayValue: f64,
    // @@protoc_insertion_point(field:results.ModelOptions.maxGrayValue)
    pub maxGrayValue: f64,
    // @@protoc_insertion_point(field:results.ModelOptions.maxMeanGrayValue)
    pub maxMeanGrayValue: f64,
    // @@protoc_insertion_point(field:results.ModelOptions.minProbability)
    pub minProbability: f64,
    // @@protoc_insertion_point(field:results.ModelOptions.minLength)
    pub minLength: f64,
    // @@protoc_insertion_point(field:results.ModelOptions.minWidth)
    pub minWidth: f64,
    // @@protoc_insertion_point(field:results.ModelOptions.minHeight)
    pub minHeight: f64,
    // @@protoc_insertion_point(field:results.ModelOptions.minArea)
    pub minArea: f64,
    // @@protoc_insertion_point(field:results.ModelOptions.minImageClassifier)
    pub minImageClassifier: f64,
    // @@protoc_insertion_point(field:results.ModelOptions.deepGrayLevel)
    pub deepGrayLevel: f64,
    // @@protoc_insertion_point(field:results.ModelOptions.priority)
    pub priority: i32,
    // @@protoc_insertion_point(field:results.ModelOptions.onlyBoundingBoxes)
    pub onlyBoundingBoxes: bool,
    // special fields
    // @@protoc_insertion_point(special_field:results.ModelOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModelOptions {
    fn default() -> &'a ModelOptions {
        <ModelOptions as ::protobuf::Message>::default_instance()
    }
}

impl ModelOptions {
    pub fn new() -> ModelOptions {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "deactivated",
            |m: &ModelOptions| { &m.deactivated },
            |m: &mut ModelOptions| { &mut m.deactivated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "minSegmentationThreshold",
            |m: &ModelOptions| { &m.minSegmentationThreshold },
            |m: &mut ModelOptions| { &mut m.minSegmentationThreshold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "minGrayValue",
            |m: &ModelOptions| { &m.minGrayValue },
            |m: &mut ModelOptions| { &mut m.minGrayValue },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "maxGrayValue",
            |m: &ModelOptions| { &m.maxGrayValue },
            |m: &mut ModelOptions| { &mut m.maxGrayValue },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "maxMeanGrayValue",
            |m: &ModelOptions| { &m.maxMeanGrayValue },
            |m: &mut ModelOptions| { &mut m.maxMeanGrayValue },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "minProbability",
            |m: &ModelOptions| { &m.minProbability },
            |m: &mut ModelOptions| { &mut m.minProbability },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "minLength",
            |m: &ModelOptions| { &m.minLength },
            |m: &mut ModelOptions| { &mut m.minLength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "minWidth",
            |m: &ModelOptions| { &m.minWidth },
            |m: &mut ModelOptions| { &mut m.minWidth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "minHeight",
            |m: &ModelOptions| { &m.minHeight },
            |m: &mut ModelOptions| { &mut m.minHeight },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "minArea",
            |m: &ModelOptions| { &m.minArea },
            |m: &mut ModelOptions| { &mut m.minArea },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "minImageClassifier",
            |m: &ModelOptions| { &m.minImageClassifier },
            |m: &mut ModelOptions| { &mut m.minImageClassifier },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "deepGrayLevel",
            |m: &ModelOptions| { &m.deepGrayLevel },
            |m: &mut ModelOptions| { &mut m.deepGrayLevel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "priority",
            |m: &ModelOptions| { &m.priority },
            |m: &mut ModelOptions| { &mut m.priority },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "onlyBoundingBoxes",
            |m: &ModelOptions| { &m.onlyBoundingBoxes },
            |m: &mut ModelOptions| { &mut m.onlyBoundingBoxes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModelOptions>(
            "ModelOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModelOptions {
    const NAME: &'static str = "ModelOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.deactivated = is.read_bool()?;
                },
                17 => {
                    self.minSegmentationThreshold = is.read_double()?;
                },
                25 => {
                    self.minGrayValue = is.read_double()?;
                },
                33 => {
                    self.maxGrayValue = is.read_double()?;
                },
                41 => {
                    self.maxMeanGrayValue = is.read_double()?;
                },
                49 => {
                    self.minProbability = is.read_double()?;
                },
                57 => {
                    self.minLength = is.read_double()?;
                },
                65 => {
                    self.minWidth = is.read_double()?;
                },
                73 => {
                    self.minHeight = is.read_double()?;
                },
                81 => {
                    self.minArea = is.read_double()?;
                },
                89 => {
                    self.minImageClassifier = is.read_double()?;
                },
                97 => {
                    self.deepGrayLevel = is.read_double()?;
                },
                104 => {
                    self.priority = is.read_int32()?;
                },
                112 => {
                    self.onlyBoundingBoxes = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.deactivated != false {
            my_size += 1 + 1;
        }
        if self.minSegmentationThreshold != 0. {
            my_size += 1 + 8;
        }
        if self.minGrayValue != 0. {
            my_size += 1 + 8;
        }
        if self.maxGrayValue != 0. {
            my_size += 1 + 8;
        }
        if self.maxMeanGrayValue != 0. {
            my_size += 1 + 8;
        }
        if self.minProbability != 0. {
            my_size += 1 + 8;
        }
        if self.minLength != 0. {
            my_size += 1 + 8;
        }
        if self.minWidth != 0. {
            my_size += 1 + 8;
        }
        if self.minHeight != 0. {
            my_size += 1 + 8;
        }
        if self.minArea != 0. {
            my_size += 1 + 8;
        }
        if self.minImageClassifier != 0. {
            my_size += 1 + 8;
        }
        if self.deepGrayLevel != 0. {
            my_size += 1 + 8;
        }
        if self.priority != 0 {
            my_size += ::protobuf::rt::int32_size(13, self.priority);
        }
        if self.onlyBoundingBoxes != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.deactivated != false {
            os.write_bool(1, self.deactivated)?;
        }
        if self.minSegmentationThreshold != 0. {
            os.write_double(2, self.minSegmentationThreshold)?;
        }
        if self.minGrayValue != 0. {
            os.write_double(3, self.minGrayValue)?;
        }
        if self.maxGrayValue != 0. {
            os.write_double(4, self.maxGrayValue)?;
        }
        if self.maxMeanGrayValue != 0. {
            os.write_double(5, self.maxMeanGrayValue)?;
        }
        if self.minProbability != 0. {
            os.write_double(6, self.minProbability)?;
        }
        if self.minLength != 0. {
            os.write_double(7, self.minLength)?;
        }
        if self.minWidth != 0. {
            os.write_double(8, self.minWidth)?;
        }
        if self.minHeight != 0. {
            os.write_double(9, self.minHeight)?;
        }
        if self.minArea != 0. {
            os.write_double(10, self.minArea)?;
        }
        if self.minImageClassifier != 0. {
            os.write_double(11, self.minImageClassifier)?;
        }
        if self.deepGrayLevel != 0. {
            os.write_double(12, self.deepGrayLevel)?;
        }
        if self.priority != 0 {
            os.write_int32(13, self.priority)?;
        }
        if self.onlyBoundingBoxes != false {
            os.write_bool(14, self.onlyBoundingBoxes)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModelOptions {
        ModelOptions::new()
    }

    fn clear(&mut self) {
        self.deactivated = false;
        self.minSegmentationThreshold = 0.;
        self.minGrayValue = 0.;
        self.maxGrayValue = 0.;
        self.maxMeanGrayValue = 0.;
        self.minProbability = 0.;
        self.minLength = 0.;
        self.minWidth = 0.;
        self.minHeight = 0.;
        self.minArea = 0.;
        self.minImageClassifier = 0.;
        self.deepGrayLevel = 0.;
        self.priority = 0;
        self.onlyBoundingBoxes = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModelOptions {
        static instance: ModelOptions = ModelOptions {
            deactivated: false,
            minSegmentationThreshold: 0.,
            minGrayValue: 0.,
            maxGrayValue: 0.,
            maxMeanGrayValue: 0.,
            minProbability: 0.,
            minLength: 0.,
            minWidth: 0.,
            minHeight: 0.,
            minArea: 0.,
            minImageClassifier: 0.,
            deepGrayLevel: 0.,
            priority: 0,
            onlyBoundingBoxes: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModelOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModelOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModelOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModelOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  deprecated
// @@protoc_insertion_point(message:results.OptionContainer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OptionContainer {
    // message fields
    // @@protoc_insertion_point(field:results.OptionContainer.options)
    pub options: ::std::collections::HashMap<i32, ModelOptions>,
    // @@protoc_insertion_point(field:results.OptionContainer.divisor_w)
    pub divisor_w: i32,
    // @@protoc_insertion_point(field:results.OptionContainer.divisor_h)
    pub divisor_h: i32,
    // @@protoc_insertion_point(field:results.OptionContainer.batch_size)
    pub batch_size: i32,
    // @@protoc_insertion_point(field:results.OptionContainer.network_img_prescaling_w)
    pub network_img_prescaling_w: i32,
    // @@protoc_insertion_point(field:results.OptionContainer.network_img_prescaling_h)
    pub network_img_prescaling_h: i32,
    // @@protoc_insertion_point(field:results.OptionContainer.network_img_prescaling_c)
    pub network_img_prescaling_c: i32,
    // @@protoc_insertion_point(field:results.OptionContainer.border_w)
    pub border_w: i32,
    // @@protoc_insertion_point(field:results.OptionContainer.border_h)
    pub border_h: i32,
    // @@protoc_insertion_point(field:results.OptionContainer.border_w_r)
    pub border_w_r: i32,
    // @@protoc_insertion_point(field:results.OptionContainer.border_h_b)
    pub border_h_b: i32,
    // @@protoc_insertion_point(field:results.OptionContainer.cells_w)
    pub cells_w: i32,
    // @@protoc_insertion_point(field:results.OptionContainer.cells_h)
    pub cells_h: i32,
    // special fields
    // @@protoc_insertion_point(special_field:results.OptionContainer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OptionContainer {
    fn default() -> &'a OptionContainer {
        <OptionContainer as ::protobuf::Message>::default_instance()
    }
}

impl OptionContainer {
    pub fn new() -> OptionContainer {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "options",
            |m: &OptionContainer| { &m.options },
            |m: &mut OptionContainer| { &mut m.options },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "divisor_w",
            |m: &OptionContainer| { &m.divisor_w },
            |m: &mut OptionContainer| { &mut m.divisor_w },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "divisor_h",
            |m: &OptionContainer| { &m.divisor_h },
            |m: &mut OptionContainer| { &mut m.divisor_h },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "batch_size",
            |m: &OptionContainer| { &m.batch_size },
            |m: &mut OptionContainer| { &mut m.batch_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "network_img_prescaling_w",
            |m: &OptionContainer| { &m.network_img_prescaling_w },
            |m: &mut OptionContainer| { &mut m.network_img_prescaling_w },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "network_img_prescaling_h",
            |m: &OptionContainer| { &m.network_img_prescaling_h },
            |m: &mut OptionContainer| { &mut m.network_img_prescaling_h },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "network_img_prescaling_c",
            |m: &OptionContainer| { &m.network_img_prescaling_c },
            |m: &mut OptionContainer| { &mut m.network_img_prescaling_c },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "border_w",
            |m: &OptionContainer| { &m.border_w },
            |m: &mut OptionContainer| { &mut m.border_w },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "border_h",
            |m: &OptionContainer| { &m.border_h },
            |m: &mut OptionContainer| { &mut m.border_h },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "border_w_r",
            |m: &OptionContainer| { &m.border_w_r },
            |m: &mut OptionContainer| { &mut m.border_w_r },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "border_h_b",
            |m: &OptionContainer| { &m.border_h_b },
            |m: &mut OptionContainer| { &mut m.border_h_b },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cells_w",
            |m: &OptionContainer| { &m.cells_w },
            |m: &mut OptionContainer| { &mut m.cells_w },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cells_h",
            |m: &OptionContainer| { &m.cells_h },
            |m: &mut OptionContainer| { &mut m.cells_h },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OptionContainer>(
            "OptionContainer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OptionContainer {
    const NAME: &'static str = "OptionContainer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_int32()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.options.insert(key, value);
                },
                16 => {
                    self.divisor_w = is.read_int32()?;
                },
                24 => {
                    self.divisor_h = is.read_int32()?;
                },
                32 => {
                    self.batch_size = is.read_int32()?;
                },
                40 => {
                    self.network_img_prescaling_w = is.read_int32()?;
                },
                48 => {
                    self.network_img_prescaling_h = is.read_int32()?;
                },
                56 => {
                    self.network_img_prescaling_c = is.read_int32()?;
                },
                64 => {
                    self.border_w = is.read_int32()?;
                },
                72 => {
                    self.border_h = is.read_int32()?;
                },
                80 => {
                    self.border_w_r = is.read_int32()?;
                },
                88 => {
                    self.border_h_b = is.read_int32()?;
                },
                96 => {
                    self.cells_w = is.read_int32()?;
                },
                104 => {
                    self.cells_h = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.options {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int32_size(1, *k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if self.divisor_w != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.divisor_w);
        }
        if self.divisor_h != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.divisor_h);
        }
        if self.batch_size != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.batch_size);
        }
        if self.network_img_prescaling_w != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.network_img_prescaling_w);
        }
        if self.network_img_prescaling_h != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.network_img_prescaling_h);
        }
        if self.network_img_prescaling_c != 0 {
            my_size += ::protobuf::rt::int32_size(7, self.network_img_prescaling_c);
        }
        if self.border_w != 0 {
            my_size += ::protobuf::rt::int32_size(8, self.border_w);
        }
        if self.border_h != 0 {
            my_size += ::protobuf::rt::int32_size(9, self.border_h);
        }
        if self.border_w_r != 0 {
            my_size += ::protobuf::rt::int32_size(10, self.border_w_r);
        }
        if self.border_h_b != 0 {
            my_size += ::protobuf::rt::int32_size(11, self.border_h_b);
        }
        if self.cells_w != 0 {
            my_size += ::protobuf::rt::int32_size(12, self.cells_w);
        }
        if self.cells_h != 0 {
            my_size += ::protobuf::rt::int32_size(13, self.cells_h);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.options {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int32_size(1, *k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_int32(1, *k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if self.divisor_w != 0 {
            os.write_int32(2, self.divisor_w)?;
        }
        if self.divisor_h != 0 {
            os.write_int32(3, self.divisor_h)?;
        }
        if self.batch_size != 0 {
            os.write_int32(4, self.batch_size)?;
        }
        if self.network_img_prescaling_w != 0 {
            os.write_int32(5, self.network_img_prescaling_w)?;
        }
        if self.network_img_prescaling_h != 0 {
            os.write_int32(6, self.network_img_prescaling_h)?;
        }
        if self.network_img_prescaling_c != 0 {
            os.write_int32(7, self.network_img_prescaling_c)?;
        }
        if self.border_w != 0 {
            os.write_int32(8, self.border_w)?;
        }
        if self.border_h != 0 {
            os.write_int32(9, self.border_h)?;
        }
        if self.border_w_r != 0 {
            os.write_int32(10, self.border_w_r)?;
        }
        if self.border_h_b != 0 {
            os.write_int32(11, self.border_h_b)?;
        }
        if self.cells_w != 0 {
            os.write_int32(12, self.cells_w)?;
        }
        if self.cells_h != 0 {
            os.write_int32(13, self.cells_h)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OptionContainer {
        OptionContainer::new()
    }

    fn clear(&mut self) {
        self.options.clear();
        self.divisor_w = 0;
        self.divisor_h = 0;
        self.batch_size = 0;
        self.network_img_prescaling_w = 0;
        self.network_img_prescaling_h = 0;
        self.network_img_prescaling_c = 0;
        self.border_w = 0;
        self.border_h = 0;
        self.border_w_r = 0;
        self.border_h_b = 0;
        self.cells_w = 0;
        self.cells_h = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OptionContainer {
        static instance: ::protobuf::rt::Lazy<OptionContainer> = ::protobuf::rt::Lazy::new();
        instance.get(OptionContainer::new)
    }
}

impl ::protobuf::MessageFull for OptionContainer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OptionContainer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OptionContainer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OptionContainer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  CPUs will only have their type and id set
// @@protoc_insertion_point(message:results.Device)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Device {
    // message fields
    // @@protoc_insertion_point(field:results.Device.device_id)
    pub device_id: i32,
    // @@protoc_insertion_point(field:results.Device.type)
    pub type_: ::protobuf::EnumOrUnknown<DeviceType>,
    // @@protoc_insertion_point(field:results.Device.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:results.Device.memory_size)
    pub memory_size: i64,
    // @@protoc_insertion_point(field:results.Device.integrated)
    pub integrated: bool,
    // @@protoc_insertion_point(field:results.Device.cuda_uuid)
    pub cuda_uuid: ::std::string::String,
    // @@protoc_insertion_point(field:results.Device.cuda_compute_capability_major)
    pub cuda_compute_capability_major: i32,
    // @@protoc_insertion_point(field:results.Device.cuda_compute_capability_minor)
    pub cuda_compute_capability_minor: i32,
    // special fields
    // @@protoc_insertion_point(special_field:results.Device.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Device {
    fn default() -> &'a Device {
        <Device as ::protobuf::Message>::default_instance()
    }
}

impl Device {
    pub fn new() -> Device {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &Device| { &m.device_id },
            |m: &mut Device| { &mut m.device_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Device| { &m.type_ },
            |m: &mut Device| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Device| { &m.name },
            |m: &mut Device| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "memory_size",
            |m: &Device| { &m.memory_size },
            |m: &mut Device| { &mut m.memory_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "integrated",
            |m: &Device| { &m.integrated },
            |m: &mut Device| { &mut m.integrated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cuda_uuid",
            |m: &Device| { &m.cuda_uuid },
            |m: &mut Device| { &mut m.cuda_uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cuda_compute_capability_major",
            |m: &Device| { &m.cuda_compute_capability_major },
            |m: &mut Device| { &mut m.cuda_compute_capability_major },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cuda_compute_capability_minor",
            |m: &Device| { &m.cuda_compute_capability_minor },
            |m: &mut Device| { &mut m.cuda_compute_capability_minor },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Device>(
            "Device",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Device {
    const NAME: &'static str = "Device";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.device_id = is.read_int32()?;
                },
                16 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                32 => {
                    self.memory_size = is.read_int64()?;
                },
                40 => {
                    self.integrated = is.read_bool()?;
                },
                50 => {
                    self.cuda_uuid = is.read_string()?;
                },
                56 => {
                    self.cuda_compute_capability_major = is.read_int32()?;
                },
                64 => {
                    self.cuda_compute_capability_minor = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.device_id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.device_id);
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(DeviceType::UNDEFINED) {
            my_size += ::protobuf::rt::int32_size(2, self.type_.value());
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if self.memory_size != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.memory_size);
        }
        if self.integrated != false {
            my_size += 1 + 1;
        }
        if !self.cuda_uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.cuda_uuid);
        }
        if self.cuda_compute_capability_major != 0 {
            my_size += ::protobuf::rt::int32_size(7, self.cuda_compute_capability_major);
        }
        if self.cuda_compute_capability_minor != 0 {
            my_size += ::protobuf::rt::int32_size(8, self.cuda_compute_capability_minor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.device_id != 0 {
            os.write_int32(1, self.device_id)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(DeviceType::UNDEFINED) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if self.memory_size != 0 {
            os.write_int64(4, self.memory_size)?;
        }
        if self.integrated != false {
            os.write_bool(5, self.integrated)?;
        }
        if !self.cuda_uuid.is_empty() {
            os.write_string(6, &self.cuda_uuid)?;
        }
        if self.cuda_compute_capability_major != 0 {
            os.write_int32(7, self.cuda_compute_capability_major)?;
        }
        if self.cuda_compute_capability_minor != 0 {
            os.write_int32(8, self.cuda_compute_capability_minor)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Device {
        Device::new()
    }

    fn clear(&mut self) {
        self.device_id = 0;
        self.type_ = ::protobuf::EnumOrUnknown::new(DeviceType::UNDEFINED);
        self.name.clear();
        self.memory_size = 0;
        self.integrated = false;
        self.cuda_uuid.clear();
        self.cuda_compute_capability_major = 0;
        self.cuda_compute_capability_minor = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Device {
        static instance: Device = Device {
            device_id: 0,
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            name: ::std::string::String::new(),
            memory_size: 0,
            integrated: false,
            cuda_uuid: ::std::string::String::new(),
            cuda_compute_capability_major: 0,
            cuda_compute_capability_minor: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Device {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Device").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Device {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Device {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:results.DeviceInformation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceInformation {
    // message fields
    // @@protoc_insertion_point(field:results.DeviceInformation.device)
    pub device: ::std::vec::Vec<Device>,
    // special fields
    // @@protoc_insertion_point(special_field:results.DeviceInformation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceInformation {
    fn default() -> &'a DeviceInformation {
        <DeviceInformation as ::protobuf::Message>::default_instance()
    }
}

impl DeviceInformation {
    pub fn new() -> DeviceInformation {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "device",
            |m: &DeviceInformation| { &m.device },
            |m: &mut DeviceInformation| { &mut m.device },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceInformation>(
            "DeviceInformation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceInformation {
    const NAME: &'static str = "DeviceInformation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.device.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.device {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.device {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceInformation {
        DeviceInformation::new()
    }

    fn clear(&mut self) {
        self.device.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceInformation {
        static instance: DeviceInformation = DeviceInformation {
            device: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceInformation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceInformation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceInformation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceInformation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:results.MapDataType)
pub enum MapDataType {
    // @@protoc_insertion_point(enum_value:results.MapDataType.MAP_INT8)
    MAP_INT8 = 0,
    // @@protoc_insertion_point(enum_value:results.MapDataType.MAP_INT16)
    MAP_INT16 = 1,
    // @@protoc_insertion_point(enum_value:results.MapDataType.MAP_INT32)
    MAP_INT32 = 2,
    // @@protoc_insertion_point(enum_value:results.MapDataType.MAP_INT64)
    MAP_INT64 = 3,
    // @@protoc_insertion_point(enum_value:results.MapDataType.MAP_UINT8)
    MAP_UINT8 = 4,
    // @@protoc_insertion_point(enum_value:results.MapDataType.MAP_UINT16)
    MAP_UINT16 = 5,
    // @@protoc_insertion_point(enum_value:results.MapDataType.MAP_UINT32)
    MAP_UINT32 = 6,
    // @@protoc_insertion_point(enum_value:results.MapDataType.MAP_UINT64)
    MAP_UINT64 = 7,
    // @@protoc_insertion_point(enum_value:results.MapDataType.MAP_FLOAT8)
    MAP_FLOAT8 = 8,
    // @@protoc_insertion_point(enum_value:results.MapDataType.MAP_FLOAT16)
    MAP_FLOAT16 = 9,
    // @@protoc_insertion_point(enum_value:results.MapDataType.MAP_FLOAT32)
    MAP_FLOAT32 = 10,
    // @@protoc_insertion_point(enum_value:results.MapDataType.MAP_FLOAT64)
    MAP_FLOAT64 = 11,
}

impl ::protobuf::Enum for MapDataType {
    const NAME: &'static str = "MapDataType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MapDataType> {
        match value {
            0 => ::std::option::Option::Some(MapDataType::MAP_INT8),
            1 => ::std::option::Option::Some(MapDataType::MAP_INT16),
            2 => ::std::option::Option::Some(MapDataType::MAP_INT32),
            3 => ::std::option::Option::Some(MapDataType::MAP_INT64),
            4 => ::std::option::Option::Some(MapDataType::MAP_UINT8),
            5 => ::std::option::Option::Some(MapDataType::MAP_UINT16),
            6 => ::std::option::Option::Some(MapDataType::MAP_UINT32),
            7 => ::std::option::Option::Some(MapDataType::MAP_UINT64),
            8 => ::std::option::Option::Some(MapDataType::MAP_FLOAT8),
            9 => ::std::option::Option::Some(MapDataType::MAP_FLOAT16),
            10 => ::std::option::Option::Some(MapDataType::MAP_FLOAT32),
            11 => ::std::option::Option::Some(MapDataType::MAP_FLOAT64),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<MapDataType> {
        match str {
            "MAP_INT8" => ::std::option::Option::Some(MapDataType::MAP_INT8),
            "MAP_INT16" => ::std::option::Option::Some(MapDataType::MAP_INT16),
            "MAP_INT32" => ::std::option::Option::Some(MapDataType::MAP_INT32),
            "MAP_INT64" => ::std::option::Option::Some(MapDataType::MAP_INT64),
            "MAP_UINT8" => ::std::option::Option::Some(MapDataType::MAP_UINT8),
            "MAP_UINT16" => ::std::option::Option::Some(MapDataType::MAP_UINT16),
            "MAP_UINT32" => ::std::option::Option::Some(MapDataType::MAP_UINT32),
            "MAP_UINT64" => ::std::option::Option::Some(MapDataType::MAP_UINT64),
            "MAP_FLOAT8" => ::std::option::Option::Some(MapDataType::MAP_FLOAT8),
            "MAP_FLOAT16" => ::std::option::Option::Some(MapDataType::MAP_FLOAT16),
            "MAP_FLOAT32" => ::std::option::Option::Some(MapDataType::MAP_FLOAT32),
            "MAP_FLOAT64" => ::std::option::Option::Some(MapDataType::MAP_FLOAT64),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MapDataType] = &[
        MapDataType::MAP_INT8,
        MapDataType::MAP_INT16,
        MapDataType::MAP_INT32,
        MapDataType::MAP_INT64,
        MapDataType::MAP_UINT8,
        MapDataType::MAP_UINT16,
        MapDataType::MAP_UINT32,
        MapDataType::MAP_UINT64,
        MapDataType::MAP_FLOAT8,
        MapDataType::MAP_FLOAT16,
        MapDataType::MAP_FLOAT32,
        MapDataType::MAP_FLOAT64,
    ];
}

impl ::protobuf::EnumFull for MapDataType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MapDataType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MapDataType {
    fn default() -> Self {
        MapDataType::MAP_INT8
    }
}

impl MapDataType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MapDataType>("MapDataType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:results.ModelType)
pub enum ModelType {
    // @@protoc_insertion_point(enum_value:results.ModelType.REGULAR)
    REGULAR = 0,
    // @@protoc_insertion_point(enum_value:results.ModelType.AREA_DEFINITION)
    AREA_DEFINITION = 1,
}

impl ::protobuf::Enum for ModelType {
    const NAME: &'static str = "ModelType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ModelType> {
        match value {
            0 => ::std::option::Option::Some(ModelType::REGULAR),
            1 => ::std::option::Option::Some(ModelType::AREA_DEFINITION),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ModelType> {
        match str {
            "REGULAR" => ::std::option::Option::Some(ModelType::REGULAR),
            "AREA_DEFINITION" => ::std::option::Option::Some(ModelType::AREA_DEFINITION),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ModelType] = &[
        ModelType::REGULAR,
        ModelType::AREA_DEFINITION,
    ];
}

impl ::protobuf::EnumFull for ModelType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ModelType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ModelType {
    fn default() -> Self {
        ModelType::REGULAR
    }
}

impl ModelType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ModelType>("ModelType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:results.ModelOutputType)
pub enum ModelOutputType {
    // @@protoc_insertion_point(enum_value:results.ModelOutputType.TYPE_UNKNOWN)
    TYPE_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:results.ModelOutputType.TYPE_CLASSIFICATION)
    TYPE_CLASSIFICATION = 1,
    // @@protoc_insertion_point(enum_value:results.ModelOutputType.TYPE_SEGMENTATION)
    TYPE_SEGMENTATION = 2,
    // @@protoc_insertion_point(enum_value:results.ModelOutputType.TYPE_INSTANCE_SEGMENTATION)
    TYPE_INSTANCE_SEGMENTATION = 3,
    // @@protoc_insertion_point(enum_value:results.ModelOutputType.TYPE_OBJECT_DETECTION)
    TYPE_OBJECT_DETECTION = 4,
    // @@protoc_insertion_point(enum_value:results.ModelOutputType.TYPE_ANOMALY_DETECTION)
    TYPE_ANOMALY_DETECTION = 5,
    // @@protoc_insertion_point(enum_value:results.ModelOutputType.TYPE_OPTICAL_CHARACTER_RECOGNITION)
    TYPE_OPTICAL_CHARACTER_RECOGNITION = 6,
}

impl ::protobuf::Enum for ModelOutputType {
    const NAME: &'static str = "ModelOutputType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ModelOutputType> {
        match value {
            0 => ::std::option::Option::Some(ModelOutputType::TYPE_UNKNOWN),
            1 => ::std::option::Option::Some(ModelOutputType::TYPE_CLASSIFICATION),
            2 => ::std::option::Option::Some(ModelOutputType::TYPE_SEGMENTATION),
            3 => ::std::option::Option::Some(ModelOutputType::TYPE_INSTANCE_SEGMENTATION),
            4 => ::std::option::Option::Some(ModelOutputType::TYPE_OBJECT_DETECTION),
            5 => ::std::option::Option::Some(ModelOutputType::TYPE_ANOMALY_DETECTION),
            6 => ::std::option::Option::Some(ModelOutputType::TYPE_OPTICAL_CHARACTER_RECOGNITION),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ModelOutputType> {
        match str {
            "TYPE_UNKNOWN" => ::std::option::Option::Some(ModelOutputType::TYPE_UNKNOWN),
            "TYPE_CLASSIFICATION" => ::std::option::Option::Some(ModelOutputType::TYPE_CLASSIFICATION),
            "TYPE_SEGMENTATION" => ::std::option::Option::Some(ModelOutputType::TYPE_SEGMENTATION),
            "TYPE_INSTANCE_SEGMENTATION" => ::std::option::Option::Some(ModelOutputType::TYPE_INSTANCE_SEGMENTATION),
            "TYPE_OBJECT_DETECTION" => ::std::option::Option::Some(ModelOutputType::TYPE_OBJECT_DETECTION),
            "TYPE_ANOMALY_DETECTION" => ::std::option::Option::Some(ModelOutputType::TYPE_ANOMALY_DETECTION),
            "TYPE_OPTICAL_CHARACTER_RECOGNITION" => ::std::option::Option::Some(ModelOutputType::TYPE_OPTICAL_CHARACTER_RECOGNITION),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ModelOutputType] = &[
        ModelOutputType::TYPE_UNKNOWN,
        ModelOutputType::TYPE_CLASSIFICATION,
        ModelOutputType::TYPE_SEGMENTATION,
        ModelOutputType::TYPE_INSTANCE_SEGMENTATION,
        ModelOutputType::TYPE_OBJECT_DETECTION,
        ModelOutputType::TYPE_ANOMALY_DETECTION,
        ModelOutputType::TYPE_OPTICAL_CHARACTER_RECOGNITION,
    ];
}

impl ::protobuf::EnumFull for ModelOutputType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ModelOutputType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ModelOutputType {
    fn default() -> Self {
        ModelOutputType::TYPE_UNKNOWN
    }
}

impl ModelOutputType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ModelOutputType>("ModelOutputType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:results.DeviceType)
pub enum DeviceType {
    // @@protoc_insertion_point(enum_value:results.DeviceType.UNDEFINED)
    UNDEFINED = 0,
    // @@protoc_insertion_point(enum_value:results.DeviceType.CPU)
    CPU = 1,
    // @@protoc_insertion_point(enum_value:results.DeviceType.GPU)
    GPU = 2,
}

impl ::protobuf::Enum for DeviceType {
    const NAME: &'static str = "DeviceType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DeviceType> {
        match value {
            0 => ::std::option::Option::Some(DeviceType::UNDEFINED),
            1 => ::std::option::Option::Some(DeviceType::CPU),
            2 => ::std::option::Option::Some(DeviceType::GPU),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DeviceType> {
        match str {
            "UNDEFINED" => ::std::option::Option::Some(DeviceType::UNDEFINED),
            "CPU" => ::std::option::Option::Some(DeviceType::CPU),
            "GPU" => ::std::option::Option::Some(DeviceType::GPU),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DeviceType] = &[
        DeviceType::UNDEFINED,
        DeviceType::CPU,
        DeviceType::GPU,
    ];
}

impl ::protobuf::EnumFull for DeviceType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DeviceType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DeviceType {
    fn default() -> Self {
        DeviceType::UNDEFINED
    }
}

impl DeviceType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DeviceType>("DeviceType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rresults.proto\x12\x07results\"\x92\x02\n\rDefectAddress\x12#\n\rdata\
    set_index\x18\x01\x20\x01(\x05R\x0cdatasetIndex\x12\x19\n\x08model_id\
    \x18\x02\x20\x01(\x05R\x07modelId\x12#\n\rfeature_index\x18\x03\x20\x01(\
    \x05R\x0cfeatureIndex\x12!\n\x0coverlap_area\x18\x04\x20\x01(\x01R\x0bov\
    erlapArea\x12#\n\roverlap_ratio\x18\x05\x20\x01(\x01R\x0coverlapRatio\
    \x123\n\x16overlap_ratio_of_other\x18\x06\x20\x01(\x01R\x13overlapRatioO\
    fOther\x12\x1f\n\x0bfeature_uid\x18\x07\x20\x01(\tR\nfeatureUid\"V\n\x06\
    RowRLC\x12\x19\n\x08offset_x\x18\x01\x20\x01(\x05R\x07offsetX\x12\x19\n\
    \x08offset_y\x18\x02\x20\x01(\x05R\x07offsetY\x12\x16\n\x06length\x18\
    \x03\x20\x01(\x05R\x06length\"N\n\x0cOcrCharacter\x12\x1c\n\tcharacter\
    \x18\x01\x20\x01(\tR\tcharacter\x12\x20\n\x0bprobability\x18\x02\x20\x01\
    (\x01R\x0bprobability\"R\n\x14OcrCharacterPosition\x12:\n\rocr_character\
    \x18\x01\x20\x03(\x0b2\x15.results.OcrCharacterR\x0cocrCharacter\"#\n\
    \x05Point\x12\x0c\n\x01x\x18\x01\x20\x01(\x01R\x01x\x12\x0c\n\x01y\x18\
    \x02\x20\x01(\x01R\x01y\"\x8e\x01\n\x12MinimalBoundingBox\x12\x19\n\x08c\
    enter_x\x18\x01\x20\x01(\x01R\x07centerX\x12\x19\n\x08center_y\x18\x02\
    \x20\x01(\x01R\x07centerY\x12\x14\n\x05width\x18\x03\x20\x01(\x01R\x05wi\
    dth\x12\x16\n\x06height\x18\x04\x20\x01(\x01R\x06height\x12\x14\n\x05ang\
    le\x18\x05\x20\x01(\x01R\x05angle\"\xf6\x06\n\x0cFeatureField\x12\x14\n\
    \x05label\x18\x01\x20\x01(\tR\x05label\x12\x12\n\x04show\x18\x02\x20\x01\
    (\x08R\x04show\x12\x14\n\x05color\x18\x03\x20\x03(\x05R\x05color\x12\x15\
    \n\x06rect_x\x18\x04\x20\x01(\x05R\x05rectX\x12\x15\n\x06rect_y\x18\x05\
    \x20\x01(\x05R\x05rectY\x12\x15\n\x06rect_w\x18\x06\x20\x01(\x05R\x05rec\
    tW\x12\x15\n\x06rect_h\x18\x07\x20\x01(\x05R\x05rectH\x12\x20\n\x0bproba\
    bility\x18\x08\x20\x01(\x01R\x0bprobability\x12\x12\n\x04area\x18\t\x20\
    \x01(\x01R\x04area\x12\x16\n\x06length\x18\n\x20\x01(\x01R\x06length\x12\
    \x14\n\x05width\x18\x0b\x20\x01(\x01R\x05width\x12\x1b\n\tmean_gray\x18\
    \x0c\x20\x01(\x01R\x08meanGray\x12\x19\n\x08max_gray\x18\r\x20\x01(\x01R\
    \x07maxGray\x12\x19\n\x08min_gray\x18\x0e\x20\x01(\x01R\x07minGray\x12\
    \x17\n\x07in_area\x18\x0f\x20\x03(\x05R\x06inArea\x12;\n\roverlaps_with\
    \x18\x10\x20\x03(\x0b2\x16.results.DefectAddressR\x0coverlapsWith\x12\
    \x1a\n\trect_x_mm\x18\x11\x20\x01(\x01R\x07rectXMm\x12\x1a\n\trect_y_mm\
    \x18\x12\x20\x01(\x01R\x07rectYMm\x12\x1a\n\trect_w_mm\x18\x13\x20\x01(\
    \x01R\x07rectWMm\x12\x1a\n\trect_h_mm\x18\x14\x20\x01(\x01R\x07rectHMm\
    \x12(\n\x07row_rlc\x18\x15\x20\x03(\x0b2\x0f.results.RowRLCR\x06rowRlc\
    \x12S\n\x16ocr_character_position\x18\x16\x20\x03(\x0b2\x1d.results.OcrC\
    haracterPositionR\x14ocrCharacterPosition\x12M\n\x14minimal_bounding_box\
    \x18\x17\x20\x01(\x0b2\x1b.results.MinimalBoundingBoxR\x12minimalBoundin\
    gBox\x12K\n\x1aminimal_bounding_box_point\x18\x18\x20\x03(\x0b2\x0e.resu\
    lts.PointR\x17minimalBoundingBoxPoint\x122\n\x15write_protected_label\
    \x18\x19\x20\x01(\x08R\x13writeProtectedLabel\"\x91\x02\n\x08MapField\
    \x12\x14\n\x05label\x18\x01\x20\x01(\tR\x05label\x12\x12\n\x04show\x18\
    \x02\x20\x01(\x08R\x04show\x12\x14\n\x05color\x18\x03\x20\x03(\x05R\x05c\
    olor\x120\n\x08datatype\x18\x04\x20\x01(\x0e2\x14.results.MapDataTypeR\
    \x08datatype\x12\x17\n\x07image_w\x18\x05\x20\x01(\x05R\x06imageW\x12\
    \x17\n\x07image_h\x18\x06\x20\x01(\x05R\x06imageH\x12\x17\n\x07image_c\
    \x18\x07\x20\x01(\x05R\x06imageC\x12%\n\x0estart_position\x18\x08\x20\
    \x01(\x05R\rstartPosition\x12!\n\x0cend_position\x18\t\x20\x01(\x05R\x0b\
    endPosition\"\x80\x04\n\x0bResultField\x12\x1f\n\x0bmodel_label\x18\x01\
    \x20\x01(\tR\nmodelLabel\x12\x1b\n\tmodel_tag\x18\x02\x20\x01(\tR\x08mod\
    elTag\x12\x19\n\x08model_id\x18\x03\x20\x01(\x05R\x07modelId\x12\x1e\n\n\
    classifier\x18\x04\x20\x01(\x01R\nclassifier\x12,\n\x12evaluation_time_m\
    s\x18\x05\x20\x01(\x01R\x10evaluationTimeMs\x125\n\x17post_processing_ti\
    me_ms\x18\x06\x20\x01(\x01R\x14postProcessingTimeMs\x120\n\nresult_map\
    \x18\x07\x20\x03(\x0b2\x11.results.MapFieldR\tresultMap\x12/\n\x07featur\
    e\x18\x08\x20\x03(\x0b2\x15.results.FeatureFieldR\x07feature\x12\x16\n\
    \x06tenant\x18\t\x20\x01(\tR\x06tenant\x12\x1b\n\ttenant_id\x18\n\x20\
    \x01(\tR\x08tenantId\x12,\n\x12onnx_version_major\x18\x0b\x20\x01(\x05R\
    \x10onnxVersionMajor\x12,\n\x12onnx_version_minor\x18\x0c\x20\x01(\x05R\
    \x10onnxVersionMinor\x12\x1f\n\x0bfeature_uid\x18\r\x20\x01(\tR\nfeature\
    Uid\"\xdd\x01\n\x07Summary\x12\x1f\n\x0bimage_class\x18\x01\x20\x01(\x05\
    R\nimageClass\x12\x1d\n\nclass_code\x18\x02\x20\x01(\tR\tclassCode\x120\
    \n\x14most_relevant_defect\x18\x03\x20\x01(\tR\x12mostRelevantDefect\x12\
    2\n\x15relevant_defects_json\x18\x04\x20\x01(\tR\x13relevantDefectsJson\
    \x12,\n\x12feature_table_json\x18\x05\x20\x01(\tR\x10featureTableJson\"Q\
    \n\x0bFeatureInfo\x12\x1f\n\x0bfeature_uid\x18\x01\x20\x01(\tR\nfeatureU\
    id\x12!\n\x0cfeature_name\x18\x02\x20\x01(\tR\x0bfeatureName\"\x85\x03\n\
    \tModelInfo\x12\x1b\n\tmodel_uid\x18\x01\x20\x01(\tR\x08modelUid\x12\x1d\
    \n\nmodel_name\x18\x02\x20\x01(\tR\tmodelName\x120\n\x08features\x18\x03\
    \x20\x03(\x0b2\x14.results.FeatureInfoR\x08features\x12\x16\n\x06tenant\
    \x18\x04\x20\x01(\tR\x06tenant\x12\x1d\n\ntenant_uid\x18\x05\x20\x01(\tR\
    \ttenantUid\x12,\n\x12onnx_version_major\x18\x06\x20\x01(\x05R\x10onnxVe\
    rsionMajor\x12,\n\x12onnx_version_minor\x18\x07\x20\x01(\x05R\x10onnxVer\
    sionMinor\x121\n\nmodel_type\x18\x08\x20\x01(\x0e2\x12.results.ModelType\
    R\tmodelType\x12D\n\x11model_output_type\x18\t\x20\x01(\x0e2\x18.results\
    .ModelOutputTypeR\x0fmodelOutputType\"\xcf\x04\n\x07Results\x12,\n\x06ou\
    tput\x18\x01\x20\x03(\x0b2\x14.results.ResultFieldR\x06output\x12(\n\x10\
    original_image_w\x18\x02\x20\x01(\x05R\x0eoriginalImageW\x12(\n\x10origi\
    nal_image_h\x18\x03\x20\x01(\x05R\x0eoriginalImageH\x12(\n\x10original_i\
    mage_c\x18\x04\x20\x01(\x05R\x0eoriginalImageC\x12-\n\x13original_image_\
    w_mm\x18\x05\x20\x01(\x01R\x10originalImageWMm\x12-\n\x13original_image_\
    h_mm\x18\x06\x20\x01(\x01R\x10originalImageHMm\x12-\n\x13original_image_\
    c_mm\x18\x07\x20\x01(\x01R\x10originalImageCMm\x121\n\x15mean_gray_activ\
    e_area\x18\x08\x20\x01(\x01R\x12meanGrayActiveArea\x127\n\x0eresult_summ\
    ary\x18\t\x20\x01(\x0b2\x10.results.SummaryR\rresultSummary\x12/\n\x14mi\
    n_gray_active_area\x18\n\x20\x01(\x01R\x11minGrayActiveArea\x12/\n\x14ma\
    x_gray_active_area\x18\x0b\x20\x01(\x01R\x11maxGrayActiveArea\x12=\n\x10\
    available_models\x18\x0c\x20\x03(\x0b2\x12.results.ModelInfoR\x0favailab\
    leModels\"\x9a\x04\n\x0cModelOptions\x12\x20\n\x0bdeactivated\x18\x01\
    \x20\x01(\x08R\x0bdeactivated\x12:\n\x18minSegmentationThreshold\x18\x02\
    \x20\x01(\x01R\x18minSegmentationThreshold\x12\"\n\x0cminGrayValue\x18\
    \x03\x20\x01(\x01R\x0cminGrayValue\x12\"\n\x0cmaxGrayValue\x18\x04\x20\
    \x01(\x01R\x0cmaxGrayValue\x12*\n\x10maxMeanGrayValue\x18\x05\x20\x01(\
    \x01R\x10maxMeanGrayValue\x12&\n\x0eminProbability\x18\x06\x20\x01(\x01R\
    \x0eminProbability\x12\x1c\n\tminLength\x18\x07\x20\x01(\x01R\tminLength\
    \x12\x1a\n\x08minWidth\x18\x08\x20\x01(\x01R\x08minWidth\x12\x1c\n\tminH\
    eight\x18\t\x20\x01(\x01R\tminHeight\x12\x18\n\x07minArea\x18\n\x20\x01(\
    \x01R\x07minArea\x12.\n\x12minImageClassifier\x18\x0b\x20\x01(\x01R\x12m\
    inImageClassifier\x12$\n\rdeepGrayLevel\x18\x0c\x20\x01(\x01R\rdeepGrayL\
    evel\x12\x1a\n\x08priority\x18\r\x20\x01(\x05R\x08priority\x12,\n\x11onl\
    yBoundingBoxes\x18\x0e\x20\x01(\x08R\x11onlyBoundingBoxes\"\xcd\x04\n\
    \x0fOptionContainer\x12?\n\x07options\x18\x01\x20\x03(\x0b2%.results.Opt\
    ionContainer.OptionsEntryR\x07options\x12\x1b\n\tdivisor_w\x18\x02\x20\
    \x01(\x05R\x08divisorW\x12\x1b\n\tdivisor_h\x18\x03\x20\x01(\x05R\x08div\
    isorH\x12\x1d\n\nbatch_size\x18\x04\x20\x01(\x05R\tbatchSize\x127\n\x18n\
    etwork_img_prescaling_w\x18\x05\x20\x01(\x05R\x15networkImgPrescalingW\
    \x127\n\x18network_img_prescaling_h\x18\x06\x20\x01(\x05R\x15networkImgP\
    rescalingH\x127\n\x18network_img_prescaling_c\x18\x07\x20\x01(\x05R\x15n\
    etworkImgPrescalingC\x12\x19\n\x08border_w\x18\x08\x20\x01(\x05R\x07bord\
    erW\x12\x19\n\x08border_h\x18\t\x20\x01(\x05R\x07borderH\x12\x1c\n\nbord\
    er_w_r\x18\n\x20\x01(\x05R\x08borderWR\x12\x1c\n\nborder_h_b\x18\x0b\x20\
    \x01(\x05R\x08borderHB\x12\x17\n\x07cells_w\x18\x0c\x20\x01(\x05R\x06cel\
    lsW\x12\x17\n\x07cells_h\x18\r\x20\x01(\x05R\x06cellsH\x1aQ\n\x0cOptions\
    Entry\x12\x10\n\x03key\x18\x01\x20\x01(\x05R\x03key\x12+\n\x05value\x18\
    \x02\x20\x01(\x0b2\x15.results.ModelOptionsR\x05value:\x028\x01\"\xc6\
    \x02\n\x06Device\x12\x1b\n\tdevice_id\x18\x01\x20\x01(\x05R\x08deviceId\
    \x12'\n\x04type\x18\x02\x20\x01(\x0e2\x13.results.DeviceTypeR\x04type\
    \x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x1f\n\x0bmemory_size\
    \x18\x04\x20\x01(\x03R\nmemorySize\x12\x1e\n\nintegrated\x18\x05\x20\x01\
    (\x08R\nintegrated\x12\x1b\n\tcuda_uuid\x18\x06\x20\x01(\tR\x08cudaUuid\
    \x12A\n\x1dcuda_compute_capability_major\x18\x07\x20\x01(\x05R\x1acudaCo\
    mputeCapabilityMajor\x12A\n\x1dcuda_compute_capability_minor\x18\x08\x20\
    \x01(\x05R\x1acudaComputeCapabilityMinor\"<\n\x11DeviceInformation\x12'\
    \n\x06device\x18\x01\x20\x03(\x0b2\x0f.results.DeviceR\x06device*\xca\
    \x01\n\x0bMapDataType\x12\x0c\n\x08MAP_INT8\x10\0\x12\r\n\tMAP_INT16\x10\
    \x01\x12\r\n\tMAP_INT32\x10\x02\x12\r\n\tMAP_INT64\x10\x03\x12\r\n\tMAP_\
    UINT8\x10\x04\x12\x0e\n\nMAP_UINT16\x10\x05\x12\x0e\n\nMAP_UINT32\x10\
    \x06\x12\x0e\n\nMAP_UINT64\x10\x07\x12\x0e\n\nMAP_FLOAT8\x10\x08\x12\x0f\
    \n\x0bMAP_FLOAT16\x10\t\x12\x0f\n\x0bMAP_FLOAT32\x10\n\x12\x0f\n\x0bMAP_\
    FLOAT64\x10\x0b*-\n\tModelType\x12\x0b\n\x07REGULAR\x10\0\x12\x13\n\x0fA\
    REA_DEFINITION\x10\x01*\xd2\x01\n\x0fModelOutputType\x12\x10\n\x0cTYPE_U\
    NKNOWN\x10\0\x12\x17\n\x13TYPE_CLASSIFICATION\x10\x01\x12\x15\n\x11TYPE_\
    SEGMENTATION\x10\x02\x12\x1e\n\x1aTYPE_INSTANCE_SEGMENTATION\x10\x03\x12\
    \x19\n\x15TYPE_OBJECT_DETECTION\x10\x04\x12\x1a\n\x16TYPE_ANOMALY_DETECT\
    ION\x10\x05\x12&\n\"TYPE_OPTICAL_CHARACTER_RECOGNITION\x10\x06*-\n\nDevi\
    ceType\x12\r\n\tUNDEFINED\x10\0\x12\x07\n\x03CPU\x10\x01\x12\x07\n\x03GP\
    U\x10\x02B+Z\x14denkproto-go/results\xaa\x02\x12DENK.Proto.ResultsJ\xcaN\
    \n\x07\x12\x05\x03\0\xe8\x01\x01\n=\n\x01\x0c\x12\x03\x03\0\x1223\x20Def\
    inition\x20of\x20Model\x20File\x20Structure\r\n\x20Version\x200.1\r\n\n\
    \x08\n\x01\x02\x12\x03\x05\0\x10\n\x08\n\x01\x08\x12\x03\x07\0+\n\t\n\
    \x02\x08\x0b\x12\x03\x07\0+\n\x08\n\x01\x08\x12\x03\t\0/\n\t\n\x02\x08%\
    \x12\x03\t\0/\n\n\n\x02\x05\0\x12\x04\x0b\0\x18\x01\n\n\n\x03\x05\0\x01\
    \x12\x03\x0b\x05\x10\n\x0b\n\x04\x05\0\x02\0\x12\x03\x0c\x08\x19\n\x0c\n\
    \x05\x05\0\x02\0\x01\x12\x03\x0c\x08\x10\n\x0c\n\x05\x05\0\x02\0\x02\x12\
    \x03\x0c\x17\x18\n\x0b\n\x04\x05\0\x02\x01\x12\x03\r\x08\x19\n\x0c\n\x05\
    \x05\0\x02\x01\x01\x12\x03\r\x08\x11\n\x0c\n\x05\x05\0\x02\x01\x02\x12\
    \x03\r\x17\x18\n\x0b\n\x04\x05\0\x02\x02\x12\x03\x0e\x08\x19\n\x0c\n\x05\
    \x05\0\x02\x02\x01\x12\x03\x0e\x08\x11\n\x0c\n\x05\x05\0\x02\x02\x02\x12\
    \x03\x0e\x17\x18\n\x0b\n\x04\x05\0\x02\x03\x12\x03\x0f\x08\x19\n\x0c\n\
    \x05\x05\0\x02\x03\x01\x12\x03\x0f\x08\x11\n\x0c\n\x05\x05\0\x02\x03\x02\
    \x12\x03\x0f\x17\x18\n\x0b\n\x04\x05\0\x02\x04\x12\x03\x10\x08\x19\n\x0c\
    \n\x05\x05\0\x02\x04\x01\x12\x03\x10\x08\x11\n\x0c\n\x05\x05\0\x02\x04\
    \x02\x12\x03\x10\x17\x18\n\x0b\n\x04\x05\0\x02\x05\x12\x03\x11\x08\x19\n\
    \x0c\n\x05\x05\0\x02\x05\x01\x12\x03\x11\x08\x12\n\x0c\n\x05\x05\0\x02\
    \x05\x02\x12\x03\x11\x17\x18\n\x0b\n\x04\x05\0\x02\x06\x12\x03\x12\x08\
    \x19\n\x0c\n\x05\x05\0\x02\x06\x01\x12\x03\x12\x08\x12\n\x0c\n\x05\x05\0\
    \x02\x06\x02\x12\x03\x12\x17\x18\n\x0b\n\x04\x05\0\x02\x07\x12\x03\x13\
    \x08\x19\n\x0c\n\x05\x05\0\x02\x07\x01\x12\x03\x13\x08\x12\n\x0c\n\x05\
    \x05\0\x02\x07\x02\x12\x03\x13\x17\x18\n\x0b\n\x04\x05\0\x02\x08\x12\x03\
    \x14\x08\x19\n\x0c\n\x05\x05\0\x02\x08\x01\x12\x03\x14\x08\x12\n\x0c\n\
    \x05\x05\0\x02\x08\x02\x12\x03\x14\x17\x18\n\x0b\n\x04\x05\0\x02\t\x12\
    \x03\x15\x08\x19\n\x0c\n\x05\x05\0\x02\t\x01\x12\x03\x15\x08\x13\n\x0c\n\
    \x05\x05\0\x02\t\x02\x12\x03\x15\x17\x18\n\x0b\n\x04\x05\0\x02\n\x12\x03\
    \x16\x08\x19\n\x0c\n\x05\x05\0\x02\n\x01\x12\x03\x16\x08\x13\n\x0c\n\x05\
    \x05\0\x02\n\x02\x12\x03\x16\x16\x18\n\x0b\n\x04\x05\0\x02\x0b\x12\x03\
    \x17\x08\x19\n\x0c\n\x05\x05\0\x02\x0b\x01\x12\x03\x17\x08\x13\n\x0c\n\
    \x05\x05\0\x02\x0b\x02\x12\x03\x17\x16\x18\n\n\n\x02\x05\x01\x12\x04\x1a\
    \0\x1d\x01\n\n\n\x03\x05\x01\x01\x12\x03\x1a\x05\x0e\n\x0b\n\x04\x05\x01\
    \x02\0\x12\x03\x1b\x08\x1c\n\x0c\n\x05\x05\x01\x02\0\x01\x12\x03\x1b\x08\
    \x0f\n\x0c\n\x05\x05\x01\x02\0\x02\x12\x03\x1b\x1a\x1b\n\x0b\n\x04\x05\
    \x01\x02\x01\x12\x03\x1c\x08\x1c\n\x0c\n\x05\x05\x01\x02\x01\x01\x12\x03\
    \x1c\x08\x17\n\x0c\n\x05\x05\x01\x02\x01\x02\x12\x03\x1c\x1a\x1b\n\n\n\
    \x02\x05\x02\x12\x04\x1f\0'\x01\n\n\n\x03\x05\x02\x01\x12\x03\x1f\x05\
    \x14\n\x0b\n\x04\x05\x02\x02\0\x12\x03\x20\x08/\n\x0c\n\x05\x05\x02\x02\
    \0\x01\x12\x03\x20\x08\x14\n\x0c\n\x05\x05\x02\x02\0\x02\x12\x03\x20-.\n\
    \x0b\n\x04\x05\x02\x02\x01\x12\x03!\x08/\n\x0c\n\x05\x05\x02\x02\x01\x01\
    \x12\x03!\x08\x1b\n\x0c\n\x05\x05\x02\x02\x01\x02\x12\x03!-.\n\x0b\n\x04\
    \x05\x02\x02\x02\x12\x03\"\x08/\n\x0c\n\x05\x05\x02\x02\x02\x01\x12\x03\
    \"\x08\x19\n\x0c\n\x05\x05\x02\x02\x02\x02\x12\x03\"-.\n\x0b\n\x04\x05\
    \x02\x02\x03\x12\x03#\x08/\n\x0c\n\x05\x05\x02\x02\x03\x01\x12\x03#\x08\
    \"\n\x0c\n\x05\x05\x02\x02\x03\x02\x12\x03#-.\n\x0b\n\x04\x05\x02\x02\
    \x04\x12\x03$\x08/\n\x0c\n\x05\x05\x02\x02\x04\x01\x12\x03$\x08\x1d\n\
    \x0c\n\x05\x05\x02\x02\x04\x02\x12\x03$-.\n\x0b\n\x04\x05\x02\x02\x05\
    \x12\x03%\x08/\n\x0c\n\x05\x05\x02\x02\x05\x01\x12\x03%\x08\x1e\n\x0c\n\
    \x05\x05\x02\x02\x05\x02\x12\x03%-.\n\x0b\n\x04\x05\x02\x02\x06\x12\x03&\
    \x08/\n\x0c\n\x05\x05\x02\x02\x06\x01\x12\x03&\x08*\n\x0c\n\x05\x05\x02\
    \x02\x06\x02\x12\x03&-.\n\n\n\x02\x04\0\x12\x04)\01\x01\n\n\n\x03\x04\0\
    \x01\x12\x03)\x08\x15\n\x0b\n\x04\x04\0\x02\0\x12\x03*\x08*\n\x0c\n\x05\
    \x04\0\x02\0\x05\x12\x03*\x08\r\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03*\x0f\
    \x1c\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03*()\n\x0b\n\x04\x04\0\x02\x01\
    \x12\x03+\x08*\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03+\x08\r\n\x0c\n\x05\
    \x04\0\x02\x01\x01\x12\x03+\x0f\x17\n\x0c\n\x05\x04\0\x02\x01\x03\x12\
    \x03+()\n\x0b\n\x04\x04\0\x02\x02\x12\x03,\x08*\n\x0c\n\x05\x04\0\x02\
    \x02\x05\x12\x03,\x08\r\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03,\x0f\x1c\n\
    \x0c\n\x05\x04\0\x02\x02\x03\x12\x03,()\n\x0b\n\x04\x04\0\x02\x03\x12\
    \x03-\x08*\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03-\x08\x0e\n\x0c\n\x05\
    \x04\0\x02\x03\x01\x12\x03-\x0f\x1b\n\x0c\n\x05\x04\0\x02\x03\x03\x12\
    \x03-()\n\x0b\n\x04\x04\0\x02\x04\x12\x03.\x08*\n\x0c\n\x05\x04\0\x02\
    \x04\x05\x12\x03.\x08\x0e\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03.\x0f\x1c\
    \n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03.()\n\x0b\n\x04\x04\0\x02\x05\x12\
    \x03/\x08*\n\x0c\n\x05\x04\0\x02\x05\x05\x12\x03/\x08\x0e\n\x0c\n\x05\
    \x04\0\x02\x05\x01\x12\x03/\x0f%\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03/(\
    )\n\x0b\n\x04\x04\0\x02\x06\x12\x030\x08*\n\x0c\n\x05\x04\0\x02\x06\x05\
    \x12\x030\x08\x0e\n\x0c\n\x05\x04\0\x02\x06\x01\x12\x030\x0f\x1a\n\x0c\n\
    \x05\x04\0\x02\x06\x03\x12\x030()\n\n\n\x02\x04\x01\x12\x043\07\x01\n\n\
    \n\x03\x04\x01\x01\x12\x033\x08\x0e\n\x0b\n\x04\x04\x01\x02\0\x12\x034\
    \x08\x1b\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x034\x08\r\n\x0c\n\x05\x04\
    \x01\x02\0\x01\x12\x034\x0e\x16\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x034\
    \x19\x1a\n\x0b\n\x04\x04\x01\x02\x01\x12\x035\x08\x1b\n\x0c\n\x05\x04\
    \x01\x02\x01\x05\x12\x035\x08\r\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x035\
    \x0e\x16\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x035\x19\x1a\n\x0b\n\x04\
    \x04\x01\x02\x02\x12\x036\x08\x1b\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\
    \x036\x08\r\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x036\x0e\x14\n\x0c\n\x05\
    \x04\x01\x02\x02\x03\x12\x036\x19\x1a\n\n\n\x02\x04\x02\x12\x049\0<\x01\
    \n\n\n\x03\x04\x02\x01\x12\x039\x08\x14\n\x0b\n\x04\x04\x02\x02\0\x12\
    \x03:\x08\x1f\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03:\x08\x0e\n\x0c\n\x05\
    \x04\x02\x02\0\x01\x12\x03:\x0f\x18\n\x0c\n\x05\x04\x02\x02\0\x03\x12\
    \x03:\x1d\x1e\n\x0b\n\x04\x04\x02\x02\x01\x12\x03;\x08\x1f\n\x0c\n\x05\
    \x04\x02\x02\x01\x05\x12\x03;\x08\x0e\n\x0c\n\x05\x04\x02\x02\x01\x01\
    \x12\x03;\x0f\x1a\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03;\x1d\x1e\n\n\n\
    \x02\x04\x03\x12\x04>\0@\x01\n\n\n\x03\x04\x03\x01\x12\x03>\x08\x1c\n\
    \x0b\n\x04\x04\x03\x02\0\x12\x03?\x080\n\x0c\n\x05\x04\x03\x02\0\x04\x12\
    \x03?\x08\x10\n\x0c\n\x05\x04\x03\x02\0\x06\x12\x03?\x11\x1d\n\x0c\n\x05\
    \x04\x03\x02\0\x01\x12\x03?\x1e+\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03?.\
    /\n\n\n\x02\x04\x04\x12\x04B\0E\x01\n\n\n\x03\x04\x04\x01\x12\x03B\x08\r\
    \n\x0b\n\x04\x04\x04\x02\0\x12\x03C\x08\x15\n\x0c\n\x05\x04\x04\x02\0\
    \x05\x12\x03C\x08\x0e\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03C\x0f\x10\n\
    \x0c\n\x05\x04\x04\x02\0\x03\x12\x03C\x13\x14\n\x0b\n\x04\x04\x04\x02\
    \x01\x12\x03D\x08\x15\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03D\x08\x0e\n\
    \x0c\n\x05\x04\x04\x02\x01\x01\x12\x03D\x0f\x10\n\x0c\n\x05\x04\x04\x02\
    \x01\x03\x12\x03D\x13\x14\n\n\n\x02\x04\x05\x12\x04G\0M\x01\n\n\n\x03\
    \x04\x05\x01\x12\x03G\x08\x1a\n\x0b\n\x04\x04\x05\x02\0\x12\x03H\x08\x1c\
    \n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03H\x08\x0e\n\x0c\n\x05\x04\x05\x02\
    \0\x01\x12\x03H\x0f\x17\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03H\x1a\x1b\n\
    \x0b\n\x04\x04\x05\x02\x01\x12\x03I\x08\x1c\n\x0c\n\x05\x04\x05\x02\x01\
    \x05\x12\x03I\x08\x0e\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03I\x0f\x17\n\
    \x0c\n\x05\x04\x05\x02\x01\x03\x12\x03I\x1a\x1b\n\x0b\n\x04\x04\x05\x02\
    \x02\x12\x03J\x08\x1c\n\x0c\n\x05\x04\x05\x02\x02\x05\x12\x03J\x08\x0e\n\
    \x0c\n\x05\x04\x05\x02\x02\x01\x12\x03J\x0f\x14\n\x0c\n\x05\x04\x05\x02\
    \x02\x03\x12\x03J\x1a\x1b\n\x0b\n\x04\x04\x05\x02\x03\x12\x03K\x08\x1c\n\
    \x0c\n\x05\x04\x05\x02\x03\x05\x12\x03K\x08\x0e\n\x0c\n\x05\x04\x05\x02\
    \x03\x01\x12\x03K\x0f\x15\n\x0c\n\x05\x04\x05\x02\x03\x03\x12\x03K\x1a\
    \x1b\n\x0b\n\x04\x04\x05\x02\x04\x12\x03L\x08\x1c\n\x0c\n\x05\x04\x05\
    \x02\x04\x05\x12\x03L\x08\x0e\n\x0c\n\x05\x04\x05\x02\x04\x01\x12\x03L\
    \x0f\x14\n\x0c\n\x05\x04\x05\x02\x04\x03\x12\x03L\x1a\x1b\n\n\n\x02\x04\
    \x06\x12\x04O\0i\x01\n\n\n\x03\x04\x06\x01\x12\x03O\x08\x14\n\x0b\n\x04\
    \x04\x06\x02\0\x12\x03P\x11F\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03P\x11\
    \x17\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03P&+\n\x0c\n\x05\x04\x06\x02\0\
    \x03\x12\x03PDE\n\x0b\n\x04\x04\x06\x02\x01\x12\x03Q\x11F\n\x0c\n\x05\
    \x04\x06\x02\x01\x05\x12\x03Q\x11\x15\n\x0c\n\x05\x04\x06\x02\x01\x01\
    \x12\x03Q&*\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03QDE\n\x0b\n\x04\x04\
    \x06\x02\x02\x12\x03R\x08F\n\x0c\n\x05\x04\x06\x02\x02\x04\x12\x03R\x08\
    \x10\n\x0c\n\x05\x04\x06\x02\x02\x05\x12\x03R\x11\x16\n\x0c\n\x05\x04\
    \x06\x02\x02\x01\x12\x03R&+\n\x0c\n\x05\x04\x06\x02\x02\x03\x12\x03RDE\n\
    \x0b\n\x04\x04\x06\x02\x03\x12\x03S\x11F\n\x0c\n\x05\x04\x06\x02\x03\x05\
    \x12\x03S\x11\x16\n\x0c\n\x05\x04\x06\x02\x03\x01\x12\x03S&,\n\x0c\n\x05\
    \x04\x06\x02\x03\x03\x12\x03SDE\n\x0b\n\x04\x04\x06\x02\x04\x12\x03T\x11\
    F\n\x0c\n\x05\x04\x06\x02\x04\x05\x12\x03T\x11\x16\n\x0c\n\x05\x04\x06\
    \x02\x04\x01\x12\x03T&,\n\x0c\n\x05\x04\x06\x02\x04\x03\x12\x03TDE\n\x0b\
    \n\x04\x04\x06\x02\x05\x12\x03U\x11F\n\x0c\n\x05\x04\x06\x02\x05\x05\x12\
    \x03U\x11\x16\n\x0c\n\x05\x04\x06\x02\x05\x01\x12\x03U&,\n\x0c\n\x05\x04\
    \x06\x02\x05\x03\x12\x03UDE\n\x0b\n\x04\x04\x06\x02\x06\x12\x03V\x11F\n\
    \x0c\n\x05\x04\x06\x02\x06\x05\x12\x03V\x11\x16\n\x0c\n\x05\x04\x06\x02\
    \x06\x01\x12\x03V&,\n\x0c\n\x05\x04\x06\x02\x06\x03\x12\x03VDE\n\x0b\n\
    \x04\x04\x06\x02\x07\x12\x03W\x11F\n\x0c\n\x05\x04\x06\x02\x07\x05\x12\
    \x03W\x11\x17\n\x0c\n\x05\x04\x06\x02\x07\x01\x12\x03W&1\n\x0c\n\x05\x04\
    \x06\x02\x07\x03\x12\x03WDE\n\x0b\n\x04\x04\x06\x02\x08\x12\x03X\x11F\n\
    \x0c\n\x05\x04\x06\x02\x08\x05\x12\x03X\x11\x17\n\x0c\n\x05\x04\x06\x02\
    \x08\x01\x12\x03X&*\n\x0c\n\x05\x04\x06\x02\x08\x03\x12\x03XDE\n\x0b\n\
    \x04\x04\x06\x02\t\x12\x03Y\x11F\n\x0c\n\x05\x04\x06\x02\t\x05\x12\x03Y\
    \x11\x17\n\x0c\n\x05\x04\x06\x02\t\x01\x12\x03Y&,\n\x0c\n\x05\x04\x06\
    \x02\t\x03\x12\x03YCE\n\x0b\n\x04\x04\x06\x02\n\x12\x03Z\x11F\n\x0c\n\
    \x05\x04\x06\x02\n\x05\x12\x03Z\x11\x17\n\x0c\n\x05\x04\x06\x02\n\x01\
    \x12\x03Z&+\n\x0c\n\x05\x04\x06\x02\n\x03\x12\x03ZCE\n\x0b\n\x04\x04\x06\
    \x02\x0b\x12\x03[\x11F\n\x0c\n\x05\x04\x06\x02\x0b\x05\x12\x03[\x11\x17\
    \n\x0c\n\x05\x04\x06\x02\x0b\x01\x12\x03[&/\n\x0c\n\x05\x04\x06\x02\x0b\
    \x03\x12\x03[CE\n\x0b\n\x04\x04\x06\x02\x0c\x12\x03\\\x11F\n\x0c\n\x05\
    \x04\x06\x02\x0c\x05\x12\x03\\\x11\x17\n\x0c\n\x05\x04\x06\x02\x0c\x01\
    \x12\x03\\&.\n\x0c\n\x05\x04\x06\x02\x0c\x03\x12\x03\\CE\n\x0b\n\x04\x04\
    \x06\x02\r\x12\x03]\x11F\n\x0c\n\x05\x04\x06\x02\r\x05\x12\x03]\x11\x17\
    \n\x0c\n\x05\x04\x06\x02\r\x01\x12\x03]&.\n\x0c\n\x05\x04\x06\x02\r\x03\
    \x12\x03]CE\n\x0b\n\x04\x04\x06\x02\x0e\x12\x03^\x08F\n\x0c\n\x05\x04\
    \x06\x02\x0e\x04\x12\x03^\x08\x10\n\x0c\n\x05\x04\x06\x02\x0e\x05\x12\
    \x03^\x11\x16\n\x0c\n\x05\x04\x06\x02\x0e\x01\x12\x03^&-\n\x0c\n\x05\x04\
    \x06\x02\x0e\x03\x12\x03^CE\n\x0b\n\x04\x04\x06\x02\x0f\x12\x03_\x08F\n\
    \x0c\n\x05\x04\x06\x02\x0f\x04\x12\x03_\x08\x10\n\x0c\n\x05\x04\x06\x02\
    \x0f\x06\x12\x03_\x11\x1e\n\x0c\n\x05\x04\x06\x02\x0f\x01\x12\x03_&3\n\
    \x0c\n\x05\x04\x06\x02\x0f\x03\x12\x03_CE\n\x0b\n\x04\x04\x06\x02\x10\
    \x12\x03`\x11F\n\x0c\n\x05\x04\x06\x02\x10\x05\x12\x03`\x11\x17\n\x0c\n\
    \x05\x04\x06\x02\x10\x01\x12\x03`&/\n\x0c\n\x05\x04\x06\x02\x10\x03\x12\
    \x03`CE\n\x0b\n\x04\x04\x06\x02\x11\x12\x03a\x11F\n\x0c\n\x05\x04\x06\
    \x02\x11\x05\x12\x03a\x11\x17\n\x0c\n\x05\x04\x06\x02\x11\x01\x12\x03a&/\
    \n\x0c\n\x05\x04\x06\x02\x11\x03\x12\x03aCE\n\x0b\n\x04\x04\x06\x02\x12\
    \x12\x03b\x11F\n\x0c\n\x05\x04\x06\x02\x12\x05\x12\x03b\x11\x17\n\x0c\n\
    \x05\x04\x06\x02\x12\x01\x12\x03b&/\n\x0c\n\x05\x04\x06\x02\x12\x03\x12\
    \x03bCE\n\x0b\n\x04\x04\x06\x02\x13\x12\x03c\x11F\n\x0c\n\x05\x04\x06\
    \x02\x13\x05\x12\x03c\x11\x17\n\x0c\n\x05\x04\x06\x02\x13\x01\x12\x03c&/\
    \n\x0c\n\x05\x04\x06\x02\x13\x03\x12\x03cCE\n\x0b\n\x04\x04\x06\x02\x14\
    \x12\x03d\x08F\n\x0c\n\x05\x04\x06\x02\x14\x04\x12\x03d\x08\x10\n\x0c\n\
    \x05\x04\x06\x02\x14\x06\x12\x03d\x11\x17\n\x0c\n\x05\x04\x06\x02\x14\
    \x01\x12\x03d&-\n\x0c\n\x05\x04\x06\x02\x14\x03\x12\x03dCE\n\x0b\n\x04\
    \x04\x06\x02\x15\x12\x03e\x08F\n\x0c\n\x05\x04\x06\x02\x15\x04\x12\x03e\
    \x08\x10\n\x0c\n\x05\x04\x06\x02\x15\x06\x12\x03e\x11%\n\x0c\n\x05\x04\
    \x06\x02\x15\x01\x12\x03e&<\n\x0c\n\x05\x04\x06\x02\x15\x03\x12\x03eCE\n\
    \x0b\n\x04\x04\x06\x02\x16\x12\x03f\x11F\n\x0c\n\x05\x04\x06\x02\x16\x06\
    \x12\x03f\x11#\n\x0c\n\x05\x04\x06\x02\x16\x01\x12\x03f&:\n\x0c\n\x05\
    \x04\x06\x02\x16\x03\x12\x03fCE\n\x0b\n\x04\x04\x06\x02\x17\x12\x03g\x08\
    F\n\x0c\n\x05\x04\x06\x02\x17\x04\x12\x03g\x08\x10\n\x0c\n\x05\x04\x06\
    \x02\x17\x06\x12\x03g\x11\x16\n\x0c\n\x05\x04\x06\x02\x17\x01\x12\x03g&@\
    \n\x0c\n\x05\x04\x06\x02\x17\x03\x12\x03gCE\n\x0b\n\x04\x04\x06\x02\x18\
    \x12\x03h\x11F\n\x0c\n\x05\x04\x06\x02\x18\x05\x12\x03h\x11\x15\n\x0c\n\
    \x05\x04\x06\x02\x18\x01\x12\x03h&;\n\x0c\n\x05\x04\x06\x02\x18\x03\x12\
    \x03hCE\n>\n\x02\x04\x07\x12\x04l\0v\x01\x1a2\x20requires\x20complementa\
    ry\x20array\x20of\x20type\x20\"datatype\"\r\n\n\n\n\x03\x04\x07\x01\x12\
    \x03l\x08\x10\n\x0b\n\x04\x04\x07\x02\0\x12\x03m\x110\n\x0c\n\x05\x04\
    \x07\x02\0\x05\x12\x03m\x11\x17\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03m\
    \x1d\"\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03m./\n\x0b\n\x04\x04\x07\x02\
    \x01\x12\x03n\x110\n\x0c\n\x05\x04\x07\x02\x01\x05\x12\x03n\x11\x15\n\
    \x0c\n\x05\x04\x07\x02\x01\x01\x12\x03n\x1d!\n\x0c\n\x05\x04\x07\x02\x01\
    \x03\x12\x03n./\n\x0b\n\x04\x04\x07\x02\x02\x12\x03o\x080\n\x0c\n\x05\
    \x04\x07\x02\x02\x04\x12\x03o\x08\x10\n\x0c\n\x05\x04\x07\x02\x02\x05\
    \x12\x03o\x11\x16\n\x0c\n\x05\x04\x07\x02\x02\x01\x12\x03o\x1d\"\n\x0c\n\
    \x05\x04\x07\x02\x02\x03\x12\x03o./\n\x0b\n\x04\x04\x07\x02\x03\x12\x03p\
    \x110\n\x0c\n\x05\x04\x07\x02\x03\x06\x12\x03p\x11\x1c\n\x0c\n\x05\x04\
    \x07\x02\x03\x01\x12\x03p\x1d%\n\x0c\n\x05\x04\x07\x02\x03\x03\x12\x03p.\
    /\n\x0b\n\x04\x04\x07\x02\x04\x12\x03q\x110\n\x0c\n\x05\x04\x07\x02\x04\
    \x05\x12\x03q\x11\x16\n\x0c\n\x05\x04\x07\x02\x04\x01\x12\x03q\x1d$\n\
    \x0c\n\x05\x04\x07\x02\x04\x03\x12\x03q./\n\x0b\n\x04\x04\x07\x02\x05\
    \x12\x03r\x110\n\x0c\n\x05\x04\x07\x02\x05\x05\x12\x03r\x11\x16\n\x0c\n\
    \x05\x04\x07\x02\x05\x01\x12\x03r\x1d$\n\x0c\n\x05\x04\x07\x02\x05\x03\
    \x12\x03r./\n\x0b\n\x04\x04\x07\x02\x06\x12\x03s\x110\n\x0c\n\x05\x04\
    \x07\x02\x06\x05\x12\x03s\x11\x16\n\x0c\n\x05\x04\x07\x02\x06\x01\x12\
    \x03s\x1d$\n\x0c\n\x05\x04\x07\x02\x06\x03\x12\x03s./\n\x0b\n\x04\x04\
    \x07\x02\x07\x12\x03t\x110\n\x0c\n\x05\x04\x07\x02\x07\x05\x12\x03t\x11\
    \x16\n\x0c\n\x05\x04\x07\x02\x07\x01\x12\x03t\x1d+\n\x0c\n\x05\x04\x07\
    \x02\x07\x03\x12\x03t./\n\x0b\n\x04\x04\x07\x02\x08\x12\x03u\x110\n\x0c\
    \n\x05\x04\x07\x02\x08\x05\x12\x03u\x11\x16\n\x0c\n\x05\x04\x07\x02\x08\
    \x01\x12\x03u\x1d)\n\x0c\n\x05\x04\x07\x02\x08\x03\x12\x03u./\n\x0b\n\
    \x02\x04\x08\x12\x05x\0\x86\x01\x01\n\n\n\x03\x04\x08\x01\x12\x03x\x08\
    \x13\n\x0b\n\x04\x04\x08\x02\0\x12\x03y\x08/\n\x0c\n\x05\x04\x08\x02\0\
    \x05\x12\x03y\x08\x0e\n\x0c\n\x05\x04\x08\x02\0\x01\x12\x03y\x11\x1c\n\
    \x0c\n\x05\x04\x08\x02\0\x03\x12\x03y-.\n\x0b\n\x04\x04\x08\x02\x01\x12\
    \x03z\x08/\n\x0c\n\x05\x04\x08\x02\x01\x05\x12\x03z\x08\x0e\n\x0c\n\x05\
    \x04\x08\x02\x01\x01\x12\x03z\x11\x1a\n\x0c\n\x05\x04\x08\x02\x01\x03\
    \x12\x03z-.\n\x1a\n\x04\x04\x08\x02\x02\x12\x03{\x08/\"\r\x20deprecated\
    \r\n\n\x0c\n\x05\x04\x08\x02\x02\x05\x12\x03{\x08\r\n\x0c\n\x05\x04\x08\
    \x02\x02\x01\x12\x03{\x11\x19\n\x0c\n\x05\x04\x08\x02\x02\x03\x12\x03{-.\
    \n\x0b\n\x04\x04\x08\x02\x03\x12\x03|\x08/\n\x0c\n\x05\x04\x08\x02\x03\
    \x05\x12\x03|\x08\x0e\n\x0c\n\x05\x04\x08\x02\x03\x01\x12\x03|\x11\x1b\n\
    \x0c\n\x05\x04\x08\x02\x03\x03\x12\x03|-.\n\x0b\n\x04\x04\x08\x02\x04\
    \x12\x03}\x08/\n\x0c\n\x05\x04\x08\x02\x04\x05\x12\x03}\x08\x0e\n\x0c\n\
    \x05\x04\x08\x02\x04\x01\x12\x03}\x11#\n\x0c\n\x05\x04\x08\x02\x04\x03\
    \x12\x03}-.\n\x0b\n\x04\x04\x08\x02\x05\x12\x03~\x08/\n\x0c\n\x05\x04\
    \x08\x02\x05\x05\x12\x03~\x08\x0e\n\x0c\n\x05\x04\x08\x02\x05\x01\x12\
    \x03~\x11(\n\x0c\n\x05\x04\x08\x02\x05\x03\x12\x03~-.\n\x0b\n\x04\x04\
    \x08\x02\x06\x12\x03\x7f\x08/\n\x0c\n\x05\x04\x08\x02\x06\x04\x12\x03\
    \x7f\x08\x10\n\x0c\n\x05\x04\x08\x02\x06\x06\x12\x03\x7f\x11\x19\n\x0c\n\
    \x05\x04\x08\x02\x06\x01\x12\x03\x7f\x1a$\n\x0c\n\x05\x04\x08\x02\x06\
    \x03\x12\x03\x7f-.\n\x0c\n\x04\x04\x08\x02\x07\x12\x04\x80\x01\x08/\n\r\
    \n\x05\x04\x08\x02\x07\x04\x12\x04\x80\x01\x08\x10\n\r\n\x05\x04\x08\x02\
    \x07\x06\x12\x04\x80\x01\x11\x1d\n\r\n\x05\x04\x08\x02\x07\x01\x12\x04\
    \x80\x01\x1e%\n\r\n\x05\x04\x08\x02\x07\x03\x12\x04\x80\x01-.\nF\n\x04\
    \x04\x08\x02\x08\x12\x04\x81\x01\x08/\"8\x20Used\x20for\x20communicating\
    \x20the\x20tenant\x20to\x20the\x20main\x20program\r\n\n\r\n\x05\x04\x08\
    \x02\x08\x05\x12\x04\x81\x01\x08\x0e\n\r\n\x05\x04\x08\x02\x08\x01\x12\
    \x04\x81\x01\x11\x17\n\r\n\x05\x04\x08\x02\x08\x03\x12\x04\x81\x01-.\nI\
    \n\x04\x04\x08\x02\t\x12\x04\x82\x01\x08/\";\x20Used\x20for\x20communica\
    ting\x20the\x20tenant-ID\x20to\x20the\x20main\x20program\r\n\n\r\n\x05\
    \x04\x08\x02\t\x05\x12\x04\x82\x01\x08\x0e\n\r\n\x05\x04\x08\x02\t\x01\
    \x12\x04\x82\x01\x11\x1a\n\r\n\x05\x04\x08\x02\t\x03\x12\x04\x82\x01,.\n\
    T\n\x04\x04\x08\x02\n\x12\x04\x83\x01\x08/\"F\x20Used\x20for\x20communic\
    ating\x20the\x20network\x20onnx\x20version\x20to\x20the\x20main\x20progr\
    am\r\n\n\r\n\x05\x04\x08\x02\n\x05\x12\x04\x83\x01\x08\r\n\r\n\x05\x04\
    \x08\x02\n\x01\x12\x04\x83\x01\x11#\n\r\n\x05\x04\x08\x02\n\x03\x12\x04\
    \x83\x01,.\nT\n\x04\x04\x08\x02\x0b\x12\x04\x84\x01\x08/\"F\x20Used\x20f\
    or\x20communicating\x20the\x20network\x20onnx\x20version\x20to\x20the\
    \x20main\x20program\r\n\n\r\n\x05\x04\x08\x02\x0b\x05\x12\x04\x84\x01\
    \x08\r\n\r\n\x05\x04\x08\x02\x0b\x01\x12\x04\x84\x01\x11#\n\r\n\x05\x04\
    \x08\x02\x0b\x03\x12\x04\x84\x01,.\n\x0c\n\x04\x04\x08\x02\x0c\x12\x04\
    \x85\x01\x08/\n\r\n\x05\x04\x08\x02\x0c\x05\x12\x04\x85\x01\x08\x0e\n\r\
    \n\x05\x04\x08\x02\x0c\x01\x12\x04\x85\x01\x11\x1c\n\r\n\x05\x04\x08\x02\
    \x0c\x03\x12\x04\x85\x01,.\n\x0c\n\x02\x04\t\x12\x06\x88\x01\0\x8e\x01\
    \x01\n\x0b\n\x03\x04\t\x01\x12\x04\x88\x01\x08\x0f\n\x0c\n\x04\x04\t\x02\
    \0\x12\x04\x89\x01\x08)\n\r\n\x05\x04\t\x02\0\x05\x12\x04\x89\x01\x08\r\
    \n\r\n\x05\x04\t\x02\0\x01\x12\x04\x89\x01\x0f\x1a\n\r\n\x05\x04\t\x02\0\
    \x03\x12\x04\x89\x01'(\n\x0c\n\x04\x04\t\x02\x01\x12\x04\x8a\x01\x08)\n\
    \r\n\x05\x04\t\x02\x01\x05\x12\x04\x8a\x01\x08\x0e\n\r\n\x05\x04\t\x02\
    \x01\x01\x12\x04\x8a\x01\x0f\x19\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\x8a\
    \x01'(\n\x0c\n\x04\x04\t\x02\x02\x12\x04\x8b\x01\x08)\n\r\n\x05\x04\t\
    \x02\x02\x05\x12\x04\x8b\x01\x08\x0e\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\
    \x8b\x01\x0f#\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\x8b\x01'(\n\x0c\n\x04\
    \x04\t\x02\x03\x12\x04\x8c\x01\x08)\n\r\n\x05\x04\t\x02\x03\x05\x12\x04\
    \x8c\x01\x08\x0e\n\r\n\x05\x04\t\x02\x03\x01\x12\x04\x8c\x01\x0f$\n\r\n\
    \x05\x04\t\x02\x03\x03\x12\x04\x8c\x01'(\n\x0c\n\x04\x04\t\x02\x04\x12\
    \x04\x8d\x01\x08)\n\r\n\x05\x04\t\x02\x04\x05\x12\x04\x8d\x01\x08\x0e\n\
    \r\n\x05\x04\t\x02\x04\x01\x12\x04\x8d\x01\x0f!\n\r\n\x05\x04\t\x02\x04\
    \x03\x12\x04\x8d\x01'(\n\x0c\n\x02\x04\n\x12\x06\x90\x01\0\x93\x01\x01\n\
    \x0b\n\x03\x04\n\x01\x12\x04\x90\x01\x08\x13\n\x0c\n\x04\x04\n\x02\0\x12\
    \x04\x91\x01\x08\x20\n\r\n\x05\x04\n\x02\0\x05\x12\x04\x91\x01\x08\x0e\n\
    \r\n\x05\x04\n\x02\0\x01\x12\x04\x91\x01\x0f\x1a\n\r\n\x05\x04\n\x02\0\
    \x03\x12\x04\x91\x01\x1e\x1f\n\x0c\n\x04\x04\n\x02\x01\x12\x04\x92\x01\
    \x08\x20\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\x92\x01\x08\x0e\n\r\n\x05\
    \x04\n\x02\x01\x01\x12\x04\x92\x01\x0f\x1b\n\r\n\x05\x04\n\x02\x01\x03\
    \x12\x04\x92\x01\x1e\x1f\n\x0c\n\x02\x04\x0b\x12\x06\x95\x01\0\x9f\x01\
    \x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\x95\x01\x08\x11\n\x0c\n\x04\x04\x0b\
    \x02\0\x12\x04\x96\x01\x118\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\x96\x01\
    \x11\x17\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\x96\x01!*\n\r\n\x05\x04\x0b\
    \x02\0\x03\x12\x04\x96\x0167\n\x0c\n\x04\x04\x0b\x02\x01\x12\x04\x97\x01\
    \x118\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\x97\x01\x11\x17\n\r\n\x05\
    \x04\x0b\x02\x01\x01\x12\x04\x97\x01!+\n\r\n\x05\x04\x0b\x02\x01\x03\x12\
    \x04\x97\x0167\n\x0c\n\x04\x04\x0b\x02\x02\x12\x04\x98\x01\x088\n\r\n\
    \x05\x04\x0b\x02\x02\x04\x12\x04\x98\x01\x08\x10\n\r\n\x05\x04\x0b\x02\
    \x02\x06\x12\x04\x98\x01\x11\x1c\n\r\n\x05\x04\x0b\x02\x02\x01\x12\x04\
    \x98\x01!)\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\x98\x0167\n\x0c\n\x04\
    \x04\x0b\x02\x03\x12\x04\x99\x01\x118\n\r\n\x05\x04\x0b\x02\x03\x05\x12\
    \x04\x99\x01\x11\x17\n\r\n\x05\x04\x0b\x02\x03\x01\x12\x04\x99\x01!'\n\r\
    \n\x05\x04\x0b\x02\x03\x03\x12\x04\x99\x0167\n\x0c\n\x04\x04\x0b\x02\x04\
    \x12\x04\x9a\x01\x19@\n\r\n\x05\x04\x0b\x02\x04\x05\x12\x04\x9a\x01\x19\
    \x1f\n\r\n\x05\x04\x0b\x02\x04\x01\x12\x04\x9a\x01)3\n\r\n\x05\x04\x0b\
    \x02\x04\x03\x12\x04\x9a\x01>?\nT\n\x04\x04\x0b\x02\x05\x12\x04\x9b\x01\
    \x118\"F\x20Used\x20for\x20communicating\x20the\x20network\x20onnx\x20ve\
    rsion\x20to\x20the\x20main\x20program\r\n\n\r\n\x05\x04\x0b\x02\x05\x05\
    \x12\x04\x9b\x01\x11\x16\n\r\n\x05\x04\x0b\x02\x05\x01\x12\x04\x9b\x01!3\
    \n\r\n\x05\x04\x0b\x02\x05\x03\x12\x04\x9b\x0167\nT\n\x04\x04\x0b\x02\
    \x06\x12\x04\x9c\x01\x118\"F\x20Used\x20for\x20communicating\x20the\x20n\
    etwork\x20onnx\x20version\x20to\x20the\x20main\x20program\r\n\n\r\n\x05\
    \x04\x0b\x02\x06\x05\x12\x04\x9c\x01\x11\x16\n\r\n\x05\x04\x0b\x02\x06\
    \x01\x12\x04\x9c\x01!3\n\r\n\x05\x04\x0b\x02\x06\x03\x12\x04\x9c\x0167\n\
    \x0c\n\x04\x04\x0b\x02\x07\x12\x04\x9d\x01\x19@\n\r\n\x05\x04\x0b\x02\
    \x07\x06\x12\x04\x9d\x01\x19\"\n\r\n\x05\x04\x0b\x02\x07\x01\x12\x04\x9d\
    \x01)3\n\r\n\x05\x04\x0b\x02\x07\x03\x12\x04\x9d\x01>?\n\x0c\n\x04\x04\
    \x0b\x02\x08\x12\x04\x9e\x01\x19@\n\r\n\x05\x04\x0b\x02\x08\x06\x12\x04\
    \x9e\x01\x19(\n\r\n\x05\x04\x0b\x02\x08\x01\x12\x04\x9e\x01):\n\r\n\x05\
    \x04\x0b\x02\x08\x03\x12\x04\x9e\x01>?\n\x0c\n\x02\x04\x0c\x12\x06\xa1\
    \x01\0\xae\x01\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\xa1\x01\x08\x0f\n\x0c\
    \n\x04\x04\x0c\x02\0\x12\x04\xa2\x01\x088\n\r\n\x05\x04\x0c\x02\0\x04\
    \x12\x04\xa2\x01\x08\x10\n\r\n\x05\x04\x0c\x02\0\x06\x12\x04\xa2\x01\x11\
    \x1c\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xa2\x01\x1d#\n\r\n\x05\x04\x0c\
    \x02\0\x03\x12\x04\xa2\x0167\n\x0c\n\x04\x04\x0c\x02\x01\x12\x04\xa3\x01\
    \x118\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\xa3\x01\x11\x16\n\r\n\x05\
    \x04\x0c\x02\x01\x01\x12\x04\xa3\x01\x1d-\n\r\n\x05\x04\x0c\x02\x01\x03\
    \x12\x04\xa3\x0167\n\x0c\n\x04\x04\x0c\x02\x02\x12\x04\xa4\x01\x118\n\r\
    \n\x05\x04\x0c\x02\x02\x05\x12\x04\xa4\x01\x11\x16\n\r\n\x05\x04\x0c\x02\
    \x02\x01\x12\x04\xa4\x01\x1d-\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\xa4\
    \x0167\n\x0c\n\x04\x04\x0c\x02\x03\x12\x04\xa5\x01\x118\n\r\n\x05\x04\
    \x0c\x02\x03\x05\x12\x04\xa5\x01\x11\x16\n\r\n\x05\x04\x0c\x02\x03\x01\
    \x12\x04\xa5\x01\x1d-\n\r\n\x05\x04\x0c\x02\x03\x03\x12\x04\xa5\x0167\n\
    \x0c\n\x04\x04\x0c\x02\x04\x12\x04\xa6\x01\x118\n\r\n\x05\x04\x0c\x02\
    \x04\x05\x12\x04\xa6\x01\x11\x17\n\r\n\x05\x04\x0c\x02\x04\x01\x12\x04\
    \xa6\x01\x1d0\n\r\n\x05\x04\x0c\x02\x04\x03\x12\x04\xa6\x0167\n\x0c\n\
    \x04\x04\x0c\x02\x05\x12\x04\xa7\x01\x118\n\r\n\x05\x04\x0c\x02\x05\x05\
    \x12\x04\xa7\x01\x11\x17\n\r\n\x05\x04\x0c\x02\x05\x01\x12\x04\xa7\x01\
    \x1d0\n\r\n\x05\x04\x0c\x02\x05\x03\x12\x04\xa7\x0167\n\x0c\n\x04\x04\
    \x0c\x02\x06\x12\x04\xa8\x01\x118\n\r\n\x05\x04\x0c\x02\x06\x05\x12\x04\
    \xa8\x01\x11\x17\n\r\n\x05\x04\x0c\x02\x06\x01\x12\x04\xa8\x01\x1d0\n\r\
    \n\x05\x04\x0c\x02\x06\x03\x12\x04\xa8\x0167\n\x0c\n\x04\x04\x0c\x02\x07\
    \x12\x04\xa9\x01\x118\n\r\n\x05\x04\x0c\x02\x07\x05\x12\x04\xa9\x01\x11\
    \x17\n\r\n\x05\x04\x0c\x02\x07\x01\x12\x04\xa9\x01\x1d2\n\r\n\x05\x04\
    \x0c\x02\x07\x03\x12\x04\xa9\x0167\n\x0c\n\x04\x04\x0c\x02\x08\x12\x04\
    \xaa\x01\x118\n\r\n\x05\x04\x0c\x02\x08\x06\x12\x04\xaa\x01\x11\x18\n\r\
    \n\x05\x04\x0c\x02\x08\x01\x12\x04\xaa\x01\x1d+\n\r\n\x05\x04\x0c\x02\
    \x08\x03\x12\x04\xaa\x0167\n\x0c\n\x04\x04\x0c\x02\t\x12\x04\xab\x01\x19\
    @\n\r\n\x05\x04\x0c\x02\t\x05\x12\x04\xab\x01\x19\x1f\n\r\n\x05\x04\x0c\
    \x02\t\x01\x12\x04\xab\x01%9\n\r\n\x05\x04\x0c\x02\t\x03\x12\x04\xab\x01\
    =?\n\x0c\n\x04\x04\x0c\x02\n\x12\x04\xac\x01\x19@\n\r\n\x05\x04\x0c\x02\
    \n\x05\x12\x04\xac\x01\x19\x1f\n\r\n\x05\x04\x0c\x02\n\x01\x12\x04\xac\
    \x01%9\n\r\n\x05\x04\x0c\x02\n\x03\x12\x04\xac\x01=?\nP\n\x04\x04\x0c\
    \x02\x0b\x12\x04\xad\x01\x088\"B\x20Used\x20for\x20communicating\x20the\
    \x20available\x20models\x20to\x20the\x20main\x20program\r\n\n\r\n\x05\
    \x04\x0c\x02\x0b\x04\x12\x04\xad\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x0b\
    \x06\x12\x04\xad\x01\x11\x1a\n\r\n\x05\x04\x0c\x02\x0b\x01\x12\x04\xad\
    \x01\x1d-\n\r\n\x05\x04\x0c\x02\x0b\x03\x12\x04\xad\x0157\n\x1b\n\x02\
    \x04\r\x12\x06\xb2\x01\0\xc1\x01\x01\x1a\r\x20deprecated\r\n\n\x0b\n\x03\
    \x04\r\x01\x12\x04\xb2\x01\x08\x14\n\x0c\n\x04\x04\r\x02\0\x12\x04\xb3\
    \x01\x08-\n\r\n\x05\x04\r\x02\0\x05\x12\x04\xb3\x01\x08\x0c\n\r\n\x05\
    \x04\r\x02\0\x01\x12\x04\xb3\x01\x0f\x1a\n\r\n\x05\x04\r\x02\0\x03\x12\
    \x04\xb3\x01+,\n\x0c\n\x04\x04\r\x02\x01\x12\x04\xb4\x01\x08-\n\r\n\x05\
    \x04\r\x02\x01\x05\x12\x04\xb4\x01\x08\x0e\n\r\n\x05\x04\r\x02\x01\x01\
    \x12\x04\xb4\x01\x0f'\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xb4\x01+,\n\
    \x0c\n\x04\x04\r\x02\x02\x12\x04\xb5\x01\x08-\n\r\n\x05\x04\r\x02\x02\
    \x05\x12\x04\xb5\x01\x08\x0e\n\r\n\x05\x04\r\x02\x02\x01\x12\x04\xb5\x01\
    \x0f\x1b\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\xb5\x01+,\n\x0c\n\x04\x04\r\
    \x02\x03\x12\x04\xb6\x01\x08-\n\r\n\x05\x04\r\x02\x03\x05\x12\x04\xb6\
    \x01\x08\x0e\n\r\n\x05\x04\r\x02\x03\x01\x12\x04\xb6\x01\x0f\x1b\n\r\n\
    \x05\x04\r\x02\x03\x03\x12\x04\xb6\x01+,\n\x0c\n\x04\x04\r\x02\x04\x12\
    \x04\xb7\x01\x08-\n\r\n\x05\x04\r\x02\x04\x05\x12\x04\xb7\x01\x08\x0e\n\
    \r\n\x05\x04\r\x02\x04\x01\x12\x04\xb7\x01\x0f\x1f\n\r\n\x05\x04\r\x02\
    \x04\x03\x12\x04\xb7\x01+,\n\x0c\n\x04\x04\r\x02\x05\x12\x04\xb8\x01\x08\
    -\n\r\n\x05\x04\r\x02\x05\x05\x12\x04\xb8\x01\x08\x0e\n\r\n\x05\x04\r\
    \x02\x05\x01\x12\x04\xb8\x01\x0f\x1d\n\r\n\x05\x04\r\x02\x05\x03\x12\x04\
    \xb8\x01+,\n\x0c\n\x04\x04\r\x02\x06\x12\x04\xb9\x01\x08-\n\r\n\x05\x04\
    \r\x02\x06\x05\x12\x04\xb9\x01\x08\x0e\n\r\n\x05\x04\r\x02\x06\x01\x12\
    \x04\xb9\x01\x0f\x18\n\r\n\x05\x04\r\x02\x06\x03\x12\x04\xb9\x01+,\n\x0c\
    \n\x04\x04\r\x02\x07\x12\x04\xba\x01\x08-\n\r\n\x05\x04\r\x02\x07\x05\
    \x12\x04\xba\x01\x08\x0e\n\r\n\x05\x04\r\x02\x07\x01\x12\x04\xba\x01\x0f\
    \x17\n\r\n\x05\x04\r\x02\x07\x03\x12\x04\xba\x01+,\n\x0c\n\x04\x04\r\x02\
    \x08\x12\x04\xbb\x01\x08-\n\r\n\x05\x04\r\x02\x08\x05\x12\x04\xbb\x01\
    \x08\x0e\n\r\n\x05\x04\r\x02\x08\x01\x12\x04\xbb\x01\x0f\x18\n\r\n\x05\
    \x04\r\x02\x08\x03\x12\x04\xbb\x01+,\n\x0c\n\x04\x04\r\x02\t\x12\x04\xbc\
    \x01\x08-\n\r\n\x05\x04\r\x02\t\x05\x12\x04\xbc\x01\x08\x0e\n\r\n\x05\
    \x04\r\x02\t\x01\x12\x04\xbc\x01\x0f\x16\n\r\n\x05\x04\r\x02\t\x03\x12\
    \x04\xbc\x01*,\n\x0c\n\x04\x04\r\x02\n\x12\x04\xbd\x01\x08-\n\r\n\x05\
    \x04\r\x02\n\x05\x12\x04\xbd\x01\x08\x0e\n\r\n\x05\x04\r\x02\n\x01\x12\
    \x04\xbd\x01\x0f!\n\r\n\x05\x04\r\x02\n\x03\x12\x04\xbd\x01*,\n\x0c\n\
    \x04\x04\r\x02\x0b\x12\x04\xbe\x01\x08-\n\r\n\x05\x04\r\x02\x0b\x05\x12\
    \x04\xbe\x01\x08\x0e\n\r\n\x05\x04\r\x02\x0b\x01\x12\x04\xbe\x01\x0f\x1c\
    \n\r\n\x05\x04\r\x02\x0b\x03\x12\x04\xbe\x01*,\n\x0c\n\x04\x04\r\x02\x0c\
    \x12\x04\xbf\x01\x08-\n\r\n\x05\x04\r\x02\x0c\x05\x12\x04\xbf\x01\x08\r\
    \n\r\n\x05\x04\r\x02\x0c\x01\x12\x04\xbf\x01\x0f\x17\n\r\n\x05\x04\r\x02\
    \x0c\x03\x12\x04\xbf\x01*,\n\x0c\n\x04\x04\r\x02\r\x12\x04\xc0\x01\x08-\
    \n\r\n\x05\x04\r\x02\r\x05\x12\x04\xc0\x01\x08\x0c\n\r\n\x05\x04\r\x02\r\
    \x01\x12\x04\xc0\x01\x0f\x20\n\r\n\x05\x04\r\x02\r\x03\x12\x04\xc0\x01*,\
    \n\x1b\n\x02\x04\x0e\x12\x06\xc4\x01\0\xd2\x01\x01\x1a\r\x20deprecated\r\
    \n\n\x0b\n\x03\x04\x0e\x01\x12\x04\xc4\x01\x08\x17\n1\n\x04\x04\x0e\x02\
    \0\x12\x04\xc5\x01\x08.\"#\x20maps\x20the\x20model_id\x20to\x20the\x20op\
    tions\r\n\n\r\n\x05\x04\x0e\x02\0\x06\x12\x04\xc5\x01\x08\x20\n\r\n\x05\
    \x04\x0e\x02\0\x01\x12\x04\xc5\x01!(\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\
    \xc5\x01,-\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\xc6\x01\x08.\n\r\n\x05\
    \x04\x0e\x02\x01\x05\x12\x04\xc6\x01\x08\r\n\r\n\x05\x04\x0e\x02\x01\x01\
    \x12\x04\xc6\x01\x0e\x17\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xc6\x01,-\
    \n\x0c\n\x04\x04\x0e\x02\x02\x12\x04\xc7\x01\x08.\n\r\n\x05\x04\x0e\x02\
    \x02\x05\x12\x04\xc7\x01\x08\r\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\xc7\
    \x01\x0e\x17\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\xc7\x01,-\n\x0c\n\x04\
    \x04\x0e\x02\x03\x12\x04\xc8\x01\x08.\n\r\n\x05\x04\x0e\x02\x03\x05\x12\
    \x04\xc8\x01\x08\r\n\r\n\x05\x04\x0e\x02\x03\x01\x12\x04\xc8\x01\x0e\x18\
    \n\r\n\x05\x04\x0e\x02\x03\x03\x12\x04\xc8\x01,-\n\x0c\n\x04\x04\x0e\x02\
    \x04\x12\x04\xc9\x01\x08.\n\r\n\x05\x04\x0e\x02\x04\x05\x12\x04\xc9\x01\
    \x08\r\n\r\n\x05\x04\x0e\x02\x04\x01\x12\x04\xc9\x01\x0e&\n\r\n\x05\x04\
    \x0e\x02\x04\x03\x12\x04\xc9\x01,-\n\x0c\n\x04\x04\x0e\x02\x05\x12\x04\
    \xca\x01\x08.\n\r\n\x05\x04\x0e\x02\x05\x05\x12\x04\xca\x01\x08\r\n\r\n\
    \x05\x04\x0e\x02\x05\x01\x12\x04\xca\x01\x0e&\n\r\n\x05\x04\x0e\x02\x05\
    \x03\x12\x04\xca\x01,-\n\x0c\n\x04\x04\x0e\x02\x06\x12\x04\xcb\x01\x08.\
    \n\r\n\x05\x04\x0e\x02\x06\x05\x12\x04\xcb\x01\x08\r\n\r\n\x05\x04\x0e\
    \x02\x06\x01\x12\x04\xcb\x01\x0e&\n\r\n\x05\x04\x0e\x02\x06\x03\x12\x04\
    \xcb\x01,-\n\x0c\n\x04\x04\x0e\x02\x07\x12\x04\xcc\x01\x08.\n\r\n\x05\
    \x04\x0e\x02\x07\x05\x12\x04\xcc\x01\x08\r\n\r\n\x05\x04\x0e\x02\x07\x01\
    \x12\x04\xcc\x01\x0e\x16\n\r\n\x05\x04\x0e\x02\x07\x03\x12\x04\xcc\x01,-\
    \n\x0c\n\x04\x04\x0e\x02\x08\x12\x04\xcd\x01\x08.\n\r\n\x05\x04\x0e\x02\
    \x08\x05\x12\x04\xcd\x01\x08\r\n\r\n\x05\x04\x0e\x02\x08\x01\x12\x04\xcd\
    \x01\x0e\x16\n\r\n\x05\x04\x0e\x02\x08\x03\x12\x04\xcd\x01,-\n\x0c\n\x04\
    \x04\x0e\x02\t\x12\x04\xce\x01\x08.\n\r\n\x05\x04\x0e\x02\t\x05\x12\x04\
    \xce\x01\x08\r\n\r\n\x05\x04\x0e\x02\t\x01\x12\x04\xce\x01\x0e\x18\n\r\n\
    \x05\x04\x0e\x02\t\x03\x12\x04\xce\x01+-\n\x0c\n\x04\x04\x0e\x02\n\x12\
    \x04\xcf\x01\x08.\n\r\n\x05\x04\x0e\x02\n\x05\x12\x04\xcf\x01\x08\r\n\r\
    \n\x05\x04\x0e\x02\n\x01\x12\x04\xcf\x01\x0e\x18\n\r\n\x05\x04\x0e\x02\n\
    \x03\x12\x04\xcf\x01+-\n\x0c\n\x04\x04\x0e\x02\x0b\x12\x04\xd0\x01\x08.\
    \n\r\n\x05\x04\x0e\x02\x0b\x05\x12\x04\xd0\x01\x08\r\n\r\n\x05\x04\x0e\
    \x02\x0b\x01\x12\x04\xd0\x01\x0e\x15\n\r\n\x05\x04\x0e\x02\x0b\x03\x12\
    \x04\xd0\x01+-\n\x0c\n\x04\x04\x0e\x02\x0c\x12\x04\xd1\x01\x08.\n\r\n\
    \x05\x04\x0e\x02\x0c\x05\x12\x04\xd1\x01\x08\r\n\r\n\x05\x04\x0e\x02\x0c\
    \x01\x12\x04\xd1\x01\x0e\x15\n\r\n\x05\x04\x0e\x02\x0c\x03\x12\x04\xd1\
    \x01+-\n\x0c\n\x02\x05\x03\x12\x06\xd4\x01\0\xd8\x01\x01\n\x0b\n\x03\x05\
    \x03\x01\x12\x04\xd4\x01\x05\x0f\n\x0c\n\x04\x05\x03\x02\0\x12\x04\xd5\
    \x01\x08\x16\n\r\n\x05\x05\x03\x02\0\x01\x12\x04\xd5\x01\x08\x11\n\r\n\
    \x05\x05\x03\x02\0\x02\x12\x04\xd5\x01\x14\x15\n\x0c\n\x04\x05\x03\x02\
    \x01\x12\x04\xd6\x01\x08\x16\n\r\n\x05\x05\x03\x02\x01\x01\x12\x04\xd6\
    \x01\x08\x0b\n\r\n\x05\x05\x03\x02\x01\x02\x12\x04\xd6\x01\x14\x15\n\x0c\
    \n\x04\x05\x03\x02\x02\x12\x04\xd7\x01\x08\x16\n\r\n\x05\x05\x03\x02\x02\
    \x01\x12\x04\xd7\x01\x08\x0b\n\r\n\x05\x05\x03\x02\x02\x02\x12\x04\xd7\
    \x01\x14\x15\n:\n\x02\x04\x0f\x12\x06\xdb\x01\0\xe4\x01\x01\x1a,\x20CPUs\
    \x20will\x20only\x20have\x20their\x20type\x20and\x20id\x20set\r\n\n\x0b\
    \n\x03\x04\x0f\x01\x12\x04\xdb\x01\x08\x0e\n\x0c\n\x04\x04\x0f\x02\0\x12\
    \x04\xdc\x01\x085\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\xdc\x01\x08\r\n\r\
    \n\x05\x04\x0f\x02\0\x01\x12\x04\xdc\x01\x13\x1c\n\r\n\x05\x04\x0f\x02\0\
    \x03\x12\x04\xdc\x0134\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\xdd\x01\x085\
    \n\r\n\x05\x04\x0f\x02\x01\x06\x12\x04\xdd\x01\x08\x12\n\r\n\x05\x04\x0f\
    \x02\x01\x01\x12\x04\xdd\x01\x13\x17\n\r\n\x05\x04\x0f\x02\x01\x03\x12\
    \x04\xdd\x0134\n\x0c\n\x04\x04\x0f\x02\x02\x12\x04\xde\x01\x085\n\r\n\
    \x05\x04\x0f\x02\x02\x05\x12\x04\xde\x01\x08\x0e\n\r\n\x05\x04\x0f\x02\
    \x02\x01\x12\x04\xde\x01\x13\x17\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\
    \xde\x0134\n.\n\x04\x04\x0f\x02\x03\x12\x04\xdf\x01\x085\"\x20\x20availa\
    ble\x20GPU\x20memory\x20in\x20bytes\r\n\n\r\n\x05\x04\x0f\x02\x03\x05\
    \x12\x04\xdf\x01\x08\r\n\r\n\x05\x04\x0f\x02\x03\x01\x12\x04\xdf\x01\x13\
    \x1e\n\r\n\x05\x04\x0f\x02\x03\x03\x12\x04\xdf\x0134\n.\n\x04\x04\x0f\
    \x02\x04\x12\x04\xe0\x01\x085\"\x20\x20whether\x20the\x20GPU\x20is\x20in\
    tegrated\r\n\n\r\n\x05\x04\x0f\x02\x04\x05\x12\x04\xe0\x01\x08\x0c\n\r\n\
    \x05\x04\x0f\x02\x04\x01\x12\x04\xe0\x01\x13\x1d\n\r\n\x05\x04\x0f\x02\
    \x04\x03\x12\x04\xe0\x0134\n\x0c\n\x04\x04\x0f\x02\x05\x12\x04\xe1\x01\
    \x085\n\r\n\x05\x04\x0f\x02\x05\x05\x12\x04\xe1\x01\x08\x0e\n\r\n\x05\
    \x04\x0f\x02\x05\x01\x12\x04\xe1\x01\x13\x1c\n\r\n\x05\x04\x0f\x02\x05\
    \x03\x12\x04\xe1\x0134\n\x0c\n\x04\x04\x0f\x02\x06\x12\x04\xe2\x01\x085\
    \n\r\n\x05\x04\x0f\x02\x06\x05\x12\x04\xe2\x01\x08\r\n\r\n\x05\x04\x0f\
    \x02\x06\x01\x12\x04\xe2\x01\x130\n\r\n\x05\x04\x0f\x02\x06\x03\x12\x04\
    \xe2\x0134\n\x0c\n\x04\x04\x0f\x02\x07\x12\x04\xe3\x01\x085\n\r\n\x05\
    \x04\x0f\x02\x07\x05\x12\x04\xe3\x01\x08\r\n\r\n\x05\x04\x0f\x02\x07\x01\
    \x12\x04\xe3\x01\x130\n\r\n\x05\x04\x0f\x02\x07\x03\x12\x04\xe3\x0134\n\
    \x0c\n\x02\x04\x10\x12\x06\xe6\x01\0\xe8\x01\x01\n\x0b\n\x03\x04\x10\x01\
    \x12\x04\xe6\x01\x08\x19\n\x0c\n\x04\x04\x10\x02\0\x12\x04\xe7\x01\x08#\
    \n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xe7\x01\x08\x10\n\r\n\x05\x04\x10\
    \x02\0\x06\x12\x04\xe7\x01\x11\x17\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\
    \xe7\x01\x18\x1e\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xe7\x01!\"b\x06prot\
    o3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(17);
            messages.push(DefectAddress::generated_message_descriptor_data());
            messages.push(RowRLC::generated_message_descriptor_data());
            messages.push(OcrCharacter::generated_message_descriptor_data());
            messages.push(OcrCharacterPosition::generated_message_descriptor_data());
            messages.push(Point::generated_message_descriptor_data());
            messages.push(MinimalBoundingBox::generated_message_descriptor_data());
            messages.push(FeatureField::generated_message_descriptor_data());
            messages.push(MapField::generated_message_descriptor_data());
            messages.push(ResultField::generated_message_descriptor_data());
            messages.push(Summary::generated_message_descriptor_data());
            messages.push(FeatureInfo::generated_message_descriptor_data());
            messages.push(ModelInfo::generated_message_descriptor_data());
            messages.push(Results::generated_message_descriptor_data());
            messages.push(ModelOptions::generated_message_descriptor_data());
            messages.push(OptionContainer::generated_message_descriptor_data());
            messages.push(Device::generated_message_descriptor_data());
            messages.push(DeviceInformation::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(4);
            enums.push(MapDataType::generated_enum_descriptor_data());
            enums.push(ModelType::generated_enum_descriptor_data());
            enums.push(ModelOutputType::generated_enum_descriptor_data());
            enums.push(DeviceType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
