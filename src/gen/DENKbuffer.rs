// This file is generated by rust-protobuf 3.4.0. Do not edit
// .proto file is parsed by protoc 26.0
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `DENKbuffer.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_4_0;

// @@protoc_insertion_point(message:denkproto.Image)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Image {
    // message fields
    // @@protoc_insertion_point(field:denkproto.Image.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:denkproto.Image.data)
    pub data: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:denkproto.Image.height)
    pub height: i32,
    // @@protoc_insertion_point(field:denkproto.Image.width)
    pub width: i32,
    // @@protoc_insertion_point(field:denkproto.Image.channels)
    pub channels: i32,
    // @@protoc_insertion_point(field:denkproto.Image.filename)
    pub filename: ::std::string::String,
    // @@protoc_insertion_point(field:denkproto.Image.imageType)
    pub imageType: ::protobuf::EnumOrUnknown<ImageTypes>,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.Image.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Image {
    fn default() -> &'a Image {
        <Image as ::protobuf::Message>::default_instance()
    }
}

impl Image {
    pub fn new() -> Image {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Image {
    const NAME: &'static str = "Image";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.data = is.read_bytes()?;
                },
                24 => {
                    self.height = is.read_int32()?;
                },
                32 => {
                    self.width = is.read_int32()?;
                },
                40 => {
                    self.channels = is.read_int32()?;
                },
                50 => {
                    self.filename = is.read_string()?;
                },
                56 => {
                    self.imageType = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.height);
        }
        if self.width != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.width);
        }
        if self.channels != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.channels);
        }
        if !self.filename.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.filename);
        }
        if self.imageType != ::protobuf::EnumOrUnknown::new(ImageTypes::Raw) {
            my_size += ::protobuf::rt::int32_size(7, self.imageType.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        if self.height != 0 {
            os.write_int32(3, self.height)?;
        }
        if self.width != 0 {
            os.write_int32(4, self.width)?;
        }
        if self.channels != 0 {
            os.write_int32(5, self.channels)?;
        }
        if !self.filename.is_empty() {
            os.write_string(6, &self.filename)?;
        }
        if self.imageType != ::protobuf::EnumOrUnknown::new(ImageTypes::Raw) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.imageType))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Image {
        Image::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.data.clear();
        self.height = 0;
        self.width = 0;
        self.channels = 0;
        self.filename.clear();
        self.imageType = ::protobuf::EnumOrUnknown::new(ImageTypes::Raw);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Image {
        static instance: Image = Image {
            id: ::std::string::String::new(),
            data: ::std::vec::Vec::new(),
            height: 0,
            width: 0,
            channels: 0,
            filename: ::std::string::String::new(),
            imageType: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:denkproto.FloatMapChannel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FloatMapChannel {
    // message fields
    // @@protoc_insertion_point(field:denkproto.FloatMapChannel.class_label_id)
    pub class_label_id: ::std::string::String,
    // @@protoc_insertion_point(field:denkproto.FloatMapChannel.data)
    pub data: ::std::vec::Vec<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.FloatMapChannel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FloatMapChannel {
    fn default() -> &'a FloatMapChannel {
        <FloatMapChannel as ::protobuf::Message>::default_instance()
    }
}

impl FloatMapChannel {
    pub fn new() -> FloatMapChannel {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FloatMapChannel {
    const NAME: &'static str = "FloatMapChannel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.class_label_id = is.read_string()?;
                },
                18 => {
                    is.read_repeated_packed_float_into(&mut self.data)?;
                },
                21 => {
                    self.data.push(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.class_label_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.class_label_id);
        }
        my_size += 5 * self.data.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.class_label_id.is_empty() {
            os.write_string(1, &self.class_label_id)?;
        }
        for v in &self.data {
            os.write_float(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FloatMapChannel {
        FloatMapChannel::new()
    }

    fn clear(&mut self) {
        self.class_label_id.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FloatMapChannel {
        static instance: FloatMapChannel = FloatMapChannel {
            class_label_id: ::std::string::String::new(),
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:denkproto.FloatMap)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FloatMap {
    // message fields
    // @@protoc_insertion_point(field:denkproto.FloatMap.channels)
    pub channels: ::std::vec::Vec<FloatMapChannel>,
    // @@protoc_insertion_point(field:denkproto.FloatMap.height)
    pub height: i32,
    // @@protoc_insertion_point(field:denkproto.FloatMap.width)
    pub width: i32,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.FloatMap.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FloatMap {
    fn default() -> &'a FloatMap {
        <FloatMap as ::protobuf::Message>::default_instance()
    }
}

impl FloatMap {
    pub fn new() -> FloatMap {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FloatMap {
    const NAME: &'static str = "FloatMap";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.channels.push(is.read_message()?);
                },
                16 => {
                    self.height = is.read_int32()?;
                },
                24 => {
                    self.width = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.height != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.height);
        }
        if self.width != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.width);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.channels {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.height != 0 {
            os.write_int32(2, self.height)?;
        }
        if self.width != 0 {
            os.write_int32(3, self.width)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FloatMap {
        FloatMap::new()
    }

    fn clear(&mut self) {
        self.channels.clear();
        self.height = 0;
        self.width = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FloatMap {
        static instance: FloatMap = FloatMap {
            channels: ::std::vec::Vec::new(),
            height: 0,
            width: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:denkproto.ClassificationPrediction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClassificationPrediction {
    // message fields
    // @@protoc_insertion_point(field:denkproto.ClassificationPrediction.class_label_id)
    pub class_label_id: ::std::string::String,
    // @@protoc_insertion_point(field:denkproto.ClassificationPrediction.score)
    pub score: f64,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.ClassificationPrediction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClassificationPrediction {
    fn default() -> &'a ClassificationPrediction {
        <ClassificationPrediction as ::protobuf::Message>::default_instance()
    }
}

impl ClassificationPrediction {
    pub fn new() -> ClassificationPrediction {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ClassificationPrediction {
    const NAME: &'static str = "ClassificationPrediction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.class_label_id = is.read_string()?;
                },
                17 => {
                    self.score = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.class_label_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.class_label_id);
        }
        if self.score != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.class_label_id.is_empty() {
            os.write_string(1, &self.class_label_id)?;
        }
        if self.score != 0. {
            os.write_double(2, self.score)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClassificationPrediction {
        ClassificationPrediction::new()
    }

    fn clear(&mut self) {
        self.class_label_id.clear();
        self.score = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClassificationPrediction {
        static instance: ClassificationPrediction = ClassificationPrediction {
            class_label_id: ::std::string::String::new(),
            score: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:denkproto.BoundingBox)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BoundingBox {
    // message fields
    // @@protoc_insertion_point(field:denkproto.BoundingBox.x1)
    pub x1: f64,
    // @@protoc_insertion_point(field:denkproto.BoundingBox.x2)
    pub x2: f64,
    // @@protoc_insertion_point(field:denkproto.BoundingBox.y1)
    pub y1: f64,
    // @@protoc_insertion_point(field:denkproto.BoundingBox.y2)
    pub y2: f64,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.BoundingBox.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BoundingBox {
    fn default() -> &'a BoundingBox {
        <BoundingBox as ::protobuf::Message>::default_instance()
    }
}

impl BoundingBox {
    pub fn new() -> BoundingBox {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for BoundingBox {
    const NAME: &'static str = "BoundingBox";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.x1 = is.read_double()?;
                },
                17 => {
                    self.x2 = is.read_double()?;
                },
                25 => {
                    self.y1 = is.read_double()?;
                },
                33 => {
                    self.y2 = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.x1 != 0. {
            my_size += 1 + 8;
        }
        if self.x2 != 0. {
            my_size += 1 + 8;
        }
        if self.y1 != 0. {
            my_size += 1 + 8;
        }
        if self.y2 != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.x1 != 0. {
            os.write_double(1, self.x1)?;
        }
        if self.x2 != 0. {
            os.write_double(2, self.x2)?;
        }
        if self.y1 != 0. {
            os.write_double(3, self.y1)?;
        }
        if self.y2 != 0. {
            os.write_double(4, self.y2)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BoundingBox {
        BoundingBox::new()
    }

    fn clear(&mut self) {
        self.x1 = 0.;
        self.x2 = 0.;
        self.y1 = 0.;
        self.y2 = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BoundingBox {
        static instance: BoundingBox = BoundingBox {
            x1: 0.,
            x2: 0.,
            y1: 0.,
            y2: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:denkproto.ObjectDetectionPrediction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ObjectDetectionPrediction {
    // message fields
    // @@protoc_insertion_point(field:denkproto.ObjectDetectionPrediction.class_label_id)
    pub class_label_id: ::std::string::String,
    // @@protoc_insertion_point(field:denkproto.ObjectDetectionPrediction.score)
    pub score: f64,
    // @@protoc_insertion_point(field:denkproto.ObjectDetectionPrediction.box)
    pub box_: ::protobuf::MessageField<BoundingBox>,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.ObjectDetectionPrediction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ObjectDetectionPrediction {
    fn default() -> &'a ObjectDetectionPrediction {
        <ObjectDetectionPrediction as ::protobuf::Message>::default_instance()
    }
}

impl ObjectDetectionPrediction {
    pub fn new() -> ObjectDetectionPrediction {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ObjectDetectionPrediction {
    const NAME: &'static str = "ObjectDetectionPrediction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.class_label_id = is.read_string()?;
                },
                17 => {
                    self.score = is.read_double()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.box_)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.class_label_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.class_label_id);
        }
        if self.score != 0. {
            my_size += 1 + 8;
        }
        if let Some(v) = self.box_.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.class_label_id.is_empty() {
            os.write_string(1, &self.class_label_id)?;
        }
        if self.score != 0. {
            os.write_double(2, self.score)?;
        }
        if let Some(v) = self.box_.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ObjectDetectionPrediction {
        ObjectDetectionPrediction::new()
    }

    fn clear(&mut self) {
        self.class_label_id.clear();
        self.score = 0.;
        self.box_.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ObjectDetectionPrediction {
        static instance: ObjectDetectionPrediction = ObjectDetectionPrediction {
            class_label_id: ::std::string::String::new(),
            score: 0.,
            box_: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:denkproto.Point2d)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Point2d {
    // message fields
    // @@protoc_insertion_point(field:denkproto.Point2d.x)
    pub x: f64,
    // @@protoc_insertion_point(field:denkproto.Point2d.y)
    pub y: f64,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.Point2d.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Point2d {
    fn default() -> &'a Point2d {
        <Point2d as ::protobuf::Message>::default_instance()
    }
}

impl Point2d {
    pub fn new() -> Point2d {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Point2d {
    const NAME: &'static str = "Point2d";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.x = is.read_double()?;
                },
                17 => {
                    self.y = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.x != 0. {
            my_size += 1 + 8;
        }
        if self.y != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.x != 0. {
            os.write_double(1, self.x)?;
        }
        if self.y != 0. {
            os.write_double(2, self.y)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Point2d {
        Point2d::new()
    }

    fn clear(&mut self) {
        self.x = 0.;
        self.y = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Point2d {
        static instance: Point2d = Point2d {
            x: 0.,
            y: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:denkproto.Contour)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Contour {
    // message fields
    // @@protoc_insertion_point(field:denkproto.Contour.points)
    pub points: ::std::vec::Vec<Point2d>,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.Contour.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Contour {
    fn default() -> &'a Contour {
        <Contour as ::protobuf::Message>::default_instance()
    }
}

impl Contour {
    pub fn new() -> Contour {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Contour {
    const NAME: &'static str = "Contour";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.points.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.points {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.points {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Contour {
        Contour::new()
    }

    fn clear(&mut self) {
        self.points.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Contour {
        static instance: Contour = Contour {
            points: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:denkproto.Polygon)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Polygon {
    // message fields
    // @@protoc_insertion_point(field:denkproto.Polygon.outer)
    pub outer: ::protobuf::MessageField<Contour>,
    // @@protoc_insertion_point(field:denkproto.Polygon.holes)
    pub holes: ::std::vec::Vec<Contour>,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.Polygon.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Polygon {
    fn default() -> &'a Polygon {
        <Polygon as ::protobuf::Message>::default_instance()
    }
}

impl Polygon {
    pub fn new() -> Polygon {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Polygon {
    const NAME: &'static str = "Polygon";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.outer)?;
                },
                18 => {
                    self.holes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.outer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.holes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.outer.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.holes {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Polygon {
        Polygon::new()
    }

    fn clear(&mut self) {
        self.outer.clear();
        self.holes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Polygon {
        static instance: Polygon = Polygon {
            outer: ::protobuf::MessageField::none(),
            holes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:denkproto.InstanceSegmentationPrediction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct InstanceSegmentationPrediction {
    // message fields
    // @@protoc_insertion_point(field:denkproto.InstanceSegmentationPrediction.class_label_id)
    pub class_label_id: ::std::string::String,
    // @@protoc_insertion_point(field:denkproto.InstanceSegmentationPrediction.score)
    pub score: f64,
    // @@protoc_insertion_point(field:denkproto.InstanceSegmentationPrediction.box)
    pub box_: ::protobuf::MessageField<BoundingBox>,
    // @@protoc_insertion_point(field:denkproto.InstanceSegmentationPrediction.polygons)
    pub polygons: ::std::vec::Vec<Polygon>,
    // @@protoc_insertion_point(field:denkproto.InstanceSegmentationPrediction.mask)
    pub mask: ::protobuf::MessageField<FloatMap>,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.InstanceSegmentationPrediction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InstanceSegmentationPrediction {
    fn default() -> &'a InstanceSegmentationPrediction {
        <InstanceSegmentationPrediction as ::protobuf::Message>::default_instance()
    }
}

impl InstanceSegmentationPrediction {
    pub fn new() -> InstanceSegmentationPrediction {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for InstanceSegmentationPrediction {
    const NAME: &'static str = "InstanceSegmentationPrediction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.class_label_id = is.read_string()?;
                },
                17 => {
                    self.score = is.read_double()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.box_)?;
                },
                34 => {
                    self.polygons.push(is.read_message()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.mask)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.class_label_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.class_label_id);
        }
        if self.score != 0. {
            my_size += 1 + 8;
        }
        if let Some(v) = self.box_.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.polygons {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.class_label_id.is_empty() {
            os.write_string(1, &self.class_label_id)?;
        }
        if self.score != 0. {
            os.write_double(2, self.score)?;
        }
        if let Some(v) = self.box_.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.polygons {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.mask.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InstanceSegmentationPrediction {
        InstanceSegmentationPrediction::new()
    }

    fn clear(&mut self) {
        self.class_label_id.clear();
        self.score = 0.;
        self.box_.clear();
        self.polygons.clear();
        self.mask.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InstanceSegmentationPrediction {
        static instance: InstanceSegmentationPrediction = InstanceSegmentationPrediction {
            class_label_id: ::std::string::String::new(),
            score: 0.,
            box_: ::protobuf::MessageField::none(),
            polygons: ::std::vec::Vec::new(),
            mask: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:denkproto.OCRPrediction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OCRPrediction {
    // message fields
    // @@protoc_insertion_point(field:denkproto.OCRPrediction.class_label_id)
    pub class_label_id: ::std::string::String,
    // @@protoc_insertion_point(field:denkproto.OCRPrediction.polygon)
    pub polygon: ::protobuf::MessageField<Polygon>,
    // @@protoc_insertion_point(field:denkproto.OCRPrediction.score)
    pub score: f64,
    // @@protoc_insertion_point(field:denkproto.OCRPrediction.text)
    pub text: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:denkproto.OCRPrediction.char_scores)
    pub char_scores: ::std::vec::Vec<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.OCRPrediction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OCRPrediction {
    fn default() -> &'a OCRPrediction {
        <OCRPrediction as ::protobuf::Message>::default_instance()
    }
}

impl OCRPrediction {
    pub fn new() -> OCRPrediction {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for OCRPrediction {
    const NAME: &'static str = "OCRPrediction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.class_label_id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.polygon)?;
                },
                25 => {
                    self.score = is.read_double()?;
                },
                34 => {
                    self.text = is.read_bytes()?;
                },
                42 => {
                    is.read_repeated_packed_double_into(&mut self.char_scores)?;
                },
                41 => {
                    self.char_scores.push(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.class_label_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.class_label_id);
        }
        if let Some(v) = self.polygon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.score != 0. {
            my_size += 1 + 8;
        }
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.text);
        }
        my_size += 9 * self.char_scores.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.class_label_id.is_empty() {
            os.write_string(1, &self.class_label_id)?;
        }
        if let Some(v) = self.polygon.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.score != 0. {
            os.write_double(3, self.score)?;
        }
        if !self.text.is_empty() {
            os.write_bytes(4, &self.text)?;
        }
        for v in &self.char_scores {
            os.write_double(5, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OCRPrediction {
        OCRPrediction::new()
    }

    fn clear(&mut self) {
        self.class_label_id.clear();
        self.polygon.clear();
        self.score = 0.;
        self.text.clear();
        self.char_scores.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OCRPrediction {
        static instance: OCRPrediction = OCRPrediction {
            class_label_id: ::std::string::String::new(),
            polygon: ::protobuf::MessageField::none(),
            score: 0.,
            text: ::std::vec::Vec::new(),
            char_scores: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:denkproto.CodePrediction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CodePrediction {
    // message fields
    // @@protoc_insertion_point(field:denkproto.CodePrediction.class_label_id)
    pub class_label_id: ::std::string::String,
    // @@protoc_insertion_point(field:denkproto.CodePrediction.polygon)
    pub polygon: ::protobuf::MessageField<Polygon>,
    // @@protoc_insertion_point(field:denkproto.CodePrediction.code_type)
    pub code_type: ::std::string::String,
    // @@protoc_insertion_point(field:denkproto.CodePrediction.text)
    pub text: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.CodePrediction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CodePrediction {
    fn default() -> &'a CodePrediction {
        <CodePrediction as ::protobuf::Message>::default_instance()
    }
}

impl CodePrediction {
    pub fn new() -> CodePrediction {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CodePrediction {
    const NAME: &'static str = "CodePrediction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.class_label_id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.polygon)?;
                },
                26 => {
                    self.code_type = is.read_string()?;
                },
                34 => {
                    self.text = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.class_label_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.class_label_id);
        }
        if let Some(v) = self.polygon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.code_type.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.code_type);
        }
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.text);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.class_label_id.is_empty() {
            os.write_string(1, &self.class_label_id)?;
        }
        if let Some(v) = self.polygon.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.code_type.is_empty() {
            os.write_string(3, &self.code_type)?;
        }
        if !self.text.is_empty() {
            os.write_bytes(4, &self.text)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CodePrediction {
        CodePrediction::new()
    }

    fn clear(&mut self) {
        self.class_label_id.clear();
        self.polygon.clear();
        self.code_type.clear();
        self.text.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CodePrediction {
        static instance: CodePrediction = CodePrediction {
            class_label_id: ::std::string::String::new(),
            polygon: ::protobuf::MessageField::none(),
            code_type: ::std::string::String::new(),
            text: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:denkproto.ComputedPropertyValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ComputedPropertyValue {
    // message oneof groups
    pub value: ::std::option::Option<computed_property_value::Value>,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.ComputedPropertyValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ComputedPropertyValue {
    fn default() -> &'a ComputedPropertyValue {
        <ComputedPropertyValue as ::protobuf::Message>::default_instance()
    }
}

impl ComputedPropertyValue {
    pub fn new() -> ComputedPropertyValue {
        ::std::default::Default::default()
    }

    // int64 _int64 = 1;

    pub fn _int64(&self) -> i64 {
        match self.value {
            ::std::option::Option::Some(computed_property_value::Value::Int64(v)) => v,
            _ => 0,
        }
    }

    pub fn clear__int64(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has__int64(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(computed_property_value::Value::Int64(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set__int64(&mut self, v: i64) {
        self.value = ::std::option::Option::Some(computed_property_value::Value::Int64(v))
    }

    // double _double = 2;

    pub fn _double(&self) -> f64 {
        match self.value {
            ::std::option::Option::Some(computed_property_value::Value::Double(v)) => v,
            _ => 0.,
        }
    }

    pub fn clear__double(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has__double(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(computed_property_value::Value::Double(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set__double(&mut self, v: f64) {
        self.value = ::std::option::Option::Some(computed_property_value::Value::Double(v))
    }

    // string _string = 3;

    pub fn _string(&self) -> &str {
        match self.value {
            ::std::option::Option::Some(computed_property_value::Value::String(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear__string(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has__string(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(computed_property_value::Value::String(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set__string(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(computed_property_value::Value::String(v))
    }

    // Mutable pointer to the field.
    pub fn mut__string(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(computed_property_value::Value::String(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(computed_property_value::Value::String(::std::string::String::new()));
        }
        match self.value {
            ::std::option::Option::Some(computed_property_value::Value::String(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take__string(&mut self) -> ::std::string::String {
        if self.has__string() {
            match self.value.take() {
                ::std::option::Option::Some(computed_property_value::Value::String(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for ComputedPropertyValue {
    const NAME: &'static str = "ComputedPropertyValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.value = ::std::option::Option::Some(computed_property_value::Value::Int64(is.read_int64()?));
                },
                17 => {
                    self.value = ::std::option::Option::Some(computed_property_value::Value::Double(is.read_double()?));
                },
                26 => {
                    self.value = ::std::option::Option::Some(computed_property_value::Value::String(is.read_string()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &computed_property_value::Value::Int64(v) => {
                    my_size += ::protobuf::rt::int64_size(1, v);
                },
                &computed_property_value::Value::Double(v) => {
                    my_size += 1 + 8;
                },
                &computed_property_value::Value::String(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &computed_property_value::Value::Int64(v) => {
                    os.write_int64(1, v)?;
                },
                &computed_property_value::Value::Double(v) => {
                    os.write_double(2, v)?;
                },
                &computed_property_value::Value::String(ref v) => {
                    os.write_string(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ComputedPropertyValue {
        ComputedPropertyValue::new()
    }

    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ComputedPropertyValue {
        static instance: ComputedPropertyValue = ComputedPropertyValue {
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `ComputedPropertyValue`
pub mod computed_property_value {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:denkproto.ComputedPropertyValue.value)
    pub enum Value {
        // @@protoc_insertion_point(oneof_field:denkproto.ComputedPropertyValue._int64)
        Int64(i64),
        // @@protoc_insertion_point(oneof_field:denkproto.ComputedPropertyValue._double)
        Double(f64),
        // @@protoc_insertion_point(oneof_field:denkproto.ComputedPropertyValue._string)
        String(::std::string::String),
    }

    impl ::protobuf::Oneof for Value {
    }

    impl Value {
    }
}

// @@protoc_insertion_point(message:denkproto.ComputedProperty)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ComputedProperty {
    // message fields
    // @@protoc_insertion_point(field:denkproto.ComputedProperty.subject)
    pub subject: ::protobuf::EnumOrUnknown<ComputedPropertySubjects>,
    // @@protoc_insertion_point(field:denkproto.ComputedProperty.value)
    pub value: ::protobuf::MessageField<ComputedPropertyValue>,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.ComputedProperty.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ComputedProperty {
    fn default() -> &'a ComputedProperty {
        <ComputedProperty as ::protobuf::Message>::default_instance()
    }
}

impl ComputedProperty {
    pub fn new() -> ComputedProperty {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ComputedProperty {
    const NAME: &'static str = "ComputedProperty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.subject = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.value)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.subject != ::protobuf::EnumOrUnknown::new(ComputedPropertySubjects::COMPUTED_PROPERTY_SUBJECT_MEAN_GRAY_VALUE) {
            my_size += ::protobuf::rt::int32_size(1, self.subject.value());
        }
        if let Some(v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.subject != ::protobuf::EnumOrUnknown::new(ComputedPropertySubjects::COMPUTED_PROPERTY_SUBJECT_MEAN_GRAY_VALUE) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.subject))?;
        }
        if let Some(v) = self.value.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ComputedProperty {
        ComputedProperty::new()
    }

    fn clear(&mut self) {
        self.subject = ::protobuf::EnumOrUnknown::new(ComputedPropertySubjects::COMPUTED_PROPERTY_SUBJECT_MEAN_GRAY_VALUE);
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ComputedProperty {
        static instance: ComputedProperty = ComputedProperty {
            subject: ::protobuf::EnumOrUnknown::from_i32(0),
            value: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:denkproto.Prediction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Prediction {
    // message fields
    // @@protoc_insertion_point(field:denkproto.Prediction.computed_properties)
    pub computed_properties: ::std::vec::Vec<ComputedProperty>,
    // message oneof groups
    pub prediction: ::std::option::Option<prediction::Prediction>,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.Prediction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Prediction {
    fn default() -> &'a Prediction {
        <Prediction as ::protobuf::Message>::default_instance()
    }
}

impl Prediction {
    pub fn new() -> Prediction {
        ::std::default::Default::default()
    }

    // .denkproto.ClassificationPrediction classification = 1;

    pub fn classification(&self) -> &ClassificationPrediction {
        match self.prediction {
            ::std::option::Option::Some(prediction::Prediction::Classification(ref v)) => v,
            _ => <ClassificationPrediction as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_classification(&mut self) {
        self.prediction = ::std::option::Option::None;
    }

    pub fn has_classification(&self) -> bool {
        match self.prediction {
            ::std::option::Option::Some(prediction::Prediction::Classification(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_classification(&mut self, v: ClassificationPrediction) {
        self.prediction = ::std::option::Option::Some(prediction::Prediction::Classification(v))
    }

    // Mutable pointer to the field.
    pub fn mut_classification(&mut self) -> &mut ClassificationPrediction {
        if let ::std::option::Option::Some(prediction::Prediction::Classification(_)) = self.prediction {
        } else {
            self.prediction = ::std::option::Option::Some(prediction::Prediction::Classification(ClassificationPrediction::new()));
        }
        match self.prediction {
            ::std::option::Option::Some(prediction::Prediction::Classification(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_classification(&mut self) -> ClassificationPrediction {
        if self.has_classification() {
            match self.prediction.take() {
                ::std::option::Option::Some(prediction::Prediction::Classification(v)) => v,
                _ => panic!(),
            }
        } else {
            ClassificationPrediction::new()
        }
    }

    // .denkproto.ObjectDetectionPrediction object_detection = 2;

    pub fn object_detection(&self) -> &ObjectDetectionPrediction {
        match self.prediction {
            ::std::option::Option::Some(prediction::Prediction::ObjectDetection(ref v)) => v,
            _ => <ObjectDetectionPrediction as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_object_detection(&mut self) {
        self.prediction = ::std::option::Option::None;
    }

    pub fn has_object_detection(&self) -> bool {
        match self.prediction {
            ::std::option::Option::Some(prediction::Prediction::ObjectDetection(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_object_detection(&mut self, v: ObjectDetectionPrediction) {
        self.prediction = ::std::option::Option::Some(prediction::Prediction::ObjectDetection(v))
    }

    // Mutable pointer to the field.
    pub fn mut_object_detection(&mut self) -> &mut ObjectDetectionPrediction {
        if let ::std::option::Option::Some(prediction::Prediction::ObjectDetection(_)) = self.prediction {
        } else {
            self.prediction = ::std::option::Option::Some(prediction::Prediction::ObjectDetection(ObjectDetectionPrediction::new()));
        }
        match self.prediction {
            ::std::option::Option::Some(prediction::Prediction::ObjectDetection(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_object_detection(&mut self) -> ObjectDetectionPrediction {
        if self.has_object_detection() {
            match self.prediction.take() {
                ::std::option::Option::Some(prediction::Prediction::ObjectDetection(v)) => v,
                _ => panic!(),
            }
        } else {
            ObjectDetectionPrediction::new()
        }
    }

    // .denkproto.InstanceSegmentationPrediction instance_segmentation = 3;

    pub fn instance_segmentation(&self) -> &InstanceSegmentationPrediction {
        match self.prediction {
            ::std::option::Option::Some(prediction::Prediction::InstanceSegmentation(ref v)) => v,
            _ => <InstanceSegmentationPrediction as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_instance_segmentation(&mut self) {
        self.prediction = ::std::option::Option::None;
    }

    pub fn has_instance_segmentation(&self) -> bool {
        match self.prediction {
            ::std::option::Option::Some(prediction::Prediction::InstanceSegmentation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instance_segmentation(&mut self, v: InstanceSegmentationPrediction) {
        self.prediction = ::std::option::Option::Some(prediction::Prediction::InstanceSegmentation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instance_segmentation(&mut self) -> &mut InstanceSegmentationPrediction {
        if let ::std::option::Option::Some(prediction::Prediction::InstanceSegmentation(_)) = self.prediction {
        } else {
            self.prediction = ::std::option::Option::Some(prediction::Prediction::InstanceSegmentation(InstanceSegmentationPrediction::new()));
        }
        match self.prediction {
            ::std::option::Option::Some(prediction::Prediction::InstanceSegmentation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instance_segmentation(&mut self) -> InstanceSegmentationPrediction {
        if self.has_instance_segmentation() {
            match self.prediction.take() {
                ::std::option::Option::Some(prediction::Prediction::InstanceSegmentation(v)) => v,
                _ => panic!(),
            }
        } else {
            InstanceSegmentationPrediction::new()
        }
    }

    // .denkproto.OCRPrediction ocr = 4;

    pub fn ocr(&self) -> &OCRPrediction {
        match self.prediction {
            ::std::option::Option::Some(prediction::Prediction::Ocr(ref v)) => v,
            _ => <OCRPrediction as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_ocr(&mut self) {
        self.prediction = ::std::option::Option::None;
    }

    pub fn has_ocr(&self) -> bool {
        match self.prediction {
            ::std::option::Option::Some(prediction::Prediction::Ocr(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ocr(&mut self, v: OCRPrediction) {
        self.prediction = ::std::option::Option::Some(prediction::Prediction::Ocr(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ocr(&mut self) -> &mut OCRPrediction {
        if let ::std::option::Option::Some(prediction::Prediction::Ocr(_)) = self.prediction {
        } else {
            self.prediction = ::std::option::Option::Some(prediction::Prediction::Ocr(OCRPrediction::new()));
        }
        match self.prediction {
            ::std::option::Option::Some(prediction::Prediction::Ocr(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ocr(&mut self) -> OCRPrediction {
        if self.has_ocr() {
            match self.prediction.take() {
                ::std::option::Option::Some(prediction::Prediction::Ocr(v)) => v,
                _ => panic!(),
            }
        } else {
            OCRPrediction::new()
        }
    }

    // .denkproto.CodePrediction code = 5;

    pub fn code(&self) -> &CodePrediction {
        match self.prediction {
            ::std::option::Option::Some(prediction::Prediction::Code(ref v)) => v,
            _ => <CodePrediction as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_code(&mut self) {
        self.prediction = ::std::option::Option::None;
    }

    pub fn has_code(&self) -> bool {
        match self.prediction {
            ::std::option::Option::Some(prediction::Prediction::Code(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: CodePrediction) {
        self.prediction = ::std::option::Option::Some(prediction::Prediction::Code(v))
    }

    // Mutable pointer to the field.
    pub fn mut_code(&mut self) -> &mut CodePrediction {
        if let ::std::option::Option::Some(prediction::Prediction::Code(_)) = self.prediction {
        } else {
            self.prediction = ::std::option::Option::Some(prediction::Prediction::Code(CodePrediction::new()));
        }
        match self.prediction {
            ::std::option::Option::Some(prediction::Prediction::Code(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_code(&mut self) -> CodePrediction {
        if self.has_code() {
            match self.prediction.take() {
                ::std::option::Option::Some(prediction::Prediction::Code(v)) => v,
                _ => panic!(),
            }
        } else {
            CodePrediction::new()
        }
    }

    // .denkproto.FloatMap segmentation = 6;

    pub fn segmentation(&self) -> &FloatMap {
        match self.prediction {
            ::std::option::Option::Some(prediction::Prediction::Segmentation(ref v)) => v,
            _ => <FloatMap as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_segmentation(&mut self) {
        self.prediction = ::std::option::Option::None;
    }

    pub fn has_segmentation(&self) -> bool {
        match self.prediction {
            ::std::option::Option::Some(prediction::Prediction::Segmentation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_segmentation(&mut self, v: FloatMap) {
        self.prediction = ::std::option::Option::Some(prediction::Prediction::Segmentation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_segmentation(&mut self) -> &mut FloatMap {
        if let ::std::option::Option::Some(prediction::Prediction::Segmentation(_)) = self.prediction {
        } else {
            self.prediction = ::std::option::Option::Some(prediction::Prediction::Segmentation(FloatMap::new()));
        }
        match self.prediction {
            ::std::option::Option::Some(prediction::Prediction::Segmentation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_segmentation(&mut self) -> FloatMap {
        if self.has_segmentation() {
            match self.prediction.take() {
                ::std::option::Option::Some(prediction::Prediction::Segmentation(v)) => v,
                _ => panic!(),
            }
        } else {
            FloatMap::new()
        }
    }

    // .denkproto.FloatMap anomaly_detection = 7;

    pub fn anomaly_detection(&self) -> &FloatMap {
        match self.prediction {
            ::std::option::Option::Some(prediction::Prediction::AnomalyDetection(ref v)) => v,
            _ => <FloatMap as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_anomaly_detection(&mut self) {
        self.prediction = ::std::option::Option::None;
    }

    pub fn has_anomaly_detection(&self) -> bool {
        match self.prediction {
            ::std::option::Option::Some(prediction::Prediction::AnomalyDetection(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_anomaly_detection(&mut self, v: FloatMap) {
        self.prediction = ::std::option::Option::Some(prediction::Prediction::AnomalyDetection(v))
    }

    // Mutable pointer to the field.
    pub fn mut_anomaly_detection(&mut self) -> &mut FloatMap {
        if let ::std::option::Option::Some(prediction::Prediction::AnomalyDetection(_)) = self.prediction {
        } else {
            self.prediction = ::std::option::Option::Some(prediction::Prediction::AnomalyDetection(FloatMap::new()));
        }
        match self.prediction {
            ::std::option::Option::Some(prediction::Prediction::AnomalyDetection(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_anomaly_detection(&mut self) -> FloatMap {
        if self.has_anomaly_detection() {
            match self.prediction.take() {
                ::std::option::Option::Some(prediction::Prediction::AnomalyDetection(v)) => v,
                _ => panic!(),
            }
        } else {
            FloatMap::new()
        }
    }
}

impl ::protobuf::Message for Prediction {
    const NAME: &'static str = "Prediction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.prediction = ::std::option::Option::Some(prediction::Prediction::Classification(is.read_message()?));
                },
                18 => {
                    self.prediction = ::std::option::Option::Some(prediction::Prediction::ObjectDetection(is.read_message()?));
                },
                26 => {
                    self.prediction = ::std::option::Option::Some(prediction::Prediction::InstanceSegmentation(is.read_message()?));
                },
                34 => {
                    self.prediction = ::std::option::Option::Some(prediction::Prediction::Ocr(is.read_message()?));
                },
                42 => {
                    self.prediction = ::std::option::Option::Some(prediction::Prediction::Code(is.read_message()?));
                },
                50 => {
                    self.prediction = ::std::option::Option::Some(prediction::Prediction::Segmentation(is.read_message()?));
                },
                58 => {
                    self.prediction = ::std::option::Option::Some(prediction::Prediction::AnomalyDetection(is.read_message()?));
                },
                162 => {
                    self.computed_properties.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.computed_properties {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let ::std::option::Option::Some(ref v) = self.prediction {
            match v {
                &prediction::Prediction::Classification(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &prediction::Prediction::ObjectDetection(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &prediction::Prediction::InstanceSegmentation(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &prediction::Prediction::Ocr(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &prediction::Prediction::Code(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &prediction::Prediction::Segmentation(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &prediction::Prediction::AnomalyDetection(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.computed_properties {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        };
        if let ::std::option::Option::Some(ref v) = self.prediction {
            match v {
                &prediction::Prediction::Classification(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &prediction::Prediction::ObjectDetection(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &prediction::Prediction::InstanceSegmentation(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &prediction::Prediction::Ocr(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &prediction::Prediction::Code(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &prediction::Prediction::Segmentation(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &prediction::Prediction::AnomalyDetection(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Prediction {
        Prediction::new()
    }

    fn clear(&mut self) {
        self.prediction = ::std::option::Option::None;
        self.prediction = ::std::option::Option::None;
        self.prediction = ::std::option::Option::None;
        self.prediction = ::std::option::Option::None;
        self.prediction = ::std::option::Option::None;
        self.prediction = ::std::option::Option::None;
        self.prediction = ::std::option::Option::None;
        self.computed_properties.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Prediction {
        static instance: Prediction = Prediction {
            computed_properties: ::std::vec::Vec::new(),
            prediction: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `Prediction`
pub mod prediction {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:denkproto.Prediction.prediction)
    pub enum Prediction {
        // @@protoc_insertion_point(oneof_field:denkproto.Prediction.classification)
        Classification(super::ClassificationPrediction),
        // @@protoc_insertion_point(oneof_field:denkproto.Prediction.object_detection)
        ObjectDetection(super::ObjectDetectionPrediction),
        // @@protoc_insertion_point(oneof_field:denkproto.Prediction.instance_segmentation)
        InstanceSegmentation(super::InstanceSegmentationPrediction),
        // @@protoc_insertion_point(oneof_field:denkproto.Prediction.ocr)
        Ocr(super::OCRPrediction),
        // @@protoc_insertion_point(oneof_field:denkproto.Prediction.code)
        Code(super::CodePrediction),
        // @@protoc_insertion_point(oneof_field:denkproto.Prediction.segmentation)
        Segmentation(super::FloatMap),
        // @@protoc_insertion_point(oneof_field:denkproto.Prediction.anomaly_detection)
        AnomalyDetection(super::FloatMap),
    }

    impl ::protobuf::Oneof for Prediction {
    }

    impl Prediction {
    }
}

// @@protoc_insertion_point(message:denkproto.Predictions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Predictions {
    // message fields
    // @@protoc_insertion_point(field:denkproto.Predictions.predictions)
    pub predictions: ::std::vec::Vec<Prediction>,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.Predictions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Predictions {
    fn default() -> &'a Predictions {
        <Predictions as ::protobuf::Message>::default_instance()
    }
}

impl Predictions {
    pub fn new() -> Predictions {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Predictions {
    const NAME: &'static str = "Predictions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.predictions.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.predictions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.predictions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Predictions {
        Predictions::new()
    }

    fn clear(&mut self) {
        self.predictions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Predictions {
        static instance: Predictions = Predictions {
            predictions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:denkproto.Result)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Result {
    // message fields
    // @@protoc_insertion_point(field:denkproto.Result.grade)
    pub grade: i32,
    // @@protoc_insertion_point(field:denkproto.Result.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:denkproto.Result.color)
    pub color: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.Result.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Result {
    fn default() -> &'a Result {
        <Result as ::protobuf::Message>::default_instance()
    }
}

impl Result {
    pub fn new() -> Result {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Result {
    const NAME: &'static str = "Result";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.grade = is.read_int32()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.color = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.grade != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.grade);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.color.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.color);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.grade != 0 {
            os.write_int32(1, self.grade)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.color.is_empty() {
            os.write_string(3, &self.color)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Result {
        Result::new()
    }

    fn clear(&mut self) {
        self.grade = 0;
        self.name.clear();
        self.color.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Result {
        static instance: Result = Result {
            grade: 0,
            name: ::std::string::String::new(),
            color: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:denkproto.ClassLabel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClassLabel {
    // message fields
    // @@protoc_insertion_point(field:denkproto.ClassLabel.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:denkproto.ClassLabel.network_id)
    pub network_id: ::std::string::String,
    // @@protoc_insertion_point(field:denkproto.ClassLabel.index)
    pub index: i32,
    // @@protoc_insertion_point(field:denkproto.ClassLabel.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:denkproto.ClassLabel.color)
    pub color: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.ClassLabel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClassLabel {
    fn default() -> &'a ClassLabel {
        <ClassLabel as ::protobuf::Message>::default_instance()
    }
}

impl ClassLabel {
    pub fn new() -> ClassLabel {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ClassLabel {
    const NAME: &'static str = "ClassLabel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.network_id = is.read_string()?;
                },
                24 => {
                    self.index = is.read_int32()?;
                },
                34 => {
                    self.name = is.read_string()?;
                },
                42 => {
                    self.color = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.network_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.network_id);
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.index);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.name);
        }
        if !self.color.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.color);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.network_id.is_empty() {
            os.write_string(2, &self.network_id)?;
        }
        if self.index != 0 {
            os.write_int32(3, self.index)?;
        }
        if !self.name.is_empty() {
            os.write_string(4, &self.name)?;
        }
        if !self.color.is_empty() {
            os.write_string(5, &self.color)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClassLabel {
        ClassLabel::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.network_id.clear();
        self.index = 0;
        self.name.clear();
        self.color.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClassLabel {
        static instance: ClassLabel = ClassLabel {
            id: ::std::string::String::new(),
            network_id: ::std::string::String::new(),
            index: 0,
            name: ::std::string::String::new(),
            color: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:denkproto.DENKbuffer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DENKbuffer {
    // message fields
    // @@protoc_insertion_point(field:denkproto.DENKbuffer.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:denkproto.DENKbuffer.project_id)
    pub project_id: ::std::string::String,
    // @@protoc_insertion_point(field:denkproto.DENKbuffer.created_by_user_id)
    pub created_by_user_id: ::std::string::String,
    // @@protoc_insertion_point(field:denkproto.DENKbuffer.owned_by_group_id)
    pub owned_by_group_id: ::std::string::String,
    // @@protoc_insertion_point(field:denkproto.DENKbuffer.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:denkproto.DENKbuffer.pipeline_config)
    pub pipeline_config: ::std::string::String,
    // @@protoc_insertion_point(field:denkproto.DENKbuffer.port_names)
    pub port_names: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:denkproto.DENKbuffer.class_labels)
    pub class_labels: ::std::collections::HashMap<::std::string::String, ClassLabel>,
    // @@protoc_insertion_point(field:denkproto.DENKbuffer.triggers)
    pub triggers: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:denkproto.DENKbuffer.images)
    pub images: ::std::collections::HashMap<::std::string::String, Image>,
    // @@protoc_insertion_point(field:denkproto.DENKbuffer.predictions)
    pub predictions: ::std::collections::HashMap<::std::string::String, Predictions>,
    // @@protoc_insertion_point(field:denkproto.DENKbuffer.results)
    pub results: ::std::collections::HashMap<::std::string::String, Result>,
    // @@protoc_insertion_point(field:denkproto.DENKbuffer.tags)
    pub tags: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.DENKbuffer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DENKbuffer {
    fn default() -> &'a DENKbuffer {
        <DENKbuffer as ::protobuf::Message>::default_instance()
    }
}

impl DENKbuffer {
    pub fn new() -> DENKbuffer {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DENKbuffer {
    const NAME: &'static str = "DENKbuffer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.project_id = is.read_string()?;
                },
                26 => {
                    self.created_by_user_id = is.read_string()?;
                },
                34 => {
                    self.owned_by_group_id = is.read_string()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                50 => {
                    self.pipeline_config = is.read_string()?;
                },
                58 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.port_names.insert(key, value);
                },
                90 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.class_labels.insert(key, value);
                },
                170 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.triggers.insert(key, value);
                },
                250 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.images.insert(key, value);
                },
                330 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.predictions.insert(key, value);
                },
                410 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.results.insert(key, value);
                },
                810 => {
                    self.tags.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.project_id);
        }
        if !self.created_by_user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.created_by_user_id);
        }
        if !self.owned_by_group_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.owned_by_group_id);
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.pipeline_config.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.pipeline_config);
        }
        for (k, v) in &self.port_names {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.class_labels {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.triggers {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.images {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.predictions {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.results {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(101, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.project_id.is_empty() {
            os.write_string(2, &self.project_id)?;
        }
        if !self.created_by_user_id.is_empty() {
            os.write_string(3, &self.created_by_user_id)?;
        }
        if !self.owned_by_group_id.is_empty() {
            os.write_string(4, &self.owned_by_group_id)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if !self.pipeline_config.is_empty() {
            os.write_string(6, &self.pipeline_config)?;
        }
        for (k, v) in &self.port_names {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(58)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        for (k, v) in &self.class_labels {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(90)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.triggers {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(170)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.images {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(250)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.predictions {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(330)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.results {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(410)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.tags {
            os.write_string(101, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DENKbuffer {
        DENKbuffer::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.project_id.clear();
        self.created_by_user_id.clear();
        self.owned_by_group_id.clear();
        self.created_at.clear();
        self.pipeline_config.clear();
        self.port_names.clear();
        self.class_labels.clear();
        self.triggers.clear();
        self.images.clear();
        self.predictions.clear();
        self.results.clear();
        self.tags.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DENKbuffer {
        static instance: ::protobuf::rt::Lazy<DENKbuffer> = ::protobuf::rt::Lazy::new();
        instance.get(DENKbuffer::new)
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:denkproto.ImageTypes)
pub enum ImageTypes {
    // @@protoc_insertion_point(enum_value:denkproto.ImageTypes.Raw)
    Raw = 0,
    // @@protoc_insertion_point(enum_value:denkproto.ImageTypes.JPEG)
    JPEG = 1,
    // @@protoc_insertion_point(enum_value:denkproto.ImageTypes.PNG)
    PNG = 2,
}

impl ::protobuf::Enum for ImageTypes {
    const NAME: &'static str = "ImageTypes";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ImageTypes> {
        match value {
            0 => ::std::option::Option::Some(ImageTypes::Raw),
            1 => ::std::option::Option::Some(ImageTypes::JPEG),
            2 => ::std::option::Option::Some(ImageTypes::PNG),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ImageTypes> {
        match str {
            "Raw" => ::std::option::Option::Some(ImageTypes::Raw),
            "JPEG" => ::std::option::Option::Some(ImageTypes::JPEG),
            "PNG" => ::std::option::Option::Some(ImageTypes::PNG),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ImageTypes] = &[
        ImageTypes::Raw,
        ImageTypes::JPEG,
        ImageTypes::PNG,
    ];
}

impl ::std::default::Default for ImageTypes {
    fn default() -> Self {
        ImageTypes::Raw
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:denkproto.ComputedPropertySubjects)
pub enum ComputedPropertySubjects {
    // @@protoc_insertion_point(enum_value:denkproto.ComputedPropertySubjects.COMPUTED_PROPERTY_SUBJECT_MEAN_GRAY_VALUE)
    COMPUTED_PROPERTY_SUBJECT_MEAN_GRAY_VALUE = 0,
}

impl ::protobuf::Enum for ComputedPropertySubjects {
    const NAME: &'static str = "ComputedPropertySubjects";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ComputedPropertySubjects> {
        match value {
            0 => ::std::option::Option::Some(ComputedPropertySubjects::COMPUTED_PROPERTY_SUBJECT_MEAN_GRAY_VALUE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ComputedPropertySubjects> {
        match str {
            "COMPUTED_PROPERTY_SUBJECT_MEAN_GRAY_VALUE" => ::std::option::Option::Some(ComputedPropertySubjects::COMPUTED_PROPERTY_SUBJECT_MEAN_GRAY_VALUE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ComputedPropertySubjects] = &[
        ComputedPropertySubjects::COMPUTED_PROPERTY_SUBJECT_MEAN_GRAY_VALUE,
    ];
}

impl ::std::default::Default for ComputedPropertySubjects {
    fn default() -> Self {
        ComputedPropertySubjects::COMPUTED_PROPERTY_SUBJECT_MEAN_GRAY_VALUE
    }
}

