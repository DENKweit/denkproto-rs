// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `ImageAnalysis_ProtobufMessages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:image_analysis.pb_ProtocolVersionDetection)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pb_ProtocolVersionDetection {
    // message fields
    // @@protoc_insertion_point(field:image_analysis.pb_ProtocolVersionDetection.protocol_version_major)
    pub protocol_version_major: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:image_analysis.pb_ProtocolVersionDetection.protocol_version_minor)
    pub protocol_version_minor: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:image_analysis.pb_ProtocolVersionDetection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pb_ProtocolVersionDetection {
    fn default() -> &'a Pb_ProtocolVersionDetection {
        <Pb_ProtocolVersionDetection as ::protobuf::Message>::default_instance()
    }
}

impl Pb_ProtocolVersionDetection {
    pub fn new() -> Pb_ProtocolVersionDetection {
        ::std::default::Default::default()
    }

    // optional int32 protocol_version_major = 1;

    pub fn protocol_version_major(&self) -> i32 {
        self.protocol_version_major.unwrap_or(1i32)
    }

    pub fn clear_protocol_version_major(&mut self) {
        self.protocol_version_major = ::std::option::Option::None;
    }

    pub fn has_protocol_version_major(&self) -> bool {
        self.protocol_version_major.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version_major(&mut self, v: i32) {
        self.protocol_version_major = ::std::option::Option::Some(v);
    }

    // optional int32 protocol_version_minor = 2;

    pub fn protocol_version_minor(&self) -> i32 {
        self.protocol_version_minor.unwrap_or(119i32)
    }

    pub fn clear_protocol_version_minor(&mut self) {
        self.protocol_version_minor = ::std::option::Option::None;
    }

    pub fn has_protocol_version_minor(&self) -> bool {
        self.protocol_version_minor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version_minor(&mut self, v: i32) {
        self.protocol_version_minor = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "protocol_version_major",
            |m: &Pb_ProtocolVersionDetection| { &m.protocol_version_major },
            |m: &mut Pb_ProtocolVersionDetection| { &mut m.protocol_version_major },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "protocol_version_minor",
            |m: &Pb_ProtocolVersionDetection| { &m.protocol_version_minor },
            |m: &mut Pb_ProtocolVersionDetection| { &mut m.protocol_version_minor },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_ProtocolVersionDetection>(
            "pb_ProtocolVersionDetection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pb_ProtocolVersionDetection {
    const NAME: &'static str = "pb_ProtocolVersionDetection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.protocol_version_major = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.protocol_version_minor = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.protocol_version_major {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.protocol_version_minor {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.protocol_version_major {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.protocol_version_minor {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pb_ProtocolVersionDetection {
        Pb_ProtocolVersionDetection::new()
    }

    fn clear(&mut self) {
        self.protocol_version_major = ::std::option::Option::None;
        self.protocol_version_minor = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pb_ProtocolVersionDetection {
        static instance: Pb_ProtocolVersionDetection = Pb_ProtocolVersionDetection {
            protocol_version_major: ::std::option::Option::None,
            protocol_version_minor: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pb_ProtocolVersionDetection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("pb_ProtocolVersionDetection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pb_ProtocolVersionDetection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pb_ProtocolVersionDetection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:image_analysis.pb_MessageHeader)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pb_MessageHeader {
    // message fields
    // @@protoc_insertion_point(field:image_analysis.pb_MessageHeader.message_type)
    pub message_type: ::std::option::Option<::protobuf::EnumOrUnknown<pb_message_header::MessageType>>,
    // @@protoc_insertion_point(field:image_analysis.pb_MessageHeader.response)
    pub response: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:image_analysis.pb_MessageHeader.message_counter)
    pub message_counter: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:image_analysis.pb_MessageHeader.size_message_body)
    pub size_message_body: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:image_analysis.pb_MessageHeader.protocol_version_major)
    pub protocol_version_major: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:image_analysis.pb_MessageHeader.protocol_version_minor)
    pub protocol_version_minor: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:image_analysis.pb_MessageHeader.timestamp_utc_ms)
    pub timestamp_utc_ms: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:image_analysis.pb_MessageHeader.error_code)
    pub error_code: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:image_analysis.pb_MessageHeader.info_text)
    pub info_text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:image_analysis.pb_MessageHeader.int_values)
    pub int_values: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:image_analysis.pb_MessageHeader.double_values)
    pub double_values: ::std::vec::Vec<f64>,
    // @@protoc_insertion_point(field:image_analysis.pb_MessageHeader.string_values)
    pub string_values: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:image_analysis.pb_MessageHeader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pb_MessageHeader {
    fn default() -> &'a Pb_MessageHeader {
        <Pb_MessageHeader as ::protobuf::Message>::default_instance()
    }
}

impl Pb_MessageHeader {
    pub fn new() -> Pb_MessageHeader {
        ::std::default::Default::default()
    }

    // required .image_analysis.pb_MessageHeader.MessageType message_type = 1;

    pub fn message_type(&self) -> pb_message_header::MessageType {
        match self.message_type {
            Some(e) => e.enum_value_or(pb_message_header::MessageType::UNDEFINED),
            None => pb_message_header::MessageType::UNDEFINED,
        }
    }

    pub fn clear_message_type(&mut self) {
        self.message_type = ::std::option::Option::None;
    }

    pub fn has_message_type(&self) -> bool {
        self.message_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_type(&mut self, v: pb_message_header::MessageType) {
        self.message_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required bool response = 2;

    pub fn response(&self) -> bool {
        self.response.unwrap_or(false)
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: bool) {
        self.response = ::std::option::Option::Some(v);
    }

    // required uint32 message_counter = 3;

    pub fn message_counter(&self) -> u32 {
        self.message_counter.unwrap_or(0)
    }

    pub fn clear_message_counter(&mut self) {
        self.message_counter = ::std::option::Option::None;
    }

    pub fn has_message_counter(&self) -> bool {
        self.message_counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_counter(&mut self, v: u32) {
        self.message_counter = ::std::option::Option::Some(v);
    }

    // required uint32 size_message_body = 4;

    pub fn size_message_body(&self) -> u32 {
        self.size_message_body.unwrap_or(0)
    }

    pub fn clear_size_message_body(&mut self) {
        self.size_message_body = ::std::option::Option::None;
    }

    pub fn has_size_message_body(&self) -> bool {
        self.size_message_body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size_message_body(&mut self, v: u32) {
        self.size_message_body = ::std::option::Option::Some(v);
    }

    // optional int32 protocol_version_major = 5;

    pub fn protocol_version_major(&self) -> i32 {
        self.protocol_version_major.unwrap_or(0)
    }

    pub fn clear_protocol_version_major(&mut self) {
        self.protocol_version_major = ::std::option::Option::None;
    }

    pub fn has_protocol_version_major(&self) -> bool {
        self.protocol_version_major.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version_major(&mut self, v: i32) {
        self.protocol_version_major = ::std::option::Option::Some(v);
    }

    // optional int32 protocol_version_minor = 6;

    pub fn protocol_version_minor(&self) -> i32 {
        self.protocol_version_minor.unwrap_or(0)
    }

    pub fn clear_protocol_version_minor(&mut self) {
        self.protocol_version_minor = ::std::option::Option::None;
    }

    pub fn has_protocol_version_minor(&self) -> bool {
        self.protocol_version_minor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version_minor(&mut self, v: i32) {
        self.protocol_version_minor = ::std::option::Option::Some(v);
    }

    // required int64 timestamp_utc_ms = 7;

    pub fn timestamp_utc_ms(&self) -> i64 {
        self.timestamp_utc_ms.unwrap_or(0)
    }

    pub fn clear_timestamp_utc_ms(&mut self) {
        self.timestamp_utc_ms = ::std::option::Option::None;
    }

    pub fn has_timestamp_utc_ms(&self) -> bool {
        self.timestamp_utc_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp_utc_ms(&mut self, v: i64) {
        self.timestamp_utc_ms = ::std::option::Option::Some(v);
    }

    // required int32 error_code = 8;

    pub fn error_code(&self) -> i32 {
        self.error_code.unwrap_or(0)
    }

    pub fn clear_error_code(&mut self) {
        self.error_code = ::std::option::Option::None;
    }

    pub fn has_error_code(&self) -> bool {
        self.error_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_code(&mut self, v: i32) {
        self.error_code = ::std::option::Option::Some(v);
    }

    // optional string info_text = 9;

    pub fn info_text(&self) -> &str {
        match self.info_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_info_text(&mut self) {
        self.info_text = ::std::option::Option::None;
    }

    pub fn has_info_text(&self) -> bool {
        self.info_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info_text(&mut self, v: ::std::string::String) {
        self.info_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info_text(&mut self) -> &mut ::std::string::String {
        if self.info_text.is_none() {
            self.info_text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.info_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_info_text(&mut self) -> ::std::string::String {
        self.info_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message_type",
            |m: &Pb_MessageHeader| { &m.message_type },
            |m: &mut Pb_MessageHeader| { &mut m.message_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &Pb_MessageHeader| { &m.response },
            |m: &mut Pb_MessageHeader| { &mut m.response },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message_counter",
            |m: &Pb_MessageHeader| { &m.message_counter },
            |m: &mut Pb_MessageHeader| { &mut m.message_counter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size_message_body",
            |m: &Pb_MessageHeader| { &m.size_message_body },
            |m: &mut Pb_MessageHeader| { &mut m.size_message_body },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "protocol_version_major",
            |m: &Pb_MessageHeader| { &m.protocol_version_major },
            |m: &mut Pb_MessageHeader| { &mut m.protocol_version_major },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "protocol_version_minor",
            |m: &Pb_MessageHeader| { &m.protocol_version_minor },
            |m: &mut Pb_MessageHeader| { &mut m.protocol_version_minor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp_utc_ms",
            |m: &Pb_MessageHeader| { &m.timestamp_utc_ms },
            |m: &mut Pb_MessageHeader| { &mut m.timestamp_utc_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error_code",
            |m: &Pb_MessageHeader| { &m.error_code },
            |m: &mut Pb_MessageHeader| { &mut m.error_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "info_text",
            |m: &Pb_MessageHeader| { &m.info_text },
            |m: &mut Pb_MessageHeader| { &mut m.info_text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "int_values",
            |m: &Pb_MessageHeader| { &m.int_values },
            |m: &mut Pb_MessageHeader| { &mut m.int_values },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "double_values",
            |m: &Pb_MessageHeader| { &m.double_values },
            |m: &mut Pb_MessageHeader| { &mut m.double_values },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "string_values",
            |m: &Pb_MessageHeader| { &m.string_values },
            |m: &mut Pb_MessageHeader| { &mut m.string_values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_MessageHeader>(
            "pb_MessageHeader",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pb_MessageHeader {
    const NAME: &'static str = "pb_MessageHeader";

    fn is_initialized(&self) -> bool {
        if self.message_type.is_none() {
            return false;
        }
        if self.response.is_none() {
            return false;
        }
        if self.message_counter.is_none() {
            return false;
        }
        if self.size_message_body.is_none() {
            return false;
        }
        if self.timestamp_utc_ms.is_none() {
            return false;
        }
        if self.error_code.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.message_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.response = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.message_counter = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.size_message_body = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.protocol_version_major = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.protocol_version_minor = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.timestamp_utc_ms = ::std::option::Option::Some(is.read_int64()?);
                },
                64 => {
                    self.error_code = ::std::option::Option::Some(is.read_int32()?);
                },
                74 => {
                    self.info_text = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    is.read_repeated_packed_int32_into(&mut self.int_values)?;
                },
                80 => {
                    self.int_values.push(is.read_int32()?);
                },
                90 => {
                    is.read_repeated_packed_double_into(&mut self.double_values)?;
                },
                89 => {
                    self.double_values.push(is.read_double()?);
                },
                98 => {
                    self.string_values.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.response {
            my_size += 1 + 1;
        }
        if let Some(v) = self.message_counter {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.size_message_body {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.protocol_version_major {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.protocol_version_minor {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.timestamp_utc_ms {
            my_size += ::protobuf::rt::int64_size(7, v);
        }
        if let Some(v) = self.error_code {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.info_text.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        for value in &self.int_values {
            my_size += ::protobuf::rt::int32_size(10, *value);
        };
        my_size += 9 * self.double_values.len() as u64;
        for value in &self.string_values {
            my_size += ::protobuf::rt::string_size(12, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.response {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.message_counter {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.size_message_body {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.protocol_version_major {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.protocol_version_minor {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.timestamp_utc_ms {
            os.write_int64(7, v)?;
        }
        if let Some(v) = self.error_code {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.info_text.as_ref() {
            os.write_string(9, v)?;
        }
        for v in &self.int_values {
            os.write_int32(10, *v)?;
        };
        for v in &self.double_values {
            os.write_double(11, *v)?;
        };
        for v in &self.string_values {
            os.write_string(12, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pb_MessageHeader {
        Pb_MessageHeader::new()
    }

    fn clear(&mut self) {
        self.message_type = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.message_counter = ::std::option::Option::None;
        self.size_message_body = ::std::option::Option::None;
        self.protocol_version_major = ::std::option::Option::None;
        self.protocol_version_minor = ::std::option::Option::None;
        self.timestamp_utc_ms = ::std::option::Option::None;
        self.error_code = ::std::option::Option::None;
        self.info_text = ::std::option::Option::None;
        self.int_values.clear();
        self.double_values.clear();
        self.string_values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pb_MessageHeader {
        static instance: Pb_MessageHeader = Pb_MessageHeader {
            message_type: ::std::option::Option::None,
            response: ::std::option::Option::None,
            message_counter: ::std::option::Option::None,
            size_message_body: ::std::option::Option::None,
            protocol_version_major: ::std::option::Option::None,
            protocol_version_minor: ::std::option::Option::None,
            timestamp_utc_ms: ::std::option::Option::None,
            error_code: ::std::option::Option::None,
            info_text: ::std::option::Option::None,
            int_values: ::std::vec::Vec::new(),
            double_values: ::std::vec::Vec::new(),
            string_values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pb_MessageHeader {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("pb_MessageHeader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pb_MessageHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pb_MessageHeader {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `pb_MessageHeader`
pub mod pb_message_header {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:image_analysis.pb_MessageHeader.MessageType)
    pub enum MessageType {
        // @@protoc_insertion_point(enum_value:image_analysis.pb_MessageHeader.MessageType.UNDEFINED)
        UNDEFINED = 0,
        // @@protoc_insertion_point(enum_value:image_analysis.pb_MessageHeader.MessageType.GETSTATUS)
        GETSTATUS = 1,
        // @@protoc_insertion_point(enum_value:image_analysis.pb_MessageHeader.MessageType.GETVERSION)
        GETVERSION = 2,
        // @@protoc_insertion_point(enum_value:image_analysis.pb_MessageHeader.MessageType.INIT)
        INIT = 3,
        // @@protoc_insertion_point(enum_value:image_analysis.pb_MessageHeader.MessageType.GETPRESETS)
        GETPRESETS = 4,
        // @@protoc_insertion_point(enum_value:image_analysis.pb_MessageHeader.MessageType.GETPRESETINFO)
        GETPRESETINFO = 5,
        // @@protoc_insertion_point(enum_value:image_analysis.pb_MessageHeader.MessageType.SETCONFIG)
        SETCONFIG = 6,
        // @@protoc_insertion_point(enum_value:image_analysis.pb_MessageHeader.MessageType.REMOVECONFIG)
        REMOVECONFIG = 7,
        // @@protoc_insertion_point(enum_value:image_analysis.pb_MessageHeader.MessageType.GETCONFIGPARAMS)
        GETCONFIGPARAMS = 8,
        // @@protoc_insertion_point(enum_value:image_analysis.pb_MessageHeader.MessageType.SETCONFIGPARAMS)
        SETCONFIGPARAMS = 9,
        // @@protoc_insertion_point(enum_value:image_analysis.pb_MessageHeader.MessageType.ANALYZEIMAGE)
        ANALYZEIMAGE = 10,
        // @@protoc_insertion_point(enum_value:image_analysis.pb_MessageHeader.MessageType.IMAGERESULT)
        IMAGERESULT = 11,
        // @@protoc_insertion_point(enum_value:image_analysis.pb_MessageHeader.MessageType.INFOMESSAGE)
        INFOMESSAGE = 12,
        // @@protoc_insertion_point(enum_value:image_analysis.pb_MessageHeader.MessageType.GETCONFIGFILE)
        GETCONFIGFILE = 1000,
        // @@protoc_insertion_point(enum_value:image_analysis.pb_MessageHeader.MessageType.SETCONFIGFILE)
        SETCONFIGFILE = 1001,
        // @@protoc_insertion_point(enum_value:image_analysis.pb_MessageHeader.MessageType.MODIFYCONFIGFILE)
        MODIFYCONFIGFILE = 1002,
        // @@protoc_insertion_point(enum_value:image_analysis.pb_MessageHeader.MessageType.GETSTATISTICS)
        GETSTATISTICS = 1003,
    }

    impl ::protobuf::Enum for MessageType {
        const NAME: &'static str = "MessageType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<MessageType> {
            match value {
                0 => ::std::option::Option::Some(MessageType::UNDEFINED),
                1 => ::std::option::Option::Some(MessageType::GETSTATUS),
                2 => ::std::option::Option::Some(MessageType::GETVERSION),
                3 => ::std::option::Option::Some(MessageType::INIT),
                4 => ::std::option::Option::Some(MessageType::GETPRESETS),
                5 => ::std::option::Option::Some(MessageType::GETPRESETINFO),
                6 => ::std::option::Option::Some(MessageType::SETCONFIG),
                7 => ::std::option::Option::Some(MessageType::REMOVECONFIG),
                8 => ::std::option::Option::Some(MessageType::GETCONFIGPARAMS),
                9 => ::std::option::Option::Some(MessageType::SETCONFIGPARAMS),
                10 => ::std::option::Option::Some(MessageType::ANALYZEIMAGE),
                11 => ::std::option::Option::Some(MessageType::IMAGERESULT),
                12 => ::std::option::Option::Some(MessageType::INFOMESSAGE),
                1000 => ::std::option::Option::Some(MessageType::GETCONFIGFILE),
                1001 => ::std::option::Option::Some(MessageType::SETCONFIGFILE),
                1002 => ::std::option::Option::Some(MessageType::MODIFYCONFIGFILE),
                1003 => ::std::option::Option::Some(MessageType::GETSTATISTICS),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<MessageType> {
            match str {
                "UNDEFINED" => ::std::option::Option::Some(MessageType::UNDEFINED),
                "GETSTATUS" => ::std::option::Option::Some(MessageType::GETSTATUS),
                "GETVERSION" => ::std::option::Option::Some(MessageType::GETVERSION),
                "INIT" => ::std::option::Option::Some(MessageType::INIT),
                "GETPRESETS" => ::std::option::Option::Some(MessageType::GETPRESETS),
                "GETPRESETINFO" => ::std::option::Option::Some(MessageType::GETPRESETINFO),
                "SETCONFIG" => ::std::option::Option::Some(MessageType::SETCONFIG),
                "REMOVECONFIG" => ::std::option::Option::Some(MessageType::REMOVECONFIG),
                "GETCONFIGPARAMS" => ::std::option::Option::Some(MessageType::GETCONFIGPARAMS),
                "SETCONFIGPARAMS" => ::std::option::Option::Some(MessageType::SETCONFIGPARAMS),
                "ANALYZEIMAGE" => ::std::option::Option::Some(MessageType::ANALYZEIMAGE),
                "IMAGERESULT" => ::std::option::Option::Some(MessageType::IMAGERESULT),
                "INFOMESSAGE" => ::std::option::Option::Some(MessageType::INFOMESSAGE),
                "GETCONFIGFILE" => ::std::option::Option::Some(MessageType::GETCONFIGFILE),
                "SETCONFIGFILE" => ::std::option::Option::Some(MessageType::SETCONFIGFILE),
                "MODIFYCONFIGFILE" => ::std::option::Option::Some(MessageType::MODIFYCONFIGFILE),
                "GETSTATISTICS" => ::std::option::Option::Some(MessageType::GETSTATISTICS),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [MessageType] = &[
            MessageType::UNDEFINED,
            MessageType::GETSTATUS,
            MessageType::GETVERSION,
            MessageType::INIT,
            MessageType::GETPRESETS,
            MessageType::GETPRESETINFO,
            MessageType::SETCONFIG,
            MessageType::REMOVECONFIG,
            MessageType::GETCONFIGPARAMS,
            MessageType::SETCONFIGPARAMS,
            MessageType::ANALYZEIMAGE,
            MessageType::IMAGERESULT,
            MessageType::INFOMESSAGE,
            MessageType::GETCONFIGFILE,
            MessageType::SETCONFIGFILE,
            MessageType::MODIFYCONFIGFILE,
            MessageType::GETSTATISTICS,
        ];
    }

    impl ::protobuf::EnumFull for MessageType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("pb_MessageHeader.MessageType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                MessageType::UNDEFINED => 0,
                MessageType::GETSTATUS => 1,
                MessageType::GETVERSION => 2,
                MessageType::INIT => 3,
                MessageType::GETPRESETS => 4,
                MessageType::GETPRESETINFO => 5,
                MessageType::SETCONFIG => 6,
                MessageType::REMOVECONFIG => 7,
                MessageType::GETCONFIGPARAMS => 8,
                MessageType::SETCONFIGPARAMS => 9,
                MessageType::ANALYZEIMAGE => 10,
                MessageType::IMAGERESULT => 11,
                MessageType::INFOMESSAGE => 12,
                MessageType::GETCONFIGFILE => 13,
                MessageType::SETCONFIGFILE => 14,
                MessageType::MODIFYCONFIGFILE => 15,
                MessageType::GETSTATISTICS => 16,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for MessageType {
        fn default() -> Self {
            MessageType::UNDEFINED
        }
    }

    impl MessageType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MessageType>("pb_MessageHeader.MessageType")
        }
    }
}

// @@protoc_insertion_point(message:image_analysis.pb_Body_Init)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pb_Body_Init {
    // message fields
    // @@protoc_insertion_point(field:image_analysis.pb_Body_Init.init_hash_code)
    pub init_hash_code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:image_analysis.pb_Body_Init.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pb_Body_Init {
    fn default() -> &'a Pb_Body_Init {
        <Pb_Body_Init as ::protobuf::Message>::default_instance()
    }
}

impl Pb_Body_Init {
    pub fn new() -> Pb_Body_Init {
        ::std::default::Default::default()
    }

    // required string init_hash_code = 1;

    pub fn init_hash_code(&self) -> &str {
        match self.init_hash_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_init_hash_code(&mut self) {
        self.init_hash_code = ::std::option::Option::None;
    }

    pub fn has_init_hash_code(&self) -> bool {
        self.init_hash_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_init_hash_code(&mut self, v: ::std::string::String) {
        self.init_hash_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_init_hash_code(&mut self) -> &mut ::std::string::String {
        if self.init_hash_code.is_none() {
            self.init_hash_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.init_hash_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_init_hash_code(&mut self) -> ::std::string::String {
        self.init_hash_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "init_hash_code",
            |m: &Pb_Body_Init| { &m.init_hash_code },
            |m: &mut Pb_Body_Init| { &mut m.init_hash_code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_Body_Init>(
            "pb_Body_Init",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pb_Body_Init {
    const NAME: &'static str = "pb_Body_Init";

    fn is_initialized(&self) -> bool {
        if self.init_hash_code.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.init_hash_code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.init_hash_code.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.init_hash_code.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pb_Body_Init {
        Pb_Body_Init::new()
    }

    fn clear(&mut self) {
        self.init_hash_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pb_Body_Init {
        static instance: Pb_Body_Init = Pb_Body_Init {
            init_hash_code: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pb_Body_Init {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("pb_Body_Init").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pb_Body_Init {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pb_Body_Init {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:image_analysis.pb_Body_GetStatus_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pb_Body_GetStatus_Response {
    // message fields
    // @@protoc_insertion_point(field:image_analysis.pb_Body_GetStatus_Response.init_hash_code)
    pub init_hash_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:image_analysis.pb_Body_GetStatus_Response.init_timestamp_utc_ms)
    pub init_timestamp_utc_ms: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:image_analysis.pb_Body_GetStatus_Response.configuration_sets)
    pub configuration_sets: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:image_analysis.pb_Body_GetStatus_Response.images_in_process)
    pub images_in_process: ::std::vec::Vec<pb_body_get_status_response::Pb_ImageInProcess>,
    // special fields
    // @@protoc_insertion_point(special_field:image_analysis.pb_Body_GetStatus_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pb_Body_GetStatus_Response {
    fn default() -> &'a Pb_Body_GetStatus_Response {
        <Pb_Body_GetStatus_Response as ::protobuf::Message>::default_instance()
    }
}

impl Pb_Body_GetStatus_Response {
    pub fn new() -> Pb_Body_GetStatus_Response {
        ::std::default::Default::default()
    }

    // required string init_hash_code = 1;

    pub fn init_hash_code(&self) -> &str {
        match self.init_hash_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_init_hash_code(&mut self) {
        self.init_hash_code = ::std::option::Option::None;
    }

    pub fn has_init_hash_code(&self) -> bool {
        self.init_hash_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_init_hash_code(&mut self, v: ::std::string::String) {
        self.init_hash_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_init_hash_code(&mut self) -> &mut ::std::string::String {
        if self.init_hash_code.is_none() {
            self.init_hash_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.init_hash_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_init_hash_code(&mut self) -> ::std::string::String {
        self.init_hash_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required int64 init_timestamp_utc_ms = 2;

    pub fn init_timestamp_utc_ms(&self) -> i64 {
        self.init_timestamp_utc_ms.unwrap_or(0)
    }

    pub fn clear_init_timestamp_utc_ms(&mut self) {
        self.init_timestamp_utc_ms = ::std::option::Option::None;
    }

    pub fn has_init_timestamp_utc_ms(&self) -> bool {
        self.init_timestamp_utc_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_init_timestamp_utc_ms(&mut self, v: i64) {
        self.init_timestamp_utc_ms = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "init_hash_code",
            |m: &Pb_Body_GetStatus_Response| { &m.init_hash_code },
            |m: &mut Pb_Body_GetStatus_Response| { &mut m.init_hash_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "init_timestamp_utc_ms",
            |m: &Pb_Body_GetStatus_Response| { &m.init_timestamp_utc_ms },
            |m: &mut Pb_Body_GetStatus_Response| { &mut m.init_timestamp_utc_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "configuration_sets",
            |m: &Pb_Body_GetStatus_Response| { &m.configuration_sets },
            |m: &mut Pb_Body_GetStatus_Response| { &mut m.configuration_sets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "images_in_process",
            |m: &Pb_Body_GetStatus_Response| { &m.images_in_process },
            |m: &mut Pb_Body_GetStatus_Response| { &mut m.images_in_process },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_Body_GetStatus_Response>(
            "pb_Body_GetStatus_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pb_Body_GetStatus_Response {
    const NAME: &'static str = "pb_Body_GetStatus_Response";

    fn is_initialized(&self) -> bool {
        if self.init_hash_code.is_none() {
            return false;
        }
        if self.init_timestamp_utc_ms.is_none() {
            return false;
        }
        for v in &self.images_in_process {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.init_hash_code = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.init_timestamp_utc_ms = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    self.configuration_sets.push(is.read_string()?);
                },
                34 => {
                    self.images_in_process.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.init_hash_code.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.init_timestamp_utc_ms {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        for value in &self.configuration_sets {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.images_in_process {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.init_hash_code.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.init_timestamp_utc_ms {
            os.write_int64(2, v)?;
        }
        for v in &self.configuration_sets {
            os.write_string(3, &v)?;
        };
        for v in &self.images_in_process {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pb_Body_GetStatus_Response {
        Pb_Body_GetStatus_Response::new()
    }

    fn clear(&mut self) {
        self.init_hash_code = ::std::option::Option::None;
        self.init_timestamp_utc_ms = ::std::option::Option::None;
        self.configuration_sets.clear();
        self.images_in_process.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pb_Body_GetStatus_Response {
        static instance: Pb_Body_GetStatus_Response = Pb_Body_GetStatus_Response {
            init_hash_code: ::std::option::Option::None,
            init_timestamp_utc_ms: ::std::option::Option::None,
            configuration_sets: ::std::vec::Vec::new(),
            images_in_process: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pb_Body_GetStatus_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("pb_Body_GetStatus_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pb_Body_GetStatus_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pb_Body_GetStatus_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `pb_Body_GetStatus_Response`
pub mod pb_body_get_status_response {
    // @@protoc_insertion_point(message:image_analysis.pb_Body_GetStatus_Response.pb_ImageInProcess)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Pb_ImageInProcess {
        // message fields
        // @@protoc_insertion_point(field:image_analysis.pb_Body_GetStatus_Response.pb_ImageInProcess.serial_number_image)
        pub serial_number_image: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_GetStatus_Response.pb_ImageInProcess.configuration_set_name)
        pub configuration_set_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:image_analysis.pb_Body_GetStatus_Response.pb_ImageInProcess.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Pb_ImageInProcess {
        fn default() -> &'a Pb_ImageInProcess {
            <Pb_ImageInProcess as ::protobuf::Message>::default_instance()
        }
    }

    impl Pb_ImageInProcess {
        pub fn new() -> Pb_ImageInProcess {
            ::std::default::Default::default()
        }

        // required string serial_number_image = 1;

        pub fn serial_number_image(&self) -> &str {
            match self.serial_number_image.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_serial_number_image(&mut self) {
            self.serial_number_image = ::std::option::Option::None;
        }

        pub fn has_serial_number_image(&self) -> bool {
            self.serial_number_image.is_some()
        }

        // Param is passed by value, moved
        pub fn set_serial_number_image(&mut self, v: ::std::string::String) {
            self.serial_number_image = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_serial_number_image(&mut self) -> &mut ::std::string::String {
            if self.serial_number_image.is_none() {
                self.serial_number_image = ::std::option::Option::Some(::std::string::String::new());
            }
            self.serial_number_image.as_mut().unwrap()
        }

        // Take field
        pub fn take_serial_number_image(&mut self) -> ::std::string::String {
            self.serial_number_image.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // required string configuration_set_name = 2;

        pub fn configuration_set_name(&self) -> &str {
            match self.configuration_set_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_configuration_set_name(&mut self) {
            self.configuration_set_name = ::std::option::Option::None;
        }

        pub fn has_configuration_set_name(&self) -> bool {
            self.configuration_set_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_configuration_set_name(&mut self, v: ::std::string::String) {
            self.configuration_set_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_configuration_set_name(&mut self) -> &mut ::std::string::String {
            if self.configuration_set_name.is_none() {
                self.configuration_set_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.configuration_set_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_configuration_set_name(&mut self) -> ::std::string::String {
            self.configuration_set_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "serial_number_image",
                |m: &Pb_ImageInProcess| { &m.serial_number_image },
                |m: &mut Pb_ImageInProcess| { &mut m.serial_number_image },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "configuration_set_name",
                |m: &Pb_ImageInProcess| { &m.configuration_set_name },
                |m: &mut Pb_ImageInProcess| { &mut m.configuration_set_name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_ImageInProcess>(
                "pb_Body_GetStatus_Response.pb_ImageInProcess",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Pb_ImageInProcess {
        const NAME: &'static str = "pb_ImageInProcess";

        fn is_initialized(&self) -> bool {
            if self.serial_number_image.is_none() {
                return false;
            }
            if self.configuration_set_name.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.serial_number_image = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.configuration_set_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.serial_number_image.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.configuration_set_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.serial_number_image.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.configuration_set_name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Pb_ImageInProcess {
            Pb_ImageInProcess::new()
        }

        fn clear(&mut self) {
            self.serial_number_image = ::std::option::Option::None;
            self.configuration_set_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Pb_ImageInProcess {
            static instance: Pb_ImageInProcess = Pb_ImageInProcess {
                serial_number_image: ::std::option::Option::None,
                configuration_set_name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Pb_ImageInProcess {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("pb_Body_GetStatus_Response.pb_ImageInProcess").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Pb_ImageInProcess {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Pb_ImageInProcess {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:image_analysis.pb_Body_GetVersion_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pb_Body_GetVersion_Response {
    // message fields
    // @@protoc_insertion_point(field:image_analysis.pb_Body_GetVersion_Response.program_name)
    pub program_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:image_analysis.pb_Body_GetVersion_Response.program_version)
    pub program_version: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:image_analysis.pb_Body_GetVersion_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pb_Body_GetVersion_Response {
    fn default() -> &'a Pb_Body_GetVersion_Response {
        <Pb_Body_GetVersion_Response as ::protobuf::Message>::default_instance()
    }
}

impl Pb_Body_GetVersion_Response {
    pub fn new() -> Pb_Body_GetVersion_Response {
        ::std::default::Default::default()
    }

    // required string program_name = 1;

    pub fn program_name(&self) -> &str {
        match self.program_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_program_name(&mut self) {
        self.program_name = ::std::option::Option::None;
    }

    pub fn has_program_name(&self) -> bool {
        self.program_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_program_name(&mut self, v: ::std::string::String) {
        self.program_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_program_name(&mut self) -> &mut ::std::string::String {
        if self.program_name.is_none() {
            self.program_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.program_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_program_name(&mut self) -> ::std::string::String {
        self.program_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string program_version = 2;

    pub fn program_version(&self) -> &str {
        match self.program_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_program_version(&mut self) {
        self.program_version = ::std::option::Option::None;
    }

    pub fn has_program_version(&self) -> bool {
        self.program_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_program_version(&mut self, v: ::std::string::String) {
        self.program_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_program_version(&mut self) -> &mut ::std::string::String {
        if self.program_version.is_none() {
            self.program_version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.program_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_program_version(&mut self) -> ::std::string::String {
        self.program_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "program_name",
            |m: &Pb_Body_GetVersion_Response| { &m.program_name },
            |m: &mut Pb_Body_GetVersion_Response| { &mut m.program_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "program_version",
            |m: &Pb_Body_GetVersion_Response| { &m.program_version },
            |m: &mut Pb_Body_GetVersion_Response| { &mut m.program_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_Body_GetVersion_Response>(
            "pb_Body_GetVersion_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pb_Body_GetVersion_Response {
    const NAME: &'static str = "pb_Body_GetVersion_Response";

    fn is_initialized(&self) -> bool {
        if self.program_name.is_none() {
            return false;
        }
        if self.program_version.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.program_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.program_version = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.program_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.program_version.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.program_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.program_version.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pb_Body_GetVersion_Response {
        Pb_Body_GetVersion_Response::new()
    }

    fn clear(&mut self) {
        self.program_name = ::std::option::Option::None;
        self.program_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pb_Body_GetVersion_Response {
        static instance: Pb_Body_GetVersion_Response = Pb_Body_GetVersion_Response {
            program_name: ::std::option::Option::None,
            program_version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pb_Body_GetVersion_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("pb_Body_GetVersion_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pb_Body_GetVersion_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pb_Body_GetVersion_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:image_analysis.pb_Body_GetPresets_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pb_Body_GetPresets_Response {
    // message fields
    // @@protoc_insertion_point(field:image_analysis.pb_Body_GetPresets_Response.preset_name_list)
    pub preset_name_list: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:image_analysis.pb_Body_GetPresets_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pb_Body_GetPresets_Response {
    fn default() -> &'a Pb_Body_GetPresets_Response {
        <Pb_Body_GetPresets_Response as ::protobuf::Message>::default_instance()
    }
}

impl Pb_Body_GetPresets_Response {
    pub fn new() -> Pb_Body_GetPresets_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "preset_name_list",
            |m: &Pb_Body_GetPresets_Response| { &m.preset_name_list },
            |m: &mut Pb_Body_GetPresets_Response| { &mut m.preset_name_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_Body_GetPresets_Response>(
            "pb_Body_GetPresets_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pb_Body_GetPresets_Response {
    const NAME: &'static str = "pb_Body_GetPresets_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.preset_name_list.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.preset_name_list {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.preset_name_list {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pb_Body_GetPresets_Response {
        Pb_Body_GetPresets_Response::new()
    }

    fn clear(&mut self) {
        self.preset_name_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pb_Body_GetPresets_Response {
        static instance: Pb_Body_GetPresets_Response = Pb_Body_GetPresets_Response {
            preset_name_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pb_Body_GetPresets_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("pb_Body_GetPresets_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pb_Body_GetPresets_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pb_Body_GetPresets_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:image_analysis.pb_Body_GetPresetInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pb_Body_GetPresetInfo {
    // message fields
    // @@protoc_insertion_point(field:image_analysis.pb_Body_GetPresetInfo.preset_name)
    pub preset_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:image_analysis.pb_Body_GetPresetInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pb_Body_GetPresetInfo {
    fn default() -> &'a Pb_Body_GetPresetInfo {
        <Pb_Body_GetPresetInfo as ::protobuf::Message>::default_instance()
    }
}

impl Pb_Body_GetPresetInfo {
    pub fn new() -> Pb_Body_GetPresetInfo {
        ::std::default::Default::default()
    }

    // required string preset_name = 1;

    pub fn preset_name(&self) -> &str {
        match self.preset_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_preset_name(&mut self) {
        self.preset_name = ::std::option::Option::None;
    }

    pub fn has_preset_name(&self) -> bool {
        self.preset_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preset_name(&mut self, v: ::std::string::String) {
        self.preset_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preset_name(&mut self) -> &mut ::std::string::String {
        if self.preset_name.is_none() {
            self.preset_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.preset_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_preset_name(&mut self) -> ::std::string::String {
        self.preset_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "preset_name",
            |m: &Pb_Body_GetPresetInfo| { &m.preset_name },
            |m: &mut Pb_Body_GetPresetInfo| { &mut m.preset_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_Body_GetPresetInfo>(
            "pb_Body_GetPresetInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pb_Body_GetPresetInfo {
    const NAME: &'static str = "pb_Body_GetPresetInfo";

    fn is_initialized(&self) -> bool {
        if self.preset_name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.preset_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.preset_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.preset_name.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pb_Body_GetPresetInfo {
        Pb_Body_GetPresetInfo::new()
    }

    fn clear(&mut self) {
        self.preset_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pb_Body_GetPresetInfo {
        static instance: Pb_Body_GetPresetInfo = Pb_Body_GetPresetInfo {
            preset_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pb_Body_GetPresetInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("pb_Body_GetPresetInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pb_Body_GetPresetInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pb_Body_GetPresetInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:image_analysis.pb_Body_GetPresetInfo_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pb_Body_GetPresetInfo_Response {
    // message fields
    // @@protoc_insertion_point(field:image_analysis.pb_Body_GetPresetInfo_Response.preset_info)
    pub preset_info: ::protobuf::MessageField<pb_body_get_preset_info_response::Pb_PresetItem>,
    // special fields
    // @@protoc_insertion_point(special_field:image_analysis.pb_Body_GetPresetInfo_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pb_Body_GetPresetInfo_Response {
    fn default() -> &'a Pb_Body_GetPresetInfo_Response {
        <Pb_Body_GetPresetInfo_Response as ::protobuf::Message>::default_instance()
    }
}

impl Pb_Body_GetPresetInfo_Response {
    pub fn new() -> Pb_Body_GetPresetInfo_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, pb_body_get_preset_info_response::Pb_PresetItem>(
            "preset_info",
            |m: &Pb_Body_GetPresetInfo_Response| { &m.preset_info },
            |m: &mut Pb_Body_GetPresetInfo_Response| { &mut m.preset_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_Body_GetPresetInfo_Response>(
            "pb_Body_GetPresetInfo_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pb_Body_GetPresetInfo_Response {
    const NAME: &'static str = "pb_Body_GetPresetInfo_Response";

    fn is_initialized(&self) -> bool {
        for v in &self.preset_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.preset_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.preset_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.preset_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pb_Body_GetPresetInfo_Response {
        Pb_Body_GetPresetInfo_Response::new()
    }

    fn clear(&mut self) {
        self.preset_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pb_Body_GetPresetInfo_Response {
        static instance: Pb_Body_GetPresetInfo_Response = Pb_Body_GetPresetInfo_Response {
            preset_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pb_Body_GetPresetInfo_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("pb_Body_GetPresetInfo_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pb_Body_GetPresetInfo_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pb_Body_GetPresetInfo_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `pb_Body_GetPresetInfo_Response`
pub mod pb_body_get_preset_info_response {
    // @@protoc_insertion_point(message:image_analysis.pb_Body_GetPresetInfo_Response.pb_AddInfoItem)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Pb_AddInfoItem {
        // message fields
        // @@protoc_insertion_point(field:image_analysis.pb_Body_GetPresetInfo_Response.pb_AddInfoItem.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_GetPresetInfo_Response.pb_AddInfoItem.value)
        pub value: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:image_analysis.pb_Body_GetPresetInfo_Response.pb_AddInfoItem.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Pb_AddInfoItem {
        fn default() -> &'a Pb_AddInfoItem {
            <Pb_AddInfoItem as ::protobuf::Message>::default_instance()
        }
    }

    impl Pb_AddInfoItem {
        pub fn new() -> Pb_AddInfoItem {
            ::std::default::Default::default()
        }

        // required string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // required string value = 2;

        pub fn value(&self) -> &str {
            match self.value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: ::std::string::String) {
            self.value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_value(&mut self) -> &mut ::std::string::String {
            if self.value.is_none() {
                self.value = ::std::option::Option::Some(::std::string::String::new());
            }
            self.value.as_mut().unwrap()
        }

        // Take field
        pub fn take_value(&mut self) -> ::std::string::String {
            self.value.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Pb_AddInfoItem| { &m.name },
                |m: &mut Pb_AddInfoItem| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "value",
                |m: &Pb_AddInfoItem| { &m.value },
                |m: &mut Pb_AddInfoItem| { &mut m.value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_AddInfoItem>(
                "pb_Body_GetPresetInfo_Response.pb_AddInfoItem",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Pb_AddInfoItem {
        const NAME: &'static str = "pb_AddInfoItem";

        fn is_initialized(&self) -> bool {
            if self.name.is_none() {
                return false;
            }
            if self.value.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.value = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.value.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.value.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Pb_AddInfoItem {
            Pb_AddInfoItem::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Pb_AddInfoItem {
            static instance: Pb_AddInfoItem = Pb_AddInfoItem {
                name: ::std::option::Option::None,
                value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Pb_AddInfoItem {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("pb_Body_GetPresetInfo_Response.pb_AddInfoItem").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Pb_AddInfoItem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Pb_AddInfoItem {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:image_analysis.pb_Body_GetPresetInfo_Response.pb_ParamInfoItem)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Pb_ParamInfoItem {
        // message fields
        // @@protoc_insertion_point(field:image_analysis.pb_Body_GetPresetInfo_Response.pb_ParamInfoItem.param_name)
        pub param_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_GetPresetInfo_Response.pb_ParamInfoItem.datatype)
        pub datatype: ::std::option::Option<::protobuf::EnumOrUnknown<super::DataTypeEnum>>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_GetPresetInfo_Response.pb_ParamInfoItem.direction)
        pub direction: ::std::option::Option<::protobuf::EnumOrUnknown<DirectionEnum>>,
        // special fields
        // @@protoc_insertion_point(special_field:image_analysis.pb_Body_GetPresetInfo_Response.pb_ParamInfoItem.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Pb_ParamInfoItem {
        fn default() -> &'a Pb_ParamInfoItem {
            <Pb_ParamInfoItem as ::protobuf::Message>::default_instance()
        }
    }

    impl Pb_ParamInfoItem {
        pub fn new() -> Pb_ParamInfoItem {
            ::std::default::Default::default()
        }

        // required string param_name = 1;

        pub fn param_name(&self) -> &str {
            match self.param_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_param_name(&mut self) {
            self.param_name = ::std::option::Option::None;
        }

        pub fn has_param_name(&self) -> bool {
            self.param_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_param_name(&mut self, v: ::std::string::String) {
            self.param_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_param_name(&mut self) -> &mut ::std::string::String {
            if self.param_name.is_none() {
                self.param_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.param_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_param_name(&mut self) -> ::std::string::String {
            self.param_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // required .image_analysis.DataTypeEnum datatype = 2;

        pub fn datatype(&self) -> super::DataTypeEnum {
            match self.datatype {
                Some(e) => e.enum_value_or(super::DataTypeEnum::UNDEFINED_DT),
                None => super::DataTypeEnum::UNDEFINED_DT,
            }
        }

        pub fn clear_datatype(&mut self) {
            self.datatype = ::std::option::Option::None;
        }

        pub fn has_datatype(&self) -> bool {
            self.datatype.is_some()
        }

        // Param is passed by value, moved
        pub fn set_datatype(&mut self, v: super::DataTypeEnum) {
            self.datatype = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // required .image_analysis.pb_Body_GetPresetInfo_Response.DirectionEnum direction = 3;

        pub fn direction(&self) -> DirectionEnum {
            match self.direction {
                Some(e) => e.enum_value_or(DirectionEnum::UNDEFINED_DR),
                None => DirectionEnum::UNDEFINED_DR,
            }
        }

        pub fn clear_direction(&mut self) {
            self.direction = ::std::option::Option::None;
        }

        pub fn has_direction(&self) -> bool {
            self.direction.is_some()
        }

        // Param is passed by value, moved
        pub fn set_direction(&mut self, v: DirectionEnum) {
            self.direction = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "param_name",
                |m: &Pb_ParamInfoItem| { &m.param_name },
                |m: &mut Pb_ParamInfoItem| { &mut m.param_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "datatype",
                |m: &Pb_ParamInfoItem| { &m.datatype },
                |m: &mut Pb_ParamInfoItem| { &mut m.datatype },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "direction",
                |m: &Pb_ParamInfoItem| { &m.direction },
                |m: &mut Pb_ParamInfoItem| { &mut m.direction },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_ParamInfoItem>(
                "pb_Body_GetPresetInfo_Response.pb_ParamInfoItem",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Pb_ParamInfoItem {
        const NAME: &'static str = "pb_ParamInfoItem";

        fn is_initialized(&self) -> bool {
            if self.param_name.is_none() {
                return false;
            }
            if self.datatype.is_none() {
                return false;
            }
            if self.direction.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.param_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.datatype = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    24 => {
                        self.direction = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.param_name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.datatype {
                my_size += ::protobuf::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.direction {
                my_size += ::protobuf::rt::int32_size(3, v.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.param_name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.datatype {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.direction {
                os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Pb_ParamInfoItem {
            Pb_ParamInfoItem::new()
        }

        fn clear(&mut self) {
            self.param_name = ::std::option::Option::None;
            self.datatype = ::std::option::Option::None;
            self.direction = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Pb_ParamInfoItem {
            static instance: Pb_ParamInfoItem = Pb_ParamInfoItem {
                param_name: ::std::option::Option::None,
                datatype: ::std::option::Option::None,
                direction: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Pb_ParamInfoItem {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("pb_Body_GetPresetInfo_Response.pb_ParamInfoItem").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Pb_ParamInfoItem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Pb_ParamInfoItem {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:image_analysis.pb_Body_GetPresetInfo_Response.pb_PresetItem)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Pb_PresetItem {
        // message fields
        // @@protoc_insertion_point(field:image_analysis.pb_Body_GetPresetInfo_Response.pb_PresetItem.preset_name)
        pub preset_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_GetPresetInfo_Response.pb_PresetItem.date)
        pub date: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_GetPresetInfo_Response.pb_PresetItem.version)
        pub version: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_GetPresetInfo_Response.pb_PresetItem.comment)
        pub comment: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_GetPresetInfo_Response.pb_PresetItem.feature_types)
        pub feature_types: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_GetPresetInfo_Response.pb_PresetItem.additional_infos)
        pub additional_infos: ::std::vec::Vec<Pb_AddInfoItem>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_GetPresetInfo_Response.pb_PresetItem.param_list)
        pub param_list: ::std::vec::Vec<Pb_ParamInfoItem>,
        // special fields
        // @@protoc_insertion_point(special_field:image_analysis.pb_Body_GetPresetInfo_Response.pb_PresetItem.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Pb_PresetItem {
        fn default() -> &'a Pb_PresetItem {
            <Pb_PresetItem as ::protobuf::Message>::default_instance()
        }
    }

    impl Pb_PresetItem {
        pub fn new() -> Pb_PresetItem {
            ::std::default::Default::default()
        }

        // required string preset_name = 1;

        pub fn preset_name(&self) -> &str {
            match self.preset_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_preset_name(&mut self) {
            self.preset_name = ::std::option::Option::None;
        }

        pub fn has_preset_name(&self) -> bool {
            self.preset_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_preset_name(&mut self, v: ::std::string::String) {
            self.preset_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_preset_name(&mut self) -> &mut ::std::string::String {
            if self.preset_name.is_none() {
                self.preset_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.preset_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_preset_name(&mut self) -> ::std::string::String {
            self.preset_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string date = 2;

        pub fn date(&self) -> &str {
            match self.date.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_date(&mut self) {
            self.date = ::std::option::Option::None;
        }

        pub fn has_date(&self) -> bool {
            self.date.is_some()
        }

        // Param is passed by value, moved
        pub fn set_date(&mut self, v: ::std::string::String) {
            self.date = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_date(&mut self) -> &mut ::std::string::String {
            if self.date.is_none() {
                self.date = ::std::option::Option::Some(::std::string::String::new());
            }
            self.date.as_mut().unwrap()
        }

        // Take field
        pub fn take_date(&mut self) -> ::std::string::String {
            self.date.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string version = 3;

        pub fn version(&self) -> &str {
            match self.version.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_version(&mut self) {
            self.version = ::std::option::Option::None;
        }

        pub fn has_version(&self) -> bool {
            self.version.is_some()
        }

        // Param is passed by value, moved
        pub fn set_version(&mut self, v: ::std::string::String) {
            self.version = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_version(&mut self) -> &mut ::std::string::String {
            if self.version.is_none() {
                self.version = ::std::option::Option::Some(::std::string::String::new());
            }
            self.version.as_mut().unwrap()
        }

        // Take field
        pub fn take_version(&mut self) -> ::std::string::String {
            self.version.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string comment = 4;

        pub fn comment(&self) -> &str {
            match self.comment.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_comment(&mut self) {
            self.comment = ::std::option::Option::None;
        }

        pub fn has_comment(&self) -> bool {
            self.comment.is_some()
        }

        // Param is passed by value, moved
        pub fn set_comment(&mut self, v: ::std::string::String) {
            self.comment = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_comment(&mut self) -> &mut ::std::string::String {
            if self.comment.is_none() {
                self.comment = ::std::option::Option::Some(::std::string::String::new());
            }
            self.comment.as_mut().unwrap()
        }

        // Take field
        pub fn take_comment(&mut self) -> ::std::string::String {
            self.comment.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "preset_name",
                |m: &Pb_PresetItem| { &m.preset_name },
                |m: &mut Pb_PresetItem| { &mut m.preset_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "date",
                |m: &Pb_PresetItem| { &m.date },
                |m: &mut Pb_PresetItem| { &mut m.date },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "version",
                |m: &Pb_PresetItem| { &m.version },
                |m: &mut Pb_PresetItem| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "comment",
                |m: &Pb_PresetItem| { &m.comment },
                |m: &mut Pb_PresetItem| { &mut m.comment },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "feature_types",
                |m: &Pb_PresetItem| { &m.feature_types },
                |m: &mut Pb_PresetItem| { &mut m.feature_types },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "additional_infos",
                |m: &Pb_PresetItem| { &m.additional_infos },
                |m: &mut Pb_PresetItem| { &mut m.additional_infos },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "param_list",
                |m: &Pb_PresetItem| { &m.param_list },
                |m: &mut Pb_PresetItem| { &mut m.param_list },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_PresetItem>(
                "pb_Body_GetPresetInfo_Response.pb_PresetItem",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Pb_PresetItem {
        const NAME: &'static str = "pb_PresetItem";

        fn is_initialized(&self) -> bool {
            if self.preset_name.is_none() {
                return false;
            }
            for v in &self.additional_infos {
                if !v.is_initialized() {
                    return false;
                }
            };
            for v in &self.param_list {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.preset_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.date = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.version = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.comment = ::std::option::Option::Some(is.read_string()?);
                    },
                    42 => {
                        self.feature_types.push(is.read_string()?);
                    },
                    50 => {
                        self.additional_infos.push(is.read_message()?);
                    },
                    58 => {
                        self.param_list.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.preset_name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.date.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.version.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.comment.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            for value in &self.feature_types {
                my_size += ::protobuf::rt::string_size(5, &value);
            };
            for value in &self.additional_infos {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.param_list {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.preset_name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.date.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.version.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.comment.as_ref() {
                os.write_string(4, v)?;
            }
            for v in &self.feature_types {
                os.write_string(5, &v)?;
            };
            for v in &self.additional_infos {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            };
            for v in &self.param_list {
                ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Pb_PresetItem {
            Pb_PresetItem::new()
        }

        fn clear(&mut self) {
            self.preset_name = ::std::option::Option::None;
            self.date = ::std::option::Option::None;
            self.version = ::std::option::Option::None;
            self.comment = ::std::option::Option::None;
            self.feature_types.clear();
            self.additional_infos.clear();
            self.param_list.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Pb_PresetItem {
            static instance: Pb_PresetItem = Pb_PresetItem {
                preset_name: ::std::option::Option::None,
                date: ::std::option::Option::None,
                version: ::std::option::Option::None,
                comment: ::std::option::Option::None,
                feature_types: ::std::vec::Vec::new(),
                additional_infos: ::std::vec::Vec::new(),
                param_list: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Pb_PresetItem {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("pb_Body_GetPresetInfo_Response.pb_PresetItem").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Pb_PresetItem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Pb_PresetItem {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:image_analysis.pb_Body_GetPresetInfo_Response.DirectionEnum)
    pub enum DirectionEnum {
        // @@protoc_insertion_point(enum_value:image_analysis.pb_Body_GetPresetInfo_Response.DirectionEnum.UNDEFINED_DR)
        UNDEFINED_DR = 0,
        // @@protoc_insertion_point(enum_value:image_analysis.pb_Body_GetPresetInfo_Response.DirectionEnum.IN_DR)
        IN_DR = 1,
        // @@protoc_insertion_point(enum_value:image_analysis.pb_Body_GetPresetInfo_Response.DirectionEnum.OUT_DR)
        OUT_DR = 2,
        // @@protoc_insertion_point(enum_value:image_analysis.pb_Body_GetPresetInfo_Response.DirectionEnum.IN_OUT_DR)
        IN_OUT_DR = 3,
    }

    impl ::protobuf::Enum for DirectionEnum {
        const NAME: &'static str = "DirectionEnum";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<DirectionEnum> {
            match value {
                0 => ::std::option::Option::Some(DirectionEnum::UNDEFINED_DR),
                1 => ::std::option::Option::Some(DirectionEnum::IN_DR),
                2 => ::std::option::Option::Some(DirectionEnum::OUT_DR),
                3 => ::std::option::Option::Some(DirectionEnum::IN_OUT_DR),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<DirectionEnum> {
            match str {
                "UNDEFINED_DR" => ::std::option::Option::Some(DirectionEnum::UNDEFINED_DR),
                "IN_DR" => ::std::option::Option::Some(DirectionEnum::IN_DR),
                "OUT_DR" => ::std::option::Option::Some(DirectionEnum::OUT_DR),
                "IN_OUT_DR" => ::std::option::Option::Some(DirectionEnum::IN_OUT_DR),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [DirectionEnum] = &[
            DirectionEnum::UNDEFINED_DR,
            DirectionEnum::IN_DR,
            DirectionEnum::OUT_DR,
            DirectionEnum::IN_OUT_DR,
        ];
    }

    impl ::protobuf::EnumFull for DirectionEnum {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("pb_Body_GetPresetInfo_Response.DirectionEnum").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for DirectionEnum {
        fn default() -> Self {
            DirectionEnum::UNDEFINED_DR
        }
    }

    impl DirectionEnum {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DirectionEnum>("pb_Body_GetPresetInfo_Response.DirectionEnum")
        }
    }
}

///  type will be used in SetConfig, GetConfigParams_Response and SetConfigParams
// @@protoc_insertion_point(message:image_analysis.pb_ConfigParam)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pb_ConfigParam {
    // message fields
    // @@protoc_insertion_point(field:image_analysis.pb_ConfigParam.param_name)
    pub param_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:image_analysis.pb_ConfigParam.datatype)
    pub datatype: ::std::option::Option<::protobuf::EnumOrUnknown<DataTypeEnum>>,
    // @@protoc_insertion_point(field:image_analysis.pb_ConfigParam.val_string)
    pub val_string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:image_analysis.pb_ConfigParam.val_json)
    pub val_json: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:image_analysis.pb_ConfigParam.val_double)
    pub val_double: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:image_analysis.pb_ConfigParam.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pb_ConfigParam {
    fn default() -> &'a Pb_ConfigParam {
        <Pb_ConfigParam as ::protobuf::Message>::default_instance()
    }
}

impl Pb_ConfigParam {
    pub fn new() -> Pb_ConfigParam {
        ::std::default::Default::default()
    }

    // required string param_name = 1;

    pub fn param_name(&self) -> &str {
        match self.param_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_param_name(&mut self) {
        self.param_name = ::std::option::Option::None;
    }

    pub fn has_param_name(&self) -> bool {
        self.param_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_name(&mut self, v: ::std::string::String) {
        self.param_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_param_name(&mut self) -> &mut ::std::string::String {
        if self.param_name.is_none() {
            self.param_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.param_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_param_name(&mut self) -> ::std::string::String {
        self.param_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required .image_analysis.DataTypeEnum datatype = 2;

    pub fn datatype(&self) -> DataTypeEnum {
        match self.datatype {
            Some(e) => e.enum_value_or(DataTypeEnum::UNDEFINED_DT),
            None => DataTypeEnum::UNDEFINED_DT,
        }
    }

    pub fn clear_datatype(&mut self) {
        self.datatype = ::std::option::Option::None;
    }

    pub fn has_datatype(&self) -> bool {
        self.datatype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_datatype(&mut self, v: DataTypeEnum) {
        self.datatype = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string val_string = 3;

    pub fn val_string(&self) -> &str {
        match self.val_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_val_string(&mut self) {
        self.val_string = ::std::option::Option::None;
    }

    pub fn has_val_string(&self) -> bool {
        self.val_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_val_string(&mut self, v: ::std::string::String) {
        self.val_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_val_string(&mut self) -> &mut ::std::string::String {
        if self.val_string.is_none() {
            self.val_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.val_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_val_string(&mut self) -> ::std::string::String {
        self.val_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string val_json = 4;

    pub fn val_json(&self) -> &str {
        match self.val_json.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_val_json(&mut self) {
        self.val_json = ::std::option::Option::None;
    }

    pub fn has_val_json(&self) -> bool {
        self.val_json.is_some()
    }

    // Param is passed by value, moved
    pub fn set_val_json(&mut self, v: ::std::string::String) {
        self.val_json = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_val_json(&mut self) -> &mut ::std::string::String {
        if self.val_json.is_none() {
            self.val_json = ::std::option::Option::Some(::std::string::String::new());
        }
        self.val_json.as_mut().unwrap()
    }

    // Take field
    pub fn take_val_json(&mut self) -> ::std::string::String {
        self.val_json.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional double val_double = 5;

    pub fn val_double(&self) -> f64 {
        self.val_double.unwrap_or(-1e99f64)
    }

    pub fn clear_val_double(&mut self) {
        self.val_double = ::std::option::Option::None;
    }

    pub fn has_val_double(&self) -> bool {
        self.val_double.is_some()
    }

    // Param is passed by value, moved
    pub fn set_val_double(&mut self, v: f64) {
        self.val_double = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "param_name",
            |m: &Pb_ConfigParam| { &m.param_name },
            |m: &mut Pb_ConfigParam| { &mut m.param_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "datatype",
            |m: &Pb_ConfigParam| { &m.datatype },
            |m: &mut Pb_ConfigParam| { &mut m.datatype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "val_string",
            |m: &Pb_ConfigParam| { &m.val_string },
            |m: &mut Pb_ConfigParam| { &mut m.val_string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "val_json",
            |m: &Pb_ConfigParam| { &m.val_json },
            |m: &mut Pb_ConfigParam| { &mut m.val_json },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "val_double",
            |m: &Pb_ConfigParam| { &m.val_double },
            |m: &mut Pb_ConfigParam| { &mut m.val_double },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_ConfigParam>(
            "pb_ConfigParam",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pb_ConfigParam {
    const NAME: &'static str = "pb_ConfigParam";

    fn is_initialized(&self) -> bool {
        if self.param_name.is_none() {
            return false;
        }
        if self.datatype.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.param_name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.datatype = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.val_string = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.val_json = ::std::option::Option::Some(is.read_string()?);
                },
                41 => {
                    self.val_double = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.param_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.datatype {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.val_string.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.val_json.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.val_double {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.param_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.datatype {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.val_string.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.val_json.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.val_double {
            os.write_double(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pb_ConfigParam {
        Pb_ConfigParam::new()
    }

    fn clear(&mut self) {
        self.param_name = ::std::option::Option::None;
        self.datatype = ::std::option::Option::None;
        self.val_string = ::std::option::Option::None;
        self.val_json = ::std::option::Option::None;
        self.val_double = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pb_ConfigParam {
        static instance: Pb_ConfigParam = Pb_ConfigParam {
            param_name: ::std::option::Option::None,
            datatype: ::std::option::Option::None,
            val_string: ::std::option::Option::None,
            val_json: ::std::option::Option::None,
            val_double: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pb_ConfigParam {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("pb_ConfigParam").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pb_ConfigParam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pb_ConfigParam {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:image_analysis.pb_Body_SetConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pb_Body_SetConfig {
    // message fields
    // @@protoc_insertion_point(field:image_analysis.pb_Body_SetConfig.configset_name)
    pub configset_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:image_analysis.pb_Body_SetConfig.cell_info)
    pub cell_info: ::protobuf::MessageField<pb_body_set_config::Pb_CellInfo>,
    // @@protoc_insertion_point(field:image_analysis.pb_Body_SetConfig.preset_name)
    pub preset_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:image_analysis.pb_Body_SetConfig.config_params)
    pub config_params: ::std::vec::Vec<Pb_ConfigParam>,
    // special fields
    // @@protoc_insertion_point(special_field:image_analysis.pb_Body_SetConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pb_Body_SetConfig {
    fn default() -> &'a Pb_Body_SetConfig {
        <Pb_Body_SetConfig as ::protobuf::Message>::default_instance()
    }
}

impl Pb_Body_SetConfig {
    pub fn new() -> Pb_Body_SetConfig {
        ::std::default::Default::default()
    }

    // required string configset_name = 1;

    pub fn configset_name(&self) -> &str {
        match self.configset_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_configset_name(&mut self) {
        self.configset_name = ::std::option::Option::None;
    }

    pub fn has_configset_name(&self) -> bool {
        self.configset_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configset_name(&mut self, v: ::std::string::String) {
        self.configset_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configset_name(&mut self) -> &mut ::std::string::String {
        if self.configset_name.is_none() {
            self.configset_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.configset_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_configset_name(&mut self) -> ::std::string::String {
        self.configset_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string preset_name = 3;

    pub fn preset_name(&self) -> &str {
        match self.preset_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_preset_name(&mut self) {
        self.preset_name = ::std::option::Option::None;
    }

    pub fn has_preset_name(&self) -> bool {
        self.preset_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preset_name(&mut self, v: ::std::string::String) {
        self.preset_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preset_name(&mut self) -> &mut ::std::string::String {
        if self.preset_name.is_none() {
            self.preset_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.preset_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_preset_name(&mut self) -> ::std::string::String {
        self.preset_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "configset_name",
            |m: &Pb_Body_SetConfig| { &m.configset_name },
            |m: &mut Pb_Body_SetConfig| { &mut m.configset_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, pb_body_set_config::Pb_CellInfo>(
            "cell_info",
            |m: &Pb_Body_SetConfig| { &m.cell_info },
            |m: &mut Pb_Body_SetConfig| { &mut m.cell_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "preset_name",
            |m: &Pb_Body_SetConfig| { &m.preset_name },
            |m: &mut Pb_Body_SetConfig| { &mut m.preset_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "config_params",
            |m: &Pb_Body_SetConfig| { &m.config_params },
            |m: &mut Pb_Body_SetConfig| { &mut m.config_params },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_Body_SetConfig>(
            "pb_Body_SetConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pb_Body_SetConfig {
    const NAME: &'static str = "pb_Body_SetConfig";

    fn is_initialized(&self) -> bool {
        if self.configset_name.is_none() {
            return false;
        }
        for v in &self.cell_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.config_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.configset_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.cell_info)?;
                },
                26 => {
                    self.preset_name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.config_params.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.configset_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.cell_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.preset_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.config_params {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.configset_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.cell_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.preset_name.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.config_params {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pb_Body_SetConfig {
        Pb_Body_SetConfig::new()
    }

    fn clear(&mut self) {
        self.configset_name = ::std::option::Option::None;
        self.cell_info.clear();
        self.preset_name = ::std::option::Option::None;
        self.config_params.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pb_Body_SetConfig {
        static instance: Pb_Body_SetConfig = Pb_Body_SetConfig {
            configset_name: ::std::option::Option::None,
            cell_info: ::protobuf::MessageField::none(),
            preset_name: ::std::option::Option::None,
            config_params: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pb_Body_SetConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("pb_Body_SetConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pb_Body_SetConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pb_Body_SetConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `pb_Body_SetConfig`
pub mod pb_body_set_config {
    // @@protoc_insertion_point(message:image_analysis.pb_Body_SetConfig.pb_CellInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Pb_CellInfo {
        // message fields
        // @@protoc_insertion_point(field:image_analysis.pb_Body_SetConfig.pb_CellInfo.busbar_count)
        pub busbar_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_SetConfig.pb_CellInfo.busbar_orientation)
        pub busbar_orientation: ::std::option::Option<::protobuf::EnumOrUnknown<pb_cell_info::Pb_BusbarOrientationEnum>>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_SetConfig.pb_CellInfo.crystal_type)
        pub crystal_type: ::std::option::Option<::protobuf::EnumOrUnknown<pb_cell_info::Pb_CrystalTypeEnum>>,
        // special fields
        // @@protoc_insertion_point(special_field:image_analysis.pb_Body_SetConfig.pb_CellInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Pb_CellInfo {
        fn default() -> &'a Pb_CellInfo {
            <Pb_CellInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl Pb_CellInfo {
        pub fn new() -> Pb_CellInfo {
            ::std::default::Default::default()
        }

        // optional int32 busbar_count = 1;

        pub fn busbar_count(&self) -> i32 {
            self.busbar_count.unwrap_or(-1i32)
        }

        pub fn clear_busbar_count(&mut self) {
            self.busbar_count = ::std::option::Option::None;
        }

        pub fn has_busbar_count(&self) -> bool {
            self.busbar_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_busbar_count(&mut self, v: i32) {
            self.busbar_count = ::std::option::Option::Some(v);
        }

        // optional .image_analysis.pb_Body_SetConfig.pb_CellInfo.pb_BusbarOrientationEnum busbar_orientation = 2;

        pub fn busbar_orientation(&self) -> pb_cell_info::Pb_BusbarOrientationEnum {
            match self.busbar_orientation {
                Some(e) => e.enum_value_or(pb_cell_info::Pb_BusbarOrientationEnum::UNDEFINED_BO),
                None => pb_cell_info::Pb_BusbarOrientationEnum::UNDEFINED_BO,
            }
        }

        pub fn clear_busbar_orientation(&mut self) {
            self.busbar_orientation = ::std::option::Option::None;
        }

        pub fn has_busbar_orientation(&self) -> bool {
            self.busbar_orientation.is_some()
        }

        // Param is passed by value, moved
        pub fn set_busbar_orientation(&mut self, v: pb_cell_info::Pb_BusbarOrientationEnum) {
            self.busbar_orientation = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional .image_analysis.pb_Body_SetConfig.pb_CellInfo.pb_CrystalTypeEnum crystal_type = 3;

        pub fn crystal_type(&self) -> pb_cell_info::Pb_CrystalTypeEnum {
            match self.crystal_type {
                Some(e) => e.enum_value_or(pb_cell_info::Pb_CrystalTypeEnum::UNDEFINED_CT),
                None => pb_cell_info::Pb_CrystalTypeEnum::UNDEFINED_CT,
            }
        }

        pub fn clear_crystal_type(&mut self) {
            self.crystal_type = ::std::option::Option::None;
        }

        pub fn has_crystal_type(&self) -> bool {
            self.crystal_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_crystal_type(&mut self, v: pb_cell_info::Pb_CrystalTypeEnum) {
            self.crystal_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "busbar_count",
                |m: &Pb_CellInfo| { &m.busbar_count },
                |m: &mut Pb_CellInfo| { &mut m.busbar_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "busbar_orientation",
                |m: &Pb_CellInfo| { &m.busbar_orientation },
                |m: &mut Pb_CellInfo| { &mut m.busbar_orientation },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "crystal_type",
                |m: &Pb_CellInfo| { &m.crystal_type },
                |m: &mut Pb_CellInfo| { &mut m.crystal_type },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_CellInfo>(
                "pb_Body_SetConfig.pb_CellInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Pb_CellInfo {
        const NAME: &'static str = "pb_CellInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.busbar_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.busbar_orientation = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    24 => {
                        self.crystal_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.busbar_count {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.busbar_orientation {
                my_size += ::protobuf::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.crystal_type {
                my_size += ::protobuf::rt::int32_size(3, v.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.busbar_count {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.busbar_orientation {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.crystal_type {
                os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Pb_CellInfo {
            Pb_CellInfo::new()
        }

        fn clear(&mut self) {
            self.busbar_count = ::std::option::Option::None;
            self.busbar_orientation = ::std::option::Option::None;
            self.crystal_type = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Pb_CellInfo {
            static instance: Pb_CellInfo = Pb_CellInfo {
                busbar_count: ::std::option::Option::None,
                busbar_orientation: ::std::option::Option::None,
                crystal_type: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Pb_CellInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("pb_Body_SetConfig.pb_CellInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Pb_CellInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Pb_CellInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `pb_CellInfo`
    pub mod pb_cell_info {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:image_analysis.pb_Body_SetConfig.pb_CellInfo.pb_BusbarOrientationEnum)
        pub enum Pb_BusbarOrientationEnum {
            // @@protoc_insertion_point(enum_value:image_analysis.pb_Body_SetConfig.pb_CellInfo.pb_BusbarOrientationEnum.UNDEFINED_BO)
            UNDEFINED_BO = 0,
            // @@protoc_insertion_point(enum_value:image_analysis.pb_Body_SetConfig.pb_CellInfo.pb_BusbarOrientationEnum.HORIZONTAL_BO)
            HORIZONTAL_BO = 1,
            // @@protoc_insertion_point(enum_value:image_analysis.pb_Body_SetConfig.pb_CellInfo.pb_BusbarOrientationEnum.VERTICAL_BO)
            VERTICAL_BO = 2,
        }

        impl ::protobuf::Enum for Pb_BusbarOrientationEnum {
            const NAME: &'static str = "pb_BusbarOrientationEnum";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<Pb_BusbarOrientationEnum> {
                match value {
                    0 => ::std::option::Option::Some(Pb_BusbarOrientationEnum::UNDEFINED_BO),
                    1 => ::std::option::Option::Some(Pb_BusbarOrientationEnum::HORIZONTAL_BO),
                    2 => ::std::option::Option::Some(Pb_BusbarOrientationEnum::VERTICAL_BO),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<Pb_BusbarOrientationEnum> {
                match str {
                    "UNDEFINED_BO" => ::std::option::Option::Some(Pb_BusbarOrientationEnum::UNDEFINED_BO),
                    "HORIZONTAL_BO" => ::std::option::Option::Some(Pb_BusbarOrientationEnum::HORIZONTAL_BO),
                    "VERTICAL_BO" => ::std::option::Option::Some(Pb_BusbarOrientationEnum::VERTICAL_BO),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [Pb_BusbarOrientationEnum] = &[
                Pb_BusbarOrientationEnum::UNDEFINED_BO,
                Pb_BusbarOrientationEnum::HORIZONTAL_BO,
                Pb_BusbarOrientationEnum::VERTICAL_BO,
            ];
        }

        impl ::protobuf::EnumFull for Pb_BusbarOrientationEnum {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("pb_Body_SetConfig.pb_CellInfo.pb_BusbarOrientationEnum").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for Pb_BusbarOrientationEnum {
            fn default() -> Self {
                Pb_BusbarOrientationEnum::UNDEFINED_BO
            }
        }

        impl Pb_BusbarOrientationEnum {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Pb_BusbarOrientationEnum>("pb_Body_SetConfig.pb_CellInfo.pb_BusbarOrientationEnum")
            }
        }

        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:image_analysis.pb_Body_SetConfig.pb_CellInfo.pb_CrystalTypeEnum)
        pub enum Pb_CrystalTypeEnum {
            // @@protoc_insertion_point(enum_value:image_analysis.pb_Body_SetConfig.pb_CellInfo.pb_CrystalTypeEnum.UNDEFINED_CT)
            UNDEFINED_CT = 0,
            // @@protoc_insertion_point(enum_value:image_analysis.pb_Body_SetConfig.pb_CellInfo.pb_CrystalTypeEnum.MONO_CT)
            MONO_CT = 1,
            // @@protoc_insertion_point(enum_value:image_analysis.pb_Body_SetConfig.pb_CellInfo.pb_CrystalTypeEnum.POLY_CT)
            POLY_CT = 2,
        }

        impl ::protobuf::Enum for Pb_CrystalTypeEnum {
            const NAME: &'static str = "pb_CrystalTypeEnum";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<Pb_CrystalTypeEnum> {
                match value {
                    0 => ::std::option::Option::Some(Pb_CrystalTypeEnum::UNDEFINED_CT),
                    1 => ::std::option::Option::Some(Pb_CrystalTypeEnum::MONO_CT),
                    2 => ::std::option::Option::Some(Pb_CrystalTypeEnum::POLY_CT),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<Pb_CrystalTypeEnum> {
                match str {
                    "UNDEFINED_CT" => ::std::option::Option::Some(Pb_CrystalTypeEnum::UNDEFINED_CT),
                    "MONO_CT" => ::std::option::Option::Some(Pb_CrystalTypeEnum::MONO_CT),
                    "POLY_CT" => ::std::option::Option::Some(Pb_CrystalTypeEnum::POLY_CT),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [Pb_CrystalTypeEnum] = &[
                Pb_CrystalTypeEnum::UNDEFINED_CT,
                Pb_CrystalTypeEnum::MONO_CT,
                Pb_CrystalTypeEnum::POLY_CT,
            ];
        }

        impl ::protobuf::EnumFull for Pb_CrystalTypeEnum {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("pb_Body_SetConfig.pb_CellInfo.pb_CrystalTypeEnum").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for Pb_CrystalTypeEnum {
            fn default() -> Self {
                Pb_CrystalTypeEnum::UNDEFINED_CT
            }
        }

        impl Pb_CrystalTypeEnum {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Pb_CrystalTypeEnum>("pb_Body_SetConfig.pb_CellInfo.pb_CrystalTypeEnum")
            }
        }
    }
}

// @@protoc_insertion_point(message:image_analysis.pb_Body_RemoveConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pb_Body_RemoveConfig {
    // message fields
    // @@protoc_insertion_point(field:image_analysis.pb_Body_RemoveConfig.configset_name)
    pub configset_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:image_analysis.pb_Body_RemoveConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pb_Body_RemoveConfig {
    fn default() -> &'a Pb_Body_RemoveConfig {
        <Pb_Body_RemoveConfig as ::protobuf::Message>::default_instance()
    }
}

impl Pb_Body_RemoveConfig {
    pub fn new() -> Pb_Body_RemoveConfig {
        ::std::default::Default::default()
    }

    // required string configset_name = 1;

    pub fn configset_name(&self) -> &str {
        match self.configset_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_configset_name(&mut self) {
        self.configset_name = ::std::option::Option::None;
    }

    pub fn has_configset_name(&self) -> bool {
        self.configset_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configset_name(&mut self, v: ::std::string::String) {
        self.configset_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configset_name(&mut self) -> &mut ::std::string::String {
        if self.configset_name.is_none() {
            self.configset_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.configset_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_configset_name(&mut self) -> ::std::string::String {
        self.configset_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "configset_name",
            |m: &Pb_Body_RemoveConfig| { &m.configset_name },
            |m: &mut Pb_Body_RemoveConfig| { &mut m.configset_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_Body_RemoveConfig>(
            "pb_Body_RemoveConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pb_Body_RemoveConfig {
    const NAME: &'static str = "pb_Body_RemoveConfig";

    fn is_initialized(&self) -> bool {
        if self.configset_name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.configset_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.configset_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.configset_name.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pb_Body_RemoveConfig {
        Pb_Body_RemoveConfig::new()
    }

    fn clear(&mut self) {
        self.configset_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pb_Body_RemoveConfig {
        static instance: Pb_Body_RemoveConfig = Pb_Body_RemoveConfig {
            configset_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pb_Body_RemoveConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("pb_Body_RemoveConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pb_Body_RemoveConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pb_Body_RemoveConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:image_analysis.pb_Body_GetConfigParams)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pb_Body_GetConfigParams {
    // message fields
    // @@protoc_insertion_point(field:image_analysis.pb_Body_GetConfigParams.configset_name)
    pub configset_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:image_analysis.pb_Body_GetConfigParams.param_name_list)
    pub param_name_list: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:image_analysis.pb_Body_GetConfigParams.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pb_Body_GetConfigParams {
    fn default() -> &'a Pb_Body_GetConfigParams {
        <Pb_Body_GetConfigParams as ::protobuf::Message>::default_instance()
    }
}

impl Pb_Body_GetConfigParams {
    pub fn new() -> Pb_Body_GetConfigParams {
        ::std::default::Default::default()
    }

    // required string configset_name = 1;

    pub fn configset_name(&self) -> &str {
        match self.configset_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_configset_name(&mut self) {
        self.configset_name = ::std::option::Option::None;
    }

    pub fn has_configset_name(&self) -> bool {
        self.configset_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configset_name(&mut self, v: ::std::string::String) {
        self.configset_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configset_name(&mut self) -> &mut ::std::string::String {
        if self.configset_name.is_none() {
            self.configset_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.configset_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_configset_name(&mut self) -> ::std::string::String {
        self.configset_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "configset_name",
            |m: &Pb_Body_GetConfigParams| { &m.configset_name },
            |m: &mut Pb_Body_GetConfigParams| { &mut m.configset_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "param_name_list",
            |m: &Pb_Body_GetConfigParams| { &m.param_name_list },
            |m: &mut Pb_Body_GetConfigParams| { &mut m.param_name_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_Body_GetConfigParams>(
            "pb_Body_GetConfigParams",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pb_Body_GetConfigParams {
    const NAME: &'static str = "pb_Body_GetConfigParams";

    fn is_initialized(&self) -> bool {
        if self.configset_name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.configset_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.param_name_list.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.configset_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.param_name_list {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.configset_name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.param_name_list {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pb_Body_GetConfigParams {
        Pb_Body_GetConfigParams::new()
    }

    fn clear(&mut self) {
        self.configset_name = ::std::option::Option::None;
        self.param_name_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pb_Body_GetConfigParams {
        static instance: Pb_Body_GetConfigParams = Pb_Body_GetConfigParams {
            configset_name: ::std::option::Option::None,
            param_name_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pb_Body_GetConfigParams {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("pb_Body_GetConfigParams").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pb_Body_GetConfigParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pb_Body_GetConfigParams {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:image_analysis.pb_Body_GetConfigParams_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pb_Body_GetConfigParams_Response {
    // message fields
    // @@protoc_insertion_point(field:image_analysis.pb_Body_GetConfigParams_Response.configset_name)
    pub configset_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:image_analysis.pb_Body_GetConfigParams_Response.config_params)
    pub config_params: ::std::vec::Vec<Pb_ConfigParam>,
    // special fields
    // @@protoc_insertion_point(special_field:image_analysis.pb_Body_GetConfigParams_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pb_Body_GetConfigParams_Response {
    fn default() -> &'a Pb_Body_GetConfigParams_Response {
        <Pb_Body_GetConfigParams_Response as ::protobuf::Message>::default_instance()
    }
}

impl Pb_Body_GetConfigParams_Response {
    pub fn new() -> Pb_Body_GetConfigParams_Response {
        ::std::default::Default::default()
    }

    // required string configset_name = 1;

    pub fn configset_name(&self) -> &str {
        match self.configset_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_configset_name(&mut self) {
        self.configset_name = ::std::option::Option::None;
    }

    pub fn has_configset_name(&self) -> bool {
        self.configset_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configset_name(&mut self, v: ::std::string::String) {
        self.configset_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configset_name(&mut self) -> &mut ::std::string::String {
        if self.configset_name.is_none() {
            self.configset_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.configset_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_configset_name(&mut self) -> ::std::string::String {
        self.configset_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "configset_name",
            |m: &Pb_Body_GetConfigParams_Response| { &m.configset_name },
            |m: &mut Pb_Body_GetConfigParams_Response| { &mut m.configset_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "config_params",
            |m: &Pb_Body_GetConfigParams_Response| { &m.config_params },
            |m: &mut Pb_Body_GetConfigParams_Response| { &mut m.config_params },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_Body_GetConfigParams_Response>(
            "pb_Body_GetConfigParams_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pb_Body_GetConfigParams_Response {
    const NAME: &'static str = "pb_Body_GetConfigParams_Response";

    fn is_initialized(&self) -> bool {
        if self.configset_name.is_none() {
            return false;
        }
        for v in &self.config_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.configset_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.config_params.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.configset_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.config_params {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.configset_name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.config_params {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pb_Body_GetConfigParams_Response {
        Pb_Body_GetConfigParams_Response::new()
    }

    fn clear(&mut self) {
        self.configset_name = ::std::option::Option::None;
        self.config_params.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pb_Body_GetConfigParams_Response {
        static instance: Pb_Body_GetConfigParams_Response = Pb_Body_GetConfigParams_Response {
            configset_name: ::std::option::Option::None,
            config_params: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pb_Body_GetConfigParams_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("pb_Body_GetConfigParams_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pb_Body_GetConfigParams_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pb_Body_GetConfigParams_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:image_analysis.pb_Body_SetConfigParams)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pb_Body_SetConfigParams {
    // message fields
    // @@protoc_insertion_point(field:image_analysis.pb_Body_SetConfigParams.configset_name)
    pub configset_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:image_analysis.pb_Body_SetConfigParams.config_params)
    pub config_params: ::std::vec::Vec<Pb_ConfigParam>,
    // special fields
    // @@protoc_insertion_point(special_field:image_analysis.pb_Body_SetConfigParams.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pb_Body_SetConfigParams {
    fn default() -> &'a Pb_Body_SetConfigParams {
        <Pb_Body_SetConfigParams as ::protobuf::Message>::default_instance()
    }
}

impl Pb_Body_SetConfigParams {
    pub fn new() -> Pb_Body_SetConfigParams {
        ::std::default::Default::default()
    }

    // required string configset_name = 1;

    pub fn configset_name(&self) -> &str {
        match self.configset_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_configset_name(&mut self) {
        self.configset_name = ::std::option::Option::None;
    }

    pub fn has_configset_name(&self) -> bool {
        self.configset_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configset_name(&mut self, v: ::std::string::String) {
        self.configset_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configset_name(&mut self) -> &mut ::std::string::String {
        if self.configset_name.is_none() {
            self.configset_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.configset_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_configset_name(&mut self) -> ::std::string::String {
        self.configset_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "configset_name",
            |m: &Pb_Body_SetConfigParams| { &m.configset_name },
            |m: &mut Pb_Body_SetConfigParams| { &mut m.configset_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "config_params",
            |m: &Pb_Body_SetConfigParams| { &m.config_params },
            |m: &mut Pb_Body_SetConfigParams| { &mut m.config_params },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_Body_SetConfigParams>(
            "pb_Body_SetConfigParams",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pb_Body_SetConfigParams {
    const NAME: &'static str = "pb_Body_SetConfigParams";

    fn is_initialized(&self) -> bool {
        if self.configset_name.is_none() {
            return false;
        }
        for v in &self.config_params {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.configset_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.config_params.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.configset_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.config_params {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.configset_name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.config_params {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pb_Body_SetConfigParams {
        Pb_Body_SetConfigParams::new()
    }

    fn clear(&mut self) {
        self.configset_name = ::std::option::Option::None;
        self.config_params.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pb_Body_SetConfigParams {
        static instance: Pb_Body_SetConfigParams = Pb_Body_SetConfigParams {
            configset_name: ::std::option::Option::None,
            config_params: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pb_Body_SetConfigParams {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("pb_Body_SetConfigParams").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pb_Body_SetConfigParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pb_Body_SetConfigParams {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:image_analysis.pb_ImageData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pb_ImageData {
    // message fields
    // @@protoc_insertion_point(field:image_analysis.pb_ImageData.image_file_format)
    pub image_file_format: ::std::option::Option<::protobuf::EnumOrUnknown<pb_image_data::Pb_FileFormatEnum>>,
    // @@protoc_insertion_point(field:image_analysis.pb_ImageData.image_data)
    pub image_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:image_analysis.pb_ImageData.width)
    pub width: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:image_analysis.pb_ImageData.height)
    pub height: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:image_analysis.pb_ImageData.bitdepth)
    pub bitdepth: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:image_analysis.pb_ImageData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pb_ImageData {
    fn default() -> &'a Pb_ImageData {
        <Pb_ImageData as ::protobuf::Message>::default_instance()
    }
}

impl Pb_ImageData {
    pub fn new() -> Pb_ImageData {
        ::std::default::Default::default()
    }

    // required .image_analysis.pb_ImageData.pb_FileFormatEnum image_file_format = 1;

    pub fn image_file_format(&self) -> pb_image_data::Pb_FileFormatEnum {
        match self.image_file_format {
            Some(e) => e.enum_value_or(pb_image_data::Pb_FileFormatEnum::UNDEFINED_FF),
            None => pb_image_data::Pb_FileFormatEnum::UNDEFINED_FF,
        }
    }

    pub fn clear_image_file_format(&mut self) {
        self.image_file_format = ::std::option::Option::None;
    }

    pub fn has_image_file_format(&self) -> bool {
        self.image_file_format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_file_format(&mut self, v: pb_image_data::Pb_FileFormatEnum) {
        self.image_file_format = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bytes image_data = 2;

    pub fn image_data(&self) -> &[u8] {
        match self.image_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_image_data(&mut self) {
        self.image_data = ::std::option::Option::None;
    }

    pub fn has_image_data(&self) -> bool {
        self.image_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.image_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.image_data.is_none() {
            self.image_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.image_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_image_data(&mut self) -> ::std::vec::Vec<u8> {
        self.image_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 width = 3;

    pub fn width(&self) -> i32 {
        self.width.unwrap_or(-1i32)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional int32 height = 4;

    pub fn height(&self) -> i32 {
        self.height.unwrap_or(-1i32)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional int32 bitdepth = 5;

    pub fn bitdepth(&self) -> i32 {
        self.bitdepth.unwrap_or(-1i32)
    }

    pub fn clear_bitdepth(&mut self) {
        self.bitdepth = ::std::option::Option::None;
    }

    pub fn has_bitdepth(&self) -> bool {
        self.bitdepth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bitdepth(&mut self, v: i32) {
        self.bitdepth = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "image_file_format",
            |m: &Pb_ImageData| { &m.image_file_format },
            |m: &mut Pb_ImageData| { &mut m.image_file_format },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "image_data",
            |m: &Pb_ImageData| { &m.image_data },
            |m: &mut Pb_ImageData| { &mut m.image_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &Pb_ImageData| { &m.width },
            |m: &mut Pb_ImageData| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &Pb_ImageData| { &m.height },
            |m: &mut Pb_ImageData| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bitdepth",
            |m: &Pb_ImageData| { &m.bitdepth },
            |m: &mut Pb_ImageData| { &mut m.bitdepth },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_ImageData>(
            "pb_ImageData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pb_ImageData {
    const NAME: &'static str = "pb_ImageData";

    fn is_initialized(&self) -> bool {
        if self.image_file_format.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.image_file_format = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.image_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.width = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.height = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.bitdepth = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.image_file_format {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.image_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.bitdepth {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.image_file_format {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.image_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.width {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.bitdepth {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pb_ImageData {
        Pb_ImageData::new()
    }

    fn clear(&mut self) {
        self.image_file_format = ::std::option::Option::None;
        self.image_data = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.bitdepth = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pb_ImageData {
        static instance: Pb_ImageData = Pb_ImageData {
            image_file_format: ::std::option::Option::None,
            image_data: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            bitdepth: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pb_ImageData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("pb_ImageData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pb_ImageData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pb_ImageData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `pb_ImageData`
pub mod pb_image_data {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:image_analysis.pb_ImageData.pb_FileFormatEnum)
    pub enum Pb_FileFormatEnum {
        // @@protoc_insertion_point(enum_value:image_analysis.pb_ImageData.pb_FileFormatEnum.UNDEFINED_FF)
        UNDEFINED_FF = 0,
        // @@protoc_insertion_point(enum_value:image_analysis.pb_ImageData.pb_FileFormatEnum.PNG_FF)
        PNG_FF = 1,
        // @@protoc_insertion_point(enum_value:image_analysis.pb_ImageData.pb_FileFormatEnum.JPG_FF)
        JPG_FF = 2,
        // @@protoc_insertion_point(enum_value:image_analysis.pb_ImageData.pb_FileFormatEnum.RAW_FF)
        RAW_FF = 3,
        // @@protoc_insertion_point(enum_value:image_analysis.pb_ImageData.pb_FileFormatEnum.BYTES)
        BYTES = 100,
        // @@protoc_insertion_point(enum_value:image_analysis.pb_ImageData.pb_FileFormatEnum.TIF_FF)
        TIF_FF = 101,
    }

    impl ::protobuf::Enum for Pb_FileFormatEnum {
        const NAME: &'static str = "pb_FileFormatEnum";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Pb_FileFormatEnum> {
            match value {
                0 => ::std::option::Option::Some(Pb_FileFormatEnum::UNDEFINED_FF),
                1 => ::std::option::Option::Some(Pb_FileFormatEnum::PNG_FF),
                2 => ::std::option::Option::Some(Pb_FileFormatEnum::JPG_FF),
                3 => ::std::option::Option::Some(Pb_FileFormatEnum::RAW_FF),
                100 => ::std::option::Option::Some(Pb_FileFormatEnum::BYTES),
                101 => ::std::option::Option::Some(Pb_FileFormatEnum::TIF_FF),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Pb_FileFormatEnum> {
            match str {
                "UNDEFINED_FF" => ::std::option::Option::Some(Pb_FileFormatEnum::UNDEFINED_FF),
                "PNG_FF" => ::std::option::Option::Some(Pb_FileFormatEnum::PNG_FF),
                "JPG_FF" => ::std::option::Option::Some(Pb_FileFormatEnum::JPG_FF),
                "RAW_FF" => ::std::option::Option::Some(Pb_FileFormatEnum::RAW_FF),
                "BYTES" => ::std::option::Option::Some(Pb_FileFormatEnum::BYTES),
                "TIF_FF" => ::std::option::Option::Some(Pb_FileFormatEnum::TIF_FF),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Pb_FileFormatEnum] = &[
            Pb_FileFormatEnum::UNDEFINED_FF,
            Pb_FileFormatEnum::PNG_FF,
            Pb_FileFormatEnum::JPG_FF,
            Pb_FileFormatEnum::RAW_FF,
            Pb_FileFormatEnum::BYTES,
            Pb_FileFormatEnum::TIF_FF,
        ];
    }

    impl ::protobuf::EnumFull for Pb_FileFormatEnum {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("pb_ImageData.pb_FileFormatEnum").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = match self {
                Pb_FileFormatEnum::UNDEFINED_FF => 0,
                Pb_FileFormatEnum::PNG_FF => 1,
                Pb_FileFormatEnum::JPG_FF => 2,
                Pb_FileFormatEnum::RAW_FF => 3,
                Pb_FileFormatEnum::BYTES => 4,
                Pb_FileFormatEnum::TIF_FF => 5,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Pb_FileFormatEnum {
        fn default() -> Self {
            Pb_FileFormatEnum::UNDEFINED_FF
        }
    }

    impl Pb_FileFormatEnum {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Pb_FileFormatEnum>("pb_ImageData.pb_FileFormatEnum")
        }
    }
}

// @@protoc_insertion_point(message:image_analysis.pb_MultiImages)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pb_MultiImages {
    // message fields
    // @@protoc_insertion_point(field:image_analysis.pb_MultiImages.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:image_analysis.pb_MultiImages.image)
    pub image: ::protobuf::MessageField<Pb_ImageData>,
    // special fields
    // @@protoc_insertion_point(special_field:image_analysis.pb_MultiImages.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pb_MultiImages {
    fn default() -> &'a Pb_MultiImages {
        <Pb_MultiImages as ::protobuf::Message>::default_instance()
    }
}

impl Pb_MultiImages {
    pub fn new() -> Pb_MultiImages {
        ::std::default::Default::default()
    }

    // required string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &Pb_MultiImages| { &m.name },
            |m: &mut Pb_MultiImages| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pb_ImageData>(
            "image",
            |m: &Pb_MultiImages| { &m.image },
            |m: &mut Pb_MultiImages| { &mut m.image },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_MultiImages>(
            "pb_MultiImages",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pb_MultiImages {
    const NAME: &'static str = "pb_MultiImages";

    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.image)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.image.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pb_MultiImages {
        Pb_MultiImages::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.image.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pb_MultiImages {
        static instance: Pb_MultiImages = Pb_MultiImages {
            name: ::std::option::Option::None,
            image: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pb_MultiImages {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("pb_MultiImages").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pb_MultiImages {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pb_MultiImages {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:image_analysis.pb_AdditionalData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pb_AdditionalData {
    // message fields
    // @@protoc_insertion_point(field:image_analysis.pb_AdditionalData.numeric_values)
    pub numeric_values: ::std::vec::Vec<pb_additional_data::Pb_NumericValue>,
    // @@protoc_insertion_point(field:image_analysis.pb_AdditionalData.string_values)
    pub string_values: ::std::vec::Vec<pb_additional_data::Pb_StringValue>,
    // special fields
    // @@protoc_insertion_point(special_field:image_analysis.pb_AdditionalData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pb_AdditionalData {
    fn default() -> &'a Pb_AdditionalData {
        <Pb_AdditionalData as ::protobuf::Message>::default_instance()
    }
}

impl Pb_AdditionalData {
    pub fn new() -> Pb_AdditionalData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "numeric_values",
            |m: &Pb_AdditionalData| { &m.numeric_values },
            |m: &mut Pb_AdditionalData| { &mut m.numeric_values },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "string_values",
            |m: &Pb_AdditionalData| { &m.string_values },
            |m: &mut Pb_AdditionalData| { &mut m.string_values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_AdditionalData>(
            "pb_AdditionalData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pb_AdditionalData {
    const NAME: &'static str = "pb_AdditionalData";

    fn is_initialized(&self) -> bool {
        for v in &self.numeric_values {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.string_values {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.numeric_values.push(is.read_message()?);
                },
                18 => {
                    self.string_values.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.numeric_values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.string_values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.numeric_values {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.string_values {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pb_AdditionalData {
        Pb_AdditionalData::new()
    }

    fn clear(&mut self) {
        self.numeric_values.clear();
        self.string_values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pb_AdditionalData {
        static instance: Pb_AdditionalData = Pb_AdditionalData {
            numeric_values: ::std::vec::Vec::new(),
            string_values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pb_AdditionalData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("pb_AdditionalData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pb_AdditionalData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pb_AdditionalData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `pb_AdditionalData`
pub mod pb_additional_data {
    // @@protoc_insertion_point(message:image_analysis.pb_AdditionalData.pb_NumericValue)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Pb_NumericValue {
        // message fields
        // @@protoc_insertion_point(field:image_analysis.pb_AdditionalData.pb_NumericValue.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:image_analysis.pb_AdditionalData.pb_NumericValue.unit)
        pub unit: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:image_analysis.pb_AdditionalData.pb_NumericValue.value)
        pub value: ::std::option::Option<f64>,
        // special fields
        // @@protoc_insertion_point(special_field:image_analysis.pb_AdditionalData.pb_NumericValue.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Pb_NumericValue {
        fn default() -> &'a Pb_NumericValue {
            <Pb_NumericValue as ::protobuf::Message>::default_instance()
        }
    }

    impl Pb_NumericValue {
        pub fn new() -> Pb_NumericValue {
            ::std::default::Default::default()
        }

        // required string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // required string unit = 2;

        pub fn unit(&self) -> &str {
            match self.unit.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_unit(&mut self) {
            self.unit = ::std::option::Option::None;
        }

        pub fn has_unit(&self) -> bool {
            self.unit.is_some()
        }

        // Param is passed by value, moved
        pub fn set_unit(&mut self, v: ::std::string::String) {
            self.unit = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_unit(&mut self) -> &mut ::std::string::String {
            if self.unit.is_none() {
                self.unit = ::std::option::Option::Some(::std::string::String::new());
            }
            self.unit.as_mut().unwrap()
        }

        // Take field
        pub fn take_unit(&mut self) -> ::std::string::String {
            self.unit.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // required double value = 3;

        pub fn value(&self) -> f64 {
            self.value.unwrap_or(0.)
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: f64) {
            self.value = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Pb_NumericValue| { &m.name },
                |m: &mut Pb_NumericValue| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "unit",
                |m: &Pb_NumericValue| { &m.unit },
                |m: &mut Pb_NumericValue| { &mut m.unit },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "value",
                |m: &Pb_NumericValue| { &m.value },
                |m: &mut Pb_NumericValue| { &mut m.value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_NumericValue>(
                "pb_AdditionalData.pb_NumericValue",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Pb_NumericValue {
        const NAME: &'static str = "pb_NumericValue";

        fn is_initialized(&self) -> bool {
            if self.name.is_none() {
                return false;
            }
            if self.unit.is_none() {
                return false;
            }
            if self.value.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.unit = ::std::option::Option::Some(is.read_string()?);
                    },
                    25 => {
                        self.value = ::std::option::Option::Some(is.read_double()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.unit.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.value {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.unit.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.value {
                os.write_double(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Pb_NumericValue {
            Pb_NumericValue::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.unit = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Pb_NumericValue {
            static instance: Pb_NumericValue = Pb_NumericValue {
                name: ::std::option::Option::None,
                unit: ::std::option::Option::None,
                value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Pb_NumericValue {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("pb_AdditionalData.pb_NumericValue").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Pb_NumericValue {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Pb_NumericValue {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:image_analysis.pb_AdditionalData.pb_StringValue)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Pb_StringValue {
        // message fields
        // @@protoc_insertion_point(field:image_analysis.pb_AdditionalData.pb_StringValue.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:image_analysis.pb_AdditionalData.pb_StringValue.value)
        pub value: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:image_analysis.pb_AdditionalData.pb_StringValue.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Pb_StringValue {
        fn default() -> &'a Pb_StringValue {
            <Pb_StringValue as ::protobuf::Message>::default_instance()
        }
    }

    impl Pb_StringValue {
        pub fn new() -> Pb_StringValue {
            ::std::default::Default::default()
        }

        // required string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // required string value = 2;

        pub fn value(&self) -> &str {
            match self.value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: ::std::string::String) {
            self.value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_value(&mut self) -> &mut ::std::string::String {
            if self.value.is_none() {
                self.value = ::std::option::Option::Some(::std::string::String::new());
            }
            self.value.as_mut().unwrap()
        }

        // Take field
        pub fn take_value(&mut self) -> ::std::string::String {
            self.value.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Pb_StringValue| { &m.name },
                |m: &mut Pb_StringValue| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "value",
                |m: &Pb_StringValue| { &m.value },
                |m: &mut Pb_StringValue| { &mut m.value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_StringValue>(
                "pb_AdditionalData.pb_StringValue",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Pb_StringValue {
        const NAME: &'static str = "pb_StringValue";

        fn is_initialized(&self) -> bool {
            if self.name.is_none() {
                return false;
            }
            if self.value.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.value = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.value.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.value.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Pb_StringValue {
            Pb_StringValue::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Pb_StringValue {
            static instance: Pb_StringValue = Pb_StringValue {
                name: ::std::option::Option::None,
                value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Pb_StringValue {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("pb_AdditionalData.pb_StringValue").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Pb_StringValue {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Pb_StringValue {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:image_analysis.pb_Body_AnalyzeImage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pb_Body_AnalyzeImage {
    // message fields
    // @@protoc_insertion_point(field:image_analysis.pb_Body_AnalyzeImage.serial_number_image)
    pub serial_number_image: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:image_analysis.pb_Body_AnalyzeImage.configset_name)
    pub configset_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:image_analysis.pb_Body_AnalyzeImage.image)
    pub image: ::protobuf::MessageField<Pb_ImageData>,
    // @@protoc_insertion_point(field:image_analysis.pb_Body_AnalyzeImage.additional_data)
    pub additional_data: ::protobuf::MessageField<Pb_AdditionalData>,
    // @@protoc_insertion_point(field:image_analysis.pb_Body_AnalyzeImage.multi_images)
    pub multi_images: ::std::vec::Vec<Pb_MultiImages>,
    // special fields
    // @@protoc_insertion_point(special_field:image_analysis.pb_Body_AnalyzeImage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pb_Body_AnalyzeImage {
    fn default() -> &'a Pb_Body_AnalyzeImage {
        <Pb_Body_AnalyzeImage as ::protobuf::Message>::default_instance()
    }
}

impl Pb_Body_AnalyzeImage {
    pub fn new() -> Pb_Body_AnalyzeImage {
        ::std::default::Default::default()
    }

    // required string serial_number_image = 1;

    pub fn serial_number_image(&self) -> &str {
        match self.serial_number_image.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_serial_number_image(&mut self) {
        self.serial_number_image = ::std::option::Option::None;
    }

    pub fn has_serial_number_image(&self) -> bool {
        self.serial_number_image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serial_number_image(&mut self, v: ::std::string::String) {
        self.serial_number_image = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serial_number_image(&mut self) -> &mut ::std::string::String {
        if self.serial_number_image.is_none() {
            self.serial_number_image = ::std::option::Option::Some(::std::string::String::new());
        }
        self.serial_number_image.as_mut().unwrap()
    }

    // Take field
    pub fn take_serial_number_image(&mut self) -> ::std::string::String {
        self.serial_number_image.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string configset_name = 2;

    pub fn configset_name(&self) -> &str {
        match self.configset_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_configset_name(&mut self) {
        self.configset_name = ::std::option::Option::None;
    }

    pub fn has_configset_name(&self) -> bool {
        self.configset_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configset_name(&mut self, v: ::std::string::String) {
        self.configset_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configset_name(&mut self) -> &mut ::std::string::String {
        if self.configset_name.is_none() {
            self.configset_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.configset_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_configset_name(&mut self) -> ::std::string::String {
        self.configset_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serial_number_image",
            |m: &Pb_Body_AnalyzeImage| { &m.serial_number_image },
            |m: &mut Pb_Body_AnalyzeImage| { &mut m.serial_number_image },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "configset_name",
            |m: &Pb_Body_AnalyzeImage| { &m.configset_name },
            |m: &mut Pb_Body_AnalyzeImage| { &mut m.configset_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pb_ImageData>(
            "image",
            |m: &Pb_Body_AnalyzeImage| { &m.image },
            |m: &mut Pb_Body_AnalyzeImage| { &mut m.image },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pb_AdditionalData>(
            "additional_data",
            |m: &Pb_Body_AnalyzeImage| { &m.additional_data },
            |m: &mut Pb_Body_AnalyzeImage| { &mut m.additional_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "multi_images",
            |m: &Pb_Body_AnalyzeImage| { &m.multi_images },
            |m: &mut Pb_Body_AnalyzeImage| { &mut m.multi_images },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_Body_AnalyzeImage>(
            "pb_Body_AnalyzeImage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pb_Body_AnalyzeImage {
    const NAME: &'static str = "pb_Body_AnalyzeImage";

    fn is_initialized(&self) -> bool {
        if self.serial_number_image.is_none() {
            return false;
        }
        if self.configset_name.is_none() {
            return false;
        }
        for v in &self.image {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.additional_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.multi_images {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.serial_number_image = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.configset_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.image)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.additional_data)?;
                },
                42 => {
                    self.multi_images.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.serial_number_image.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.configset_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.image.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.additional_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.multi_images {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.serial_number_image.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.configset_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.image.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.additional_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        for v in &self.multi_images {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pb_Body_AnalyzeImage {
        Pb_Body_AnalyzeImage::new()
    }

    fn clear(&mut self) {
        self.serial_number_image = ::std::option::Option::None;
        self.configset_name = ::std::option::Option::None;
        self.image.clear();
        self.additional_data.clear();
        self.multi_images.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pb_Body_AnalyzeImage {
        static instance: Pb_Body_AnalyzeImage = Pb_Body_AnalyzeImage {
            serial_number_image: ::std::option::Option::None,
            configset_name: ::std::option::Option::None,
            image: ::protobuf::MessageField::none(),
            additional_data: ::protobuf::MessageField::none(),
            multi_images: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pb_Body_AnalyzeImage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("pb_Body_AnalyzeImage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pb_Body_AnalyzeImage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pb_Body_AnalyzeImage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:image_analysis.pb_Body_ImageResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pb_Body_ImageResult {
    // message fields
    // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.serial_number_image)
    pub serial_number_image: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.configset_name)
    pub configset_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.features)
    pub features: ::std::vec::Vec<pb_body_image_result::Pb_Feature>,
    // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.image_classification)
    pub image_classification: ::protobuf::MessageField<pb_body_image_result::Pb_ImageClassification>,
    // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.image_plain)
    pub image_plain: ::protobuf::MessageField<Pb_ImageData>,
    // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.image_overlaid)
    pub image_overlaid: ::protobuf::MessageField<Pb_ImageData>,
    // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.multi_images_plain)
    pub multi_images_plain: ::std::vec::Vec<Pb_MultiImages>,
    // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.multi_images_overlaid)
    pub multi_images_overlaid: ::std::vec::Vec<Pb_MultiImages>,
    // special fields
    // @@protoc_insertion_point(special_field:image_analysis.pb_Body_ImageResult.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pb_Body_ImageResult {
    fn default() -> &'a Pb_Body_ImageResult {
        <Pb_Body_ImageResult as ::protobuf::Message>::default_instance()
    }
}

impl Pb_Body_ImageResult {
    pub fn new() -> Pb_Body_ImageResult {
        ::std::default::Default::default()
    }

    // required string serial_number_image = 1;

    pub fn serial_number_image(&self) -> &str {
        match self.serial_number_image.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_serial_number_image(&mut self) {
        self.serial_number_image = ::std::option::Option::None;
    }

    pub fn has_serial_number_image(&self) -> bool {
        self.serial_number_image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serial_number_image(&mut self, v: ::std::string::String) {
        self.serial_number_image = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serial_number_image(&mut self) -> &mut ::std::string::String {
        if self.serial_number_image.is_none() {
            self.serial_number_image = ::std::option::Option::Some(::std::string::String::new());
        }
        self.serial_number_image.as_mut().unwrap()
    }

    // Take field
    pub fn take_serial_number_image(&mut self) -> ::std::string::String {
        self.serial_number_image.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string configset_name = 2;

    pub fn configset_name(&self) -> &str {
        match self.configset_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_configset_name(&mut self) {
        self.configset_name = ::std::option::Option::None;
    }

    pub fn has_configset_name(&self) -> bool {
        self.configset_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configset_name(&mut self, v: ::std::string::String) {
        self.configset_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configset_name(&mut self) -> &mut ::std::string::String {
        if self.configset_name.is_none() {
            self.configset_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.configset_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_configset_name(&mut self) -> ::std::string::String {
        self.configset_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serial_number_image",
            |m: &Pb_Body_ImageResult| { &m.serial_number_image },
            |m: &mut Pb_Body_ImageResult| { &mut m.serial_number_image },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "configset_name",
            |m: &Pb_Body_ImageResult| { &m.configset_name },
            |m: &mut Pb_Body_ImageResult| { &mut m.configset_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "features",
            |m: &Pb_Body_ImageResult| { &m.features },
            |m: &mut Pb_Body_ImageResult| { &mut m.features },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, pb_body_image_result::Pb_ImageClassification>(
            "image_classification",
            |m: &Pb_Body_ImageResult| { &m.image_classification },
            |m: &mut Pb_Body_ImageResult| { &mut m.image_classification },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pb_ImageData>(
            "image_plain",
            |m: &Pb_Body_ImageResult| { &m.image_plain },
            |m: &mut Pb_Body_ImageResult| { &mut m.image_plain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Pb_ImageData>(
            "image_overlaid",
            |m: &Pb_Body_ImageResult| { &m.image_overlaid },
            |m: &mut Pb_Body_ImageResult| { &mut m.image_overlaid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "multi_images_plain",
            |m: &Pb_Body_ImageResult| { &m.multi_images_plain },
            |m: &mut Pb_Body_ImageResult| { &mut m.multi_images_plain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "multi_images_overlaid",
            |m: &Pb_Body_ImageResult| { &m.multi_images_overlaid },
            |m: &mut Pb_Body_ImageResult| { &mut m.multi_images_overlaid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_Body_ImageResult>(
            "pb_Body_ImageResult",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pb_Body_ImageResult {
    const NAME: &'static str = "pb_Body_ImageResult";

    fn is_initialized(&self) -> bool {
        if self.serial_number_image.is_none() {
            return false;
        }
        if self.configset_name.is_none() {
            return false;
        }
        for v in &self.features {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.image_classification {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.image_plain {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.image_overlaid {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.multi_images_plain {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.multi_images_overlaid {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.serial_number_image = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.configset_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.features.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.image_classification)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.image_plain)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.image_overlaid)?;
                },
                58 => {
                    self.multi_images_plain.push(is.read_message()?);
                },
                66 => {
                    self.multi_images_overlaid.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.serial_number_image.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.configset_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.features {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.image_classification.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.image_plain.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.image_overlaid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.multi_images_plain {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.multi_images_overlaid {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.serial_number_image.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.configset_name.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.features {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.image_classification.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.image_plain.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.image_overlaid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        for v in &self.multi_images_plain {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        for v in &self.multi_images_overlaid {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pb_Body_ImageResult {
        Pb_Body_ImageResult::new()
    }

    fn clear(&mut self) {
        self.serial_number_image = ::std::option::Option::None;
        self.configset_name = ::std::option::Option::None;
        self.features.clear();
        self.image_classification.clear();
        self.image_plain.clear();
        self.image_overlaid.clear();
        self.multi_images_plain.clear();
        self.multi_images_overlaid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pb_Body_ImageResult {
        static instance: Pb_Body_ImageResult = Pb_Body_ImageResult {
            serial_number_image: ::std::option::Option::None,
            configset_name: ::std::option::Option::None,
            features: ::std::vec::Vec::new(),
            image_classification: ::protobuf::MessageField::none(),
            image_plain: ::protobuf::MessageField::none(),
            image_overlaid: ::protobuf::MessageField::none(),
            multi_images_plain: ::std::vec::Vec::new(),
            multi_images_overlaid: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pb_Body_ImageResult {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("pb_Body_ImageResult").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pb_Body_ImageResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pb_Body_ImageResult {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `pb_Body_ImageResult`
pub mod pb_body_image_result {
    // @@protoc_insertion_point(message:image_analysis.pb_Body_ImageResult.pb_Rect)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Pb_Rect {
        // message fields
        // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Rect.x_pos)
        pub x_pos: ::std::option::Option<f64>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Rect.y_pos)
        pub y_pos: ::std::option::Option<f64>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Rect.width)
        pub width: ::std::option::Option<f64>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Rect.height)
        pub height: ::std::option::Option<f64>,
        // special fields
        // @@protoc_insertion_point(special_field:image_analysis.pb_Body_ImageResult.pb_Rect.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Pb_Rect {
        fn default() -> &'a Pb_Rect {
            <Pb_Rect as ::protobuf::Message>::default_instance()
        }
    }

    impl Pb_Rect {
        pub fn new() -> Pb_Rect {
            ::std::default::Default::default()
        }

        // optional double x_pos = 1;

        pub fn x_pos(&self) -> f64 {
            self.x_pos.unwrap_or(0.)
        }

        pub fn clear_x_pos(&mut self) {
            self.x_pos = ::std::option::Option::None;
        }

        pub fn has_x_pos(&self) -> bool {
            self.x_pos.is_some()
        }

        // Param is passed by value, moved
        pub fn set_x_pos(&mut self, v: f64) {
            self.x_pos = ::std::option::Option::Some(v);
        }

        // optional double y_pos = 2;

        pub fn y_pos(&self) -> f64 {
            self.y_pos.unwrap_or(0.)
        }

        pub fn clear_y_pos(&mut self) {
            self.y_pos = ::std::option::Option::None;
        }

        pub fn has_y_pos(&self) -> bool {
            self.y_pos.is_some()
        }

        // Param is passed by value, moved
        pub fn set_y_pos(&mut self, v: f64) {
            self.y_pos = ::std::option::Option::Some(v);
        }

        // optional double width = 3;

        pub fn width(&self) -> f64 {
            self.width.unwrap_or(0.)
        }

        pub fn clear_width(&mut self) {
            self.width = ::std::option::Option::None;
        }

        pub fn has_width(&self) -> bool {
            self.width.is_some()
        }

        // Param is passed by value, moved
        pub fn set_width(&mut self, v: f64) {
            self.width = ::std::option::Option::Some(v);
        }

        // optional double height = 4;

        pub fn height(&self) -> f64 {
            self.height.unwrap_or(0.)
        }

        pub fn clear_height(&mut self) {
            self.height = ::std::option::Option::None;
        }

        pub fn has_height(&self) -> bool {
            self.height.is_some()
        }

        // Param is passed by value, moved
        pub fn set_height(&mut self, v: f64) {
            self.height = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "x_pos",
                |m: &Pb_Rect| { &m.x_pos },
                |m: &mut Pb_Rect| { &mut m.x_pos },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "y_pos",
                |m: &Pb_Rect| { &m.y_pos },
                |m: &mut Pb_Rect| { &mut m.y_pos },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "width",
                |m: &Pb_Rect| { &m.width },
                |m: &mut Pb_Rect| { &mut m.width },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "height",
                |m: &Pb_Rect| { &m.height },
                |m: &mut Pb_Rect| { &mut m.height },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_Rect>(
                "pb_Body_ImageResult.pb_Rect",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Pb_Rect {
        const NAME: &'static str = "pb_Rect";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.x_pos = ::std::option::Option::Some(is.read_double()?);
                    },
                    17 => {
                        self.y_pos = ::std::option::Option::Some(is.read_double()?);
                    },
                    25 => {
                        self.width = ::std::option::Option::Some(is.read_double()?);
                    },
                    33 => {
                        self.height = ::std::option::Option::Some(is.read_double()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.x_pos {
                my_size += 1 + 8;
            }
            if let Some(v) = self.y_pos {
                my_size += 1 + 8;
            }
            if let Some(v) = self.width {
                my_size += 1 + 8;
            }
            if let Some(v) = self.height {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.x_pos {
                os.write_double(1, v)?;
            }
            if let Some(v) = self.y_pos {
                os.write_double(2, v)?;
            }
            if let Some(v) = self.width {
                os.write_double(3, v)?;
            }
            if let Some(v) = self.height {
                os.write_double(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Pb_Rect {
            Pb_Rect::new()
        }

        fn clear(&mut self) {
            self.x_pos = ::std::option::Option::None;
            self.y_pos = ::std::option::Option::None;
            self.width = ::std::option::Option::None;
            self.height = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Pb_Rect {
            static instance: Pb_Rect = Pb_Rect {
                x_pos: ::std::option::Option::None,
                y_pos: ::std::option::Option::None,
                width: ::std::option::Option::None,
                height: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Pb_Rect {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("pb_Body_ImageResult.pb_Rect").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Pb_Rect {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Pb_Rect {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:image_analysis.pb_Body_ImageResult.pb_DENK_Point)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Pb_DENK_Point {
        // message fields
        // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_DENK_Point.x)
        pub x: ::std::option::Option<f64>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_DENK_Point.y)
        pub y: ::std::option::Option<f64>,
        // special fields
        // @@protoc_insertion_point(special_field:image_analysis.pb_Body_ImageResult.pb_DENK_Point.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Pb_DENK_Point {
        fn default() -> &'a Pb_DENK_Point {
            <Pb_DENK_Point as ::protobuf::Message>::default_instance()
        }
    }

    impl Pb_DENK_Point {
        pub fn new() -> Pb_DENK_Point {
            ::std::default::Default::default()
        }

        // optional double x = 1;

        pub fn x(&self) -> f64 {
            self.x.unwrap_or(0.)
        }

        pub fn clear_x(&mut self) {
            self.x = ::std::option::Option::None;
        }

        pub fn has_x(&self) -> bool {
            self.x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_x(&mut self, v: f64) {
            self.x = ::std::option::Option::Some(v);
        }

        // optional double y = 2;

        pub fn y(&self) -> f64 {
            self.y.unwrap_or(0.)
        }

        pub fn clear_y(&mut self) {
            self.y = ::std::option::Option::None;
        }

        pub fn has_y(&self) -> bool {
            self.y.is_some()
        }

        // Param is passed by value, moved
        pub fn set_y(&mut self, v: f64) {
            self.y = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "x",
                |m: &Pb_DENK_Point| { &m.x },
                |m: &mut Pb_DENK_Point| { &mut m.x },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "y",
                |m: &Pb_DENK_Point| { &m.y },
                |m: &mut Pb_DENK_Point| { &mut m.y },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_DENK_Point>(
                "pb_Body_ImageResult.pb_DENK_Point",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Pb_DENK_Point {
        const NAME: &'static str = "pb_DENK_Point";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.x = ::std::option::Option::Some(is.read_double()?);
                    },
                    17 => {
                        self.y = ::std::option::Option::Some(is.read_double()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.x {
                my_size += 1 + 8;
            }
            if let Some(v) = self.y {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.x {
                os.write_double(1, v)?;
            }
            if let Some(v) = self.y {
                os.write_double(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Pb_DENK_Point {
            Pb_DENK_Point::new()
        }

        fn clear(&mut self) {
            self.x = ::std::option::Option::None;
            self.y = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Pb_DENK_Point {
            static instance: Pb_DENK_Point = Pb_DENK_Point {
                x: ::std::option::Option::None,
                y: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Pb_DENK_Point {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("pb_Body_ImageResult.pb_DENK_Point").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Pb_DENK_Point {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Pb_DENK_Point {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:image_analysis.pb_Body_ImageResult.pb_DENK_MinimalBoundingBox)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Pb_DENK_MinimalBoundingBox {
        // message fields
        // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_DENK_MinimalBoundingBox.center_x)
        pub center_x: ::std::option::Option<f64>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_DENK_MinimalBoundingBox.center_y)
        pub center_y: ::std::option::Option<f64>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_DENK_MinimalBoundingBox.width)
        pub width: ::std::option::Option<f64>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_DENK_MinimalBoundingBox.height)
        pub height: ::std::option::Option<f64>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_DENK_MinimalBoundingBox.angle)
        pub angle: ::std::option::Option<f64>,
        // special fields
        // @@protoc_insertion_point(special_field:image_analysis.pb_Body_ImageResult.pb_DENK_MinimalBoundingBox.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Pb_DENK_MinimalBoundingBox {
        fn default() -> &'a Pb_DENK_MinimalBoundingBox {
            <Pb_DENK_MinimalBoundingBox as ::protobuf::Message>::default_instance()
        }
    }

    impl Pb_DENK_MinimalBoundingBox {
        pub fn new() -> Pb_DENK_MinimalBoundingBox {
            ::std::default::Default::default()
        }

        // optional double center_x = 1;

        pub fn center_x(&self) -> f64 {
            self.center_x.unwrap_or(0.)
        }

        pub fn clear_center_x(&mut self) {
            self.center_x = ::std::option::Option::None;
        }

        pub fn has_center_x(&self) -> bool {
            self.center_x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_center_x(&mut self, v: f64) {
            self.center_x = ::std::option::Option::Some(v);
        }

        // optional double center_y = 2;

        pub fn center_y(&self) -> f64 {
            self.center_y.unwrap_or(0.)
        }

        pub fn clear_center_y(&mut self) {
            self.center_y = ::std::option::Option::None;
        }

        pub fn has_center_y(&self) -> bool {
            self.center_y.is_some()
        }

        // Param is passed by value, moved
        pub fn set_center_y(&mut self, v: f64) {
            self.center_y = ::std::option::Option::Some(v);
        }

        // optional double width = 3;

        pub fn width(&self) -> f64 {
            self.width.unwrap_or(0.)
        }

        pub fn clear_width(&mut self) {
            self.width = ::std::option::Option::None;
        }

        pub fn has_width(&self) -> bool {
            self.width.is_some()
        }

        // Param is passed by value, moved
        pub fn set_width(&mut self, v: f64) {
            self.width = ::std::option::Option::Some(v);
        }

        // optional double height = 4;

        pub fn height(&self) -> f64 {
            self.height.unwrap_or(0.)
        }

        pub fn clear_height(&mut self) {
            self.height = ::std::option::Option::None;
        }

        pub fn has_height(&self) -> bool {
            self.height.is_some()
        }

        // Param is passed by value, moved
        pub fn set_height(&mut self, v: f64) {
            self.height = ::std::option::Option::Some(v);
        }

        // optional double angle = 5;

        pub fn angle(&self) -> f64 {
            self.angle.unwrap_or(0.)
        }

        pub fn clear_angle(&mut self) {
            self.angle = ::std::option::Option::None;
        }

        pub fn has_angle(&self) -> bool {
            self.angle.is_some()
        }

        // Param is passed by value, moved
        pub fn set_angle(&mut self, v: f64) {
            self.angle = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "center_x",
                |m: &Pb_DENK_MinimalBoundingBox| { &m.center_x },
                |m: &mut Pb_DENK_MinimalBoundingBox| { &mut m.center_x },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "center_y",
                |m: &Pb_DENK_MinimalBoundingBox| { &m.center_y },
                |m: &mut Pb_DENK_MinimalBoundingBox| { &mut m.center_y },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "width",
                |m: &Pb_DENK_MinimalBoundingBox| { &m.width },
                |m: &mut Pb_DENK_MinimalBoundingBox| { &mut m.width },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "height",
                |m: &Pb_DENK_MinimalBoundingBox| { &m.height },
                |m: &mut Pb_DENK_MinimalBoundingBox| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "angle",
                |m: &Pb_DENK_MinimalBoundingBox| { &m.angle },
                |m: &mut Pb_DENK_MinimalBoundingBox| { &mut m.angle },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_DENK_MinimalBoundingBox>(
                "pb_Body_ImageResult.pb_DENK_MinimalBoundingBox",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Pb_DENK_MinimalBoundingBox {
        const NAME: &'static str = "pb_DENK_MinimalBoundingBox";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.center_x = ::std::option::Option::Some(is.read_double()?);
                    },
                    17 => {
                        self.center_y = ::std::option::Option::Some(is.read_double()?);
                    },
                    25 => {
                        self.width = ::std::option::Option::Some(is.read_double()?);
                    },
                    33 => {
                        self.height = ::std::option::Option::Some(is.read_double()?);
                    },
                    41 => {
                        self.angle = ::std::option::Option::Some(is.read_double()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.center_x {
                my_size += 1 + 8;
            }
            if let Some(v) = self.center_y {
                my_size += 1 + 8;
            }
            if let Some(v) = self.width {
                my_size += 1 + 8;
            }
            if let Some(v) = self.height {
                my_size += 1 + 8;
            }
            if let Some(v) = self.angle {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.center_x {
                os.write_double(1, v)?;
            }
            if let Some(v) = self.center_y {
                os.write_double(2, v)?;
            }
            if let Some(v) = self.width {
                os.write_double(3, v)?;
            }
            if let Some(v) = self.height {
                os.write_double(4, v)?;
            }
            if let Some(v) = self.angle {
                os.write_double(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Pb_DENK_MinimalBoundingBox {
            Pb_DENK_MinimalBoundingBox::new()
        }

        fn clear(&mut self) {
            self.center_x = ::std::option::Option::None;
            self.center_y = ::std::option::Option::None;
            self.width = ::std::option::Option::None;
            self.height = ::std::option::Option::None;
            self.angle = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Pb_DENK_MinimalBoundingBox {
            static instance: Pb_DENK_MinimalBoundingBox = Pb_DENK_MinimalBoundingBox {
                center_x: ::std::option::Option::None,
                center_y: ::std::option::Option::None,
                width: ::std::option::Option::None,
                height: ::std::option::Option::None,
                angle: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Pb_DENK_MinimalBoundingBox {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("pb_Body_ImageResult.pb_DENK_MinimalBoundingBox").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Pb_DENK_MinimalBoundingBox {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Pb_DENK_MinimalBoundingBox {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:image_analysis.pb_Body_ImageResult.pb_DENK_OcrCharacter)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Pb_DENK_OcrCharacter {
        // message fields
        // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_DENK_OcrCharacter.character)
        pub character: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_DENK_OcrCharacter.probability)
        pub probability: ::std::option::Option<f64>,
        // special fields
        // @@protoc_insertion_point(special_field:image_analysis.pb_Body_ImageResult.pb_DENK_OcrCharacter.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Pb_DENK_OcrCharacter {
        fn default() -> &'a Pb_DENK_OcrCharacter {
            <Pb_DENK_OcrCharacter as ::protobuf::Message>::default_instance()
        }
    }

    impl Pb_DENK_OcrCharacter {
        pub fn new() -> Pb_DENK_OcrCharacter {
            ::std::default::Default::default()
        }

        // optional string character = 1;

        pub fn character(&self) -> &str {
            match self.character.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_character(&mut self) {
            self.character = ::std::option::Option::None;
        }

        pub fn has_character(&self) -> bool {
            self.character.is_some()
        }

        // Param is passed by value, moved
        pub fn set_character(&mut self, v: ::std::string::String) {
            self.character = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_character(&mut self) -> &mut ::std::string::String {
            if self.character.is_none() {
                self.character = ::std::option::Option::Some(::std::string::String::new());
            }
            self.character.as_mut().unwrap()
        }

        // Take field
        pub fn take_character(&mut self) -> ::std::string::String {
            self.character.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional double probability = 2;

        pub fn probability(&self) -> f64 {
            self.probability.unwrap_or(0.)
        }

        pub fn clear_probability(&mut self) {
            self.probability = ::std::option::Option::None;
        }

        pub fn has_probability(&self) -> bool {
            self.probability.is_some()
        }

        // Param is passed by value, moved
        pub fn set_probability(&mut self, v: f64) {
            self.probability = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "character",
                |m: &Pb_DENK_OcrCharacter| { &m.character },
                |m: &mut Pb_DENK_OcrCharacter| { &mut m.character },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "probability",
                |m: &Pb_DENK_OcrCharacter| { &m.probability },
                |m: &mut Pb_DENK_OcrCharacter| { &mut m.probability },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_DENK_OcrCharacter>(
                "pb_Body_ImageResult.pb_DENK_OcrCharacter",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Pb_DENK_OcrCharacter {
        const NAME: &'static str = "pb_DENK_OcrCharacter";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.character = ::std::option::Option::Some(is.read_string()?);
                    },
                    17 => {
                        self.probability = ::std::option::Option::Some(is.read_double()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.character.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.probability {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.character.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.probability {
                os.write_double(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Pb_DENK_OcrCharacter {
            Pb_DENK_OcrCharacter::new()
        }

        fn clear(&mut self) {
            self.character = ::std::option::Option::None;
            self.probability = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Pb_DENK_OcrCharacter {
            static instance: Pb_DENK_OcrCharacter = Pb_DENK_OcrCharacter {
                character: ::std::option::Option::None,
                probability: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Pb_DENK_OcrCharacter {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("pb_Body_ImageResult.pb_DENK_OcrCharacter").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Pb_DENK_OcrCharacter {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Pb_DENK_OcrCharacter {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:image_analysis.pb_Body_ImageResult.pb_DENK_OcrCharacterPosition)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Pb_DENK_OcrCharacterPosition {
        // message fields
        // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_DENK_OcrCharacterPosition.ocr_character)
        pub ocr_character: ::std::vec::Vec<Pb_DENK_OcrCharacter>,
        // special fields
        // @@protoc_insertion_point(special_field:image_analysis.pb_Body_ImageResult.pb_DENK_OcrCharacterPosition.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Pb_DENK_OcrCharacterPosition {
        fn default() -> &'a Pb_DENK_OcrCharacterPosition {
            <Pb_DENK_OcrCharacterPosition as ::protobuf::Message>::default_instance()
        }
    }

    impl Pb_DENK_OcrCharacterPosition {
        pub fn new() -> Pb_DENK_OcrCharacterPosition {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "ocr_character",
                |m: &Pb_DENK_OcrCharacterPosition| { &m.ocr_character },
                |m: &mut Pb_DENK_OcrCharacterPosition| { &mut m.ocr_character },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_DENK_OcrCharacterPosition>(
                "pb_Body_ImageResult.pb_DENK_OcrCharacterPosition",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Pb_DENK_OcrCharacterPosition {
        const NAME: &'static str = "pb_DENK_OcrCharacterPosition";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.ocr_character.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.ocr_character {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.ocr_character {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Pb_DENK_OcrCharacterPosition {
            Pb_DENK_OcrCharacterPosition::new()
        }

        fn clear(&mut self) {
            self.ocr_character.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Pb_DENK_OcrCharacterPosition {
            static instance: Pb_DENK_OcrCharacterPosition = Pb_DENK_OcrCharacterPosition {
                ocr_character: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Pb_DENK_OcrCharacterPosition {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("pb_Body_ImageResult.pb_DENK_OcrCharacterPosition").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Pb_DENK_OcrCharacterPosition {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Pb_DENK_OcrCharacterPosition {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:image_analysis.pb_Body_ImageResult.pb_Feature)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Pb_Feature {
        // message fields
        // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Feature.feature_type_name)
        pub feature_type_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Feature.feature_infos)
        pub feature_infos: ::std::vec::Vec<pb_feature::Pb_FeatureInfo>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Feature.multi_image_names)
        pub multi_image_names: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Feature.section)
        pub section: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Feature.filtered_out)
        pub filtered_out: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Feature.classifier)
        pub classifier: ::std::option::Option<f64>,
        // special fields
        // @@protoc_insertion_point(special_field:image_analysis.pb_Body_ImageResult.pb_Feature.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Pb_Feature {
        fn default() -> &'a Pb_Feature {
            <Pb_Feature as ::protobuf::Message>::default_instance()
        }
    }

    impl Pb_Feature {
        pub fn new() -> Pb_Feature {
            ::std::default::Default::default()
        }

        // required string feature_type_name = 1;

        pub fn feature_type_name(&self) -> &str {
            match self.feature_type_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_feature_type_name(&mut self) {
            self.feature_type_name = ::std::option::Option::None;
        }

        pub fn has_feature_type_name(&self) -> bool {
            self.feature_type_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_feature_type_name(&mut self, v: ::std::string::String) {
            self.feature_type_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_feature_type_name(&mut self) -> &mut ::std::string::String {
            if self.feature_type_name.is_none() {
                self.feature_type_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.feature_type_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_feature_type_name(&mut self) -> ::std::string::String {
            self.feature_type_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool filtered_out = 101;

        pub fn filtered_out(&self) -> bool {
            self.filtered_out.unwrap_or(false)
        }

        pub fn clear_filtered_out(&mut self) {
            self.filtered_out = ::std::option::Option::None;
        }

        pub fn has_filtered_out(&self) -> bool {
            self.filtered_out.is_some()
        }

        // Param is passed by value, moved
        pub fn set_filtered_out(&mut self, v: bool) {
            self.filtered_out = ::std::option::Option::Some(v);
        }

        // optional double classifier = 102;

        pub fn classifier(&self) -> f64 {
            self.classifier.unwrap_or(0.)
        }

        pub fn clear_classifier(&mut self) {
            self.classifier = ::std::option::Option::None;
        }

        pub fn has_classifier(&self) -> bool {
            self.classifier.is_some()
        }

        // Param is passed by value, moved
        pub fn set_classifier(&mut self, v: f64) {
            self.classifier = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "feature_type_name",
                |m: &Pb_Feature| { &m.feature_type_name },
                |m: &mut Pb_Feature| { &mut m.feature_type_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "feature_infos",
                |m: &Pb_Feature| { &m.feature_infos },
                |m: &mut Pb_Feature| { &mut m.feature_infos },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "multi_image_names",
                |m: &Pb_Feature| { &m.multi_image_names },
                |m: &mut Pb_Feature| { &mut m.multi_image_names },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "section",
                |m: &Pb_Feature| { &m.section },
                |m: &mut Pb_Feature| { &mut m.section },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "filtered_out",
                |m: &Pb_Feature| { &m.filtered_out },
                |m: &mut Pb_Feature| { &mut m.filtered_out },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "classifier",
                |m: &Pb_Feature| { &m.classifier },
                |m: &mut Pb_Feature| { &mut m.classifier },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_Feature>(
                "pb_Body_ImageResult.pb_Feature",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Pb_Feature {
        const NAME: &'static str = "pb_Feature";

        fn is_initialized(&self) -> bool {
            if self.feature_type_name.is_none() {
                return false;
            }
            for v in &self.feature_infos {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.feature_type_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.feature_infos.push(is.read_message()?);
                    },
                    26 => {
                        self.multi_image_names.push(is.read_string()?);
                    },
                    802 => {
                        self.section.push(is.read_string()?);
                    },
                    808 => {
                        self.filtered_out = ::std::option::Option::Some(is.read_bool()?);
                    },
                    817 => {
                        self.classifier = ::std::option::Option::Some(is.read_double()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.feature_type_name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            for value in &self.feature_infos {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.multi_image_names {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            for value in &self.section {
                my_size += ::protobuf::rt::string_size(100, &value);
            };
            if let Some(v) = self.filtered_out {
                my_size += 2 + 1;
            }
            if let Some(v) = self.classifier {
                my_size += 2 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.feature_type_name.as_ref() {
                os.write_string(1, v)?;
            }
            for v in &self.feature_infos {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            for v in &self.multi_image_names {
                os.write_string(3, &v)?;
            };
            for v in &self.section {
                os.write_string(100, &v)?;
            };
            if let Some(v) = self.filtered_out {
                os.write_bool(101, v)?;
            }
            if let Some(v) = self.classifier {
                os.write_double(102, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Pb_Feature {
            Pb_Feature::new()
        }

        fn clear(&mut self) {
            self.feature_type_name = ::std::option::Option::None;
            self.feature_infos.clear();
            self.multi_image_names.clear();
            self.section.clear();
            self.filtered_out = ::std::option::Option::None;
            self.classifier = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Pb_Feature {
            static instance: Pb_Feature = Pb_Feature {
                feature_type_name: ::std::option::Option::None,
                feature_infos: ::std::vec::Vec::new(),
                multi_image_names: ::std::vec::Vec::new(),
                section: ::std::vec::Vec::new(),
                filtered_out: ::std::option::Option::None,
                classifier: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Pb_Feature {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("pb_Body_ImageResult.pb_Feature").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Pb_Feature {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Pb_Feature {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `pb_Feature`
    pub mod pb_feature {
        // @@protoc_insertion_point(message:image_analysis.pb_Body_ImageResult.pb_Feature.pb_FeatureInfo)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Pb_FeatureInfo {
            // message fields
            // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Feature.pb_FeatureInfo.outline_rect_px)
            pub outline_rect_px: ::protobuf::MessageField<super::Pb_Rect>,
            // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Feature.pb_FeatureInfo.probability)
            pub probability: ::std::option::Option<f64>,
            // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Feature.pb_FeatureInfo.length)
            pub length: ::std::option::Option<f64>,
            // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Feature.pb_FeatureInfo.area)
            pub area: ::std::option::Option<f64>,
            // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Feature.pb_FeatureInfo.angle)
            pub angle: ::std::option::Option<f64>,
            // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Feature.pb_FeatureInfo.number)
            pub number: ::std::option::Option<f64>,
            // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Feature.pb_FeatureInfo.average)
            pub average: ::std::option::Option<f64>,
            // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Feature.pb_FeatureInfo.maximum)
            pub maximum: ::std::option::Option<f64>,
            // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Feature.pb_FeatureInfo.minimum)
            pub minimum: ::std::option::Option<f64>,
            // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Feature.pb_FeatureInfo.area_edge)
            pub area_edge: ::std::option::Option<f64>,
            // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Feature.pb_FeatureInfo.area_length)
            pub area_length: ::std::option::Option<f64>,
            // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Feature.pb_FeatureInfo.avggrayvalue)
            pub avggrayvalue: ::std::option::Option<f64>,
            // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Feature.pb_FeatureInfo.maxgrayvalue)
            pub maxgrayvalue: ::std::option::Option<f64>,
            // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Feature.pb_FeatureInfo.mingrayvalue)
            pub mingrayvalue: ::std::option::Option<f64>,
            // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Feature.pb_FeatureInfo.id)
            pub id: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Feature.pb_FeatureInfo.related_ids)
            pub related_ids: ::std::vec::Vec<i32>,
            // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Feature.pb_FeatureInfo.width)
            pub width: ::std::option::Option<f64>,
            // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Feature.pb_FeatureInfo.outline_rect_mm)
            pub outline_rect_mm: ::protobuf::MessageField<super::Pb_Rect>,
            // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Feature.pb_FeatureInfo.uid)
            pub uid: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Feature.pb_FeatureInfo.related_uids)
            pub related_uids: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Feature.pb_FeatureInfo.minimal_bounding_box)
            pub minimal_bounding_box: ::protobuf::MessageField<super::Pb_DENK_MinimalBoundingBox>,
            // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Feature.pb_FeatureInfo.minimal_bounding_box_point)
            pub minimal_bounding_box_point: ::std::vec::Vec<super::Pb_DENK_Point>,
            // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Feature.pb_FeatureInfo.ocr_text)
            pub ocr_text: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_Feature.pb_FeatureInfo.ocr_character_position)
            pub ocr_character_position: ::std::vec::Vec<super::Pb_DENK_OcrCharacterPosition>,
            // special fields
            // @@protoc_insertion_point(special_field:image_analysis.pb_Body_ImageResult.pb_Feature.pb_FeatureInfo.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Pb_FeatureInfo {
            fn default() -> &'a Pb_FeatureInfo {
                <Pb_FeatureInfo as ::protobuf::Message>::default_instance()
            }
        }

        impl Pb_FeatureInfo {
            pub fn new() -> Pb_FeatureInfo {
                ::std::default::Default::default()
            }

            // optional double probability = 2;

            pub fn probability(&self) -> f64 {
                self.probability.unwrap_or(-1e99f64)
            }

            pub fn clear_probability(&mut self) {
                self.probability = ::std::option::Option::None;
            }

            pub fn has_probability(&self) -> bool {
                self.probability.is_some()
            }

            // Param is passed by value, moved
            pub fn set_probability(&mut self, v: f64) {
                self.probability = ::std::option::Option::Some(v);
            }

            // optional double length = 3;

            pub fn length(&self) -> f64 {
                self.length.unwrap_or(-1e99f64)
            }

            pub fn clear_length(&mut self) {
                self.length = ::std::option::Option::None;
            }

            pub fn has_length(&self) -> bool {
                self.length.is_some()
            }

            // Param is passed by value, moved
            pub fn set_length(&mut self, v: f64) {
                self.length = ::std::option::Option::Some(v);
            }

            // optional double area = 4;

            pub fn area(&self) -> f64 {
                self.area.unwrap_or(-1e99f64)
            }

            pub fn clear_area(&mut self) {
                self.area = ::std::option::Option::None;
            }

            pub fn has_area(&self) -> bool {
                self.area.is_some()
            }

            // Param is passed by value, moved
            pub fn set_area(&mut self, v: f64) {
                self.area = ::std::option::Option::Some(v);
            }

            // optional double angle = 5;

            pub fn angle(&self) -> f64 {
                self.angle.unwrap_or(-1e99f64)
            }

            pub fn clear_angle(&mut self) {
                self.angle = ::std::option::Option::None;
            }

            pub fn has_angle(&self) -> bool {
                self.angle.is_some()
            }

            // Param is passed by value, moved
            pub fn set_angle(&mut self, v: f64) {
                self.angle = ::std::option::Option::Some(v);
            }

            // optional double number = 6;

            pub fn number(&self) -> f64 {
                self.number.unwrap_or(-1e99f64)
            }

            pub fn clear_number(&mut self) {
                self.number = ::std::option::Option::None;
            }

            pub fn has_number(&self) -> bool {
                self.number.is_some()
            }

            // Param is passed by value, moved
            pub fn set_number(&mut self, v: f64) {
                self.number = ::std::option::Option::Some(v);
            }

            // optional double average = 7;

            pub fn average(&self) -> f64 {
                self.average.unwrap_or(-1e99f64)
            }

            pub fn clear_average(&mut self) {
                self.average = ::std::option::Option::None;
            }

            pub fn has_average(&self) -> bool {
                self.average.is_some()
            }

            // Param is passed by value, moved
            pub fn set_average(&mut self, v: f64) {
                self.average = ::std::option::Option::Some(v);
            }

            // optional double maximum = 8;

            pub fn maximum(&self) -> f64 {
                self.maximum.unwrap_or(-1e99f64)
            }

            pub fn clear_maximum(&mut self) {
                self.maximum = ::std::option::Option::None;
            }

            pub fn has_maximum(&self) -> bool {
                self.maximum.is_some()
            }

            // Param is passed by value, moved
            pub fn set_maximum(&mut self, v: f64) {
                self.maximum = ::std::option::Option::Some(v);
            }

            // optional double minimum = 9;

            pub fn minimum(&self) -> f64 {
                self.minimum.unwrap_or(-1e99f64)
            }

            pub fn clear_minimum(&mut self) {
                self.minimum = ::std::option::Option::None;
            }

            pub fn has_minimum(&self) -> bool {
                self.minimum.is_some()
            }

            // Param is passed by value, moved
            pub fn set_minimum(&mut self, v: f64) {
                self.minimum = ::std::option::Option::Some(v);
            }

            // optional double area_edge = 10;

            pub fn area_edge(&self) -> f64 {
                self.area_edge.unwrap_or(-1e99f64)
            }

            pub fn clear_area_edge(&mut self) {
                self.area_edge = ::std::option::Option::None;
            }

            pub fn has_area_edge(&self) -> bool {
                self.area_edge.is_some()
            }

            // Param is passed by value, moved
            pub fn set_area_edge(&mut self, v: f64) {
                self.area_edge = ::std::option::Option::Some(v);
            }

            // optional double area_length = 11;

            pub fn area_length(&self) -> f64 {
                self.area_length.unwrap_or(-1e99f64)
            }

            pub fn clear_area_length(&mut self) {
                self.area_length = ::std::option::Option::None;
            }

            pub fn has_area_length(&self) -> bool {
                self.area_length.is_some()
            }

            // Param is passed by value, moved
            pub fn set_area_length(&mut self, v: f64) {
                self.area_length = ::std::option::Option::Some(v);
            }

            // optional double avggrayvalue = 13;

            pub fn avggrayvalue(&self) -> f64 {
                self.avggrayvalue.unwrap_or(-1e99f64)
            }

            pub fn clear_avggrayvalue(&mut self) {
                self.avggrayvalue = ::std::option::Option::None;
            }

            pub fn has_avggrayvalue(&self) -> bool {
                self.avggrayvalue.is_some()
            }

            // Param is passed by value, moved
            pub fn set_avggrayvalue(&mut self, v: f64) {
                self.avggrayvalue = ::std::option::Option::Some(v);
            }

            // optional double maxgrayvalue = 14;

            pub fn maxgrayvalue(&self) -> f64 {
                self.maxgrayvalue.unwrap_or(-1e99f64)
            }

            pub fn clear_maxgrayvalue(&mut self) {
                self.maxgrayvalue = ::std::option::Option::None;
            }

            pub fn has_maxgrayvalue(&self) -> bool {
                self.maxgrayvalue.is_some()
            }

            // Param is passed by value, moved
            pub fn set_maxgrayvalue(&mut self, v: f64) {
                self.maxgrayvalue = ::std::option::Option::Some(v);
            }

            // optional double mingrayvalue = 15;

            pub fn mingrayvalue(&self) -> f64 {
                self.mingrayvalue.unwrap_or(-1e99f64)
            }

            pub fn clear_mingrayvalue(&mut self) {
                self.mingrayvalue = ::std::option::Option::None;
            }

            pub fn has_mingrayvalue(&self) -> bool {
                self.mingrayvalue.is_some()
            }

            // Param is passed by value, moved
            pub fn set_mingrayvalue(&mut self, v: f64) {
                self.mingrayvalue = ::std::option::Option::Some(v);
            }

            // optional int32 id = 16;

            pub fn id(&self) -> i32 {
                self.id.unwrap_or(-1i32)
            }

            pub fn clear_id(&mut self) {
                self.id = ::std::option::Option::None;
            }

            pub fn has_id(&self) -> bool {
                self.id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_id(&mut self, v: i32) {
                self.id = ::std::option::Option::Some(v);
            }

            // optional double width = 100;

            pub fn width(&self) -> f64 {
                self.width.unwrap_or(-1e99f64)
            }

            pub fn clear_width(&mut self) {
                self.width = ::std::option::Option::None;
            }

            pub fn has_width(&self) -> bool {
                self.width.is_some()
            }

            // Param is passed by value, moved
            pub fn set_width(&mut self, v: f64) {
                self.width = ::std::option::Option::Some(v);
            }

            // optional string uid = 102;

            pub fn uid(&self) -> &str {
                match self.uid.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_uid(&mut self) {
                self.uid = ::std::option::Option::None;
            }

            pub fn has_uid(&self) -> bool {
                self.uid.is_some()
            }

            // Param is passed by value, moved
            pub fn set_uid(&mut self, v: ::std::string::String) {
                self.uid = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_uid(&mut self) -> &mut ::std::string::String {
                if self.uid.is_none() {
                    self.uid = ::std::option::Option::Some(::std::string::String::new());
                }
                self.uid.as_mut().unwrap()
            }

            // Take field
            pub fn take_uid(&mut self) -> ::std::string::String {
                self.uid.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional string ocr_text = 106;

            pub fn ocr_text(&self) -> &str {
                match self.ocr_text.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_ocr_text(&mut self) {
                self.ocr_text = ::std::option::Option::None;
            }

            pub fn has_ocr_text(&self) -> bool {
                self.ocr_text.is_some()
            }

            // Param is passed by value, moved
            pub fn set_ocr_text(&mut self, v: ::std::string::String) {
                self.ocr_text = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_ocr_text(&mut self) -> &mut ::std::string::String {
                if self.ocr_text.is_none() {
                    self.ocr_text = ::std::option::Option::Some(::std::string::String::new());
                }
                self.ocr_text.as_mut().unwrap()
            }

            // Take field
            pub fn take_ocr_text(&mut self) -> ::std::string::String {
                self.ocr_text.take().unwrap_or_else(|| ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(24);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Pb_Rect>(
                    "outline_rect_px",
                    |m: &Pb_FeatureInfo| { &m.outline_rect_px },
                    |m: &mut Pb_FeatureInfo| { &mut m.outline_rect_px },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "probability",
                    |m: &Pb_FeatureInfo| { &m.probability },
                    |m: &mut Pb_FeatureInfo| { &mut m.probability },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "length",
                    |m: &Pb_FeatureInfo| { &m.length },
                    |m: &mut Pb_FeatureInfo| { &mut m.length },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "area",
                    |m: &Pb_FeatureInfo| { &m.area },
                    |m: &mut Pb_FeatureInfo| { &mut m.area },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "angle",
                    |m: &Pb_FeatureInfo| { &m.angle },
                    |m: &mut Pb_FeatureInfo| { &mut m.angle },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "number",
                    |m: &Pb_FeatureInfo| { &m.number },
                    |m: &mut Pb_FeatureInfo| { &mut m.number },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "average",
                    |m: &Pb_FeatureInfo| { &m.average },
                    |m: &mut Pb_FeatureInfo| { &mut m.average },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "maximum",
                    |m: &Pb_FeatureInfo| { &m.maximum },
                    |m: &mut Pb_FeatureInfo| { &mut m.maximum },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "minimum",
                    |m: &Pb_FeatureInfo| { &m.minimum },
                    |m: &mut Pb_FeatureInfo| { &mut m.minimum },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "area_edge",
                    |m: &Pb_FeatureInfo| { &m.area_edge },
                    |m: &mut Pb_FeatureInfo| { &mut m.area_edge },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "area_length",
                    |m: &Pb_FeatureInfo| { &m.area_length },
                    |m: &mut Pb_FeatureInfo| { &mut m.area_length },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "avggrayvalue",
                    |m: &Pb_FeatureInfo| { &m.avggrayvalue },
                    |m: &mut Pb_FeatureInfo| { &mut m.avggrayvalue },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "maxgrayvalue",
                    |m: &Pb_FeatureInfo| { &m.maxgrayvalue },
                    |m: &mut Pb_FeatureInfo| { &mut m.maxgrayvalue },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "mingrayvalue",
                    |m: &Pb_FeatureInfo| { &m.mingrayvalue },
                    |m: &mut Pb_FeatureInfo| { &mut m.mingrayvalue },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "id",
                    |m: &Pb_FeatureInfo| { &m.id },
                    |m: &mut Pb_FeatureInfo| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "related_ids",
                    |m: &Pb_FeatureInfo| { &m.related_ids },
                    |m: &mut Pb_FeatureInfo| { &mut m.related_ids },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "width",
                    |m: &Pb_FeatureInfo| { &m.width },
                    |m: &mut Pb_FeatureInfo| { &mut m.width },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Pb_Rect>(
                    "outline_rect_mm",
                    |m: &Pb_FeatureInfo| { &m.outline_rect_mm },
                    |m: &mut Pb_FeatureInfo| { &mut m.outline_rect_mm },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "uid",
                    |m: &Pb_FeatureInfo| { &m.uid },
                    |m: &mut Pb_FeatureInfo| { &mut m.uid },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "related_uids",
                    |m: &Pb_FeatureInfo| { &m.related_uids },
                    |m: &mut Pb_FeatureInfo| { &mut m.related_uids },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::Pb_DENK_MinimalBoundingBox>(
                    "minimal_bounding_box",
                    |m: &Pb_FeatureInfo| { &m.minimal_bounding_box },
                    |m: &mut Pb_FeatureInfo| { &mut m.minimal_bounding_box },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "minimal_bounding_box_point",
                    |m: &Pb_FeatureInfo| { &m.minimal_bounding_box_point },
                    |m: &mut Pb_FeatureInfo| { &mut m.minimal_bounding_box_point },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "ocr_text",
                    |m: &Pb_FeatureInfo| { &m.ocr_text },
                    |m: &mut Pb_FeatureInfo| { &mut m.ocr_text },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "ocr_character_position",
                    |m: &Pb_FeatureInfo| { &m.ocr_character_position },
                    |m: &mut Pb_FeatureInfo| { &mut m.ocr_character_position },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_FeatureInfo>(
                    "pb_Body_ImageResult.pb_Feature.pb_FeatureInfo",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Pb_FeatureInfo {
            const NAME: &'static str = "pb_FeatureInfo";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.outline_rect_px)?;
                        },
                        17 => {
                            self.probability = ::std::option::Option::Some(is.read_double()?);
                        },
                        25 => {
                            self.length = ::std::option::Option::Some(is.read_double()?);
                        },
                        33 => {
                            self.area = ::std::option::Option::Some(is.read_double()?);
                        },
                        41 => {
                            self.angle = ::std::option::Option::Some(is.read_double()?);
                        },
                        49 => {
                            self.number = ::std::option::Option::Some(is.read_double()?);
                        },
                        57 => {
                            self.average = ::std::option::Option::Some(is.read_double()?);
                        },
                        65 => {
                            self.maximum = ::std::option::Option::Some(is.read_double()?);
                        },
                        73 => {
                            self.minimum = ::std::option::Option::Some(is.read_double()?);
                        },
                        81 => {
                            self.area_edge = ::std::option::Option::Some(is.read_double()?);
                        },
                        89 => {
                            self.area_length = ::std::option::Option::Some(is.read_double()?);
                        },
                        105 => {
                            self.avggrayvalue = ::std::option::Option::Some(is.read_double()?);
                        },
                        113 => {
                            self.maxgrayvalue = ::std::option::Option::Some(is.read_double()?);
                        },
                        121 => {
                            self.mingrayvalue = ::std::option::Option::Some(is.read_double()?);
                        },
                        128 => {
                            self.id = ::std::option::Option::Some(is.read_int32()?);
                        },
                        138 => {
                            is.read_repeated_packed_int32_into(&mut self.related_ids)?;
                        },
                        136 => {
                            self.related_ids.push(is.read_int32()?);
                        },
                        801 => {
                            self.width = ::std::option::Option::Some(is.read_double()?);
                        },
                        810 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.outline_rect_mm)?;
                        },
                        818 => {
                            self.uid = ::std::option::Option::Some(is.read_string()?);
                        },
                        826 => {
                            self.related_uids.push(is.read_string()?);
                        },
                        834 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.minimal_bounding_box)?;
                        },
                        842 => {
                            self.minimal_bounding_box_point.push(is.read_message()?);
                        },
                        850 => {
                            self.ocr_text = ::std::option::Option::Some(is.read_string()?);
                        },
                        858 => {
                            self.ocr_character_position.push(is.read_message()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.outline_rect_px.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                if let Some(v) = self.probability {
                    my_size += 1 + 8;
                }
                if let Some(v) = self.length {
                    my_size += 1 + 8;
                }
                if let Some(v) = self.area {
                    my_size += 1 + 8;
                }
                if let Some(v) = self.angle {
                    my_size += 1 + 8;
                }
                if let Some(v) = self.number {
                    my_size += 1 + 8;
                }
                if let Some(v) = self.average {
                    my_size += 1 + 8;
                }
                if let Some(v) = self.maximum {
                    my_size += 1 + 8;
                }
                if let Some(v) = self.minimum {
                    my_size += 1 + 8;
                }
                if let Some(v) = self.area_edge {
                    my_size += 1 + 8;
                }
                if let Some(v) = self.area_length {
                    my_size += 1 + 8;
                }
                if let Some(v) = self.avggrayvalue {
                    my_size += 1 + 8;
                }
                if let Some(v) = self.maxgrayvalue {
                    my_size += 1 + 8;
                }
                if let Some(v) = self.mingrayvalue {
                    my_size += 1 + 8;
                }
                if let Some(v) = self.id {
                    my_size += ::protobuf::rt::int32_size(16, v);
                }
                for value in &self.related_ids {
                    my_size += ::protobuf::rt::int32_size(17, *value);
                };
                if let Some(v) = self.width {
                    my_size += 2 + 8;
                }
                if let Some(v) = self.outline_rect_mm.as_ref() {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                if let Some(v) = self.uid.as_ref() {
                    my_size += ::protobuf::rt::string_size(102, &v);
                }
                for value in &self.related_uids {
                    my_size += ::protobuf::rt::string_size(103, &value);
                };
                if let Some(v) = self.minimal_bounding_box.as_ref() {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                for value in &self.minimal_bounding_box_point {
                    let len = value.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                if let Some(v) = self.ocr_text.as_ref() {
                    my_size += ::protobuf::rt::string_size(106, &v);
                }
                for value in &self.ocr_character_position {
                    let len = value.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.outline_rect_px.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                }
                if let Some(v) = self.probability {
                    os.write_double(2, v)?;
                }
                if let Some(v) = self.length {
                    os.write_double(3, v)?;
                }
                if let Some(v) = self.area {
                    os.write_double(4, v)?;
                }
                if let Some(v) = self.angle {
                    os.write_double(5, v)?;
                }
                if let Some(v) = self.number {
                    os.write_double(6, v)?;
                }
                if let Some(v) = self.average {
                    os.write_double(7, v)?;
                }
                if let Some(v) = self.maximum {
                    os.write_double(8, v)?;
                }
                if let Some(v) = self.minimum {
                    os.write_double(9, v)?;
                }
                if let Some(v) = self.area_edge {
                    os.write_double(10, v)?;
                }
                if let Some(v) = self.area_length {
                    os.write_double(11, v)?;
                }
                if let Some(v) = self.avggrayvalue {
                    os.write_double(13, v)?;
                }
                if let Some(v) = self.maxgrayvalue {
                    os.write_double(14, v)?;
                }
                if let Some(v) = self.mingrayvalue {
                    os.write_double(15, v)?;
                }
                if let Some(v) = self.id {
                    os.write_int32(16, v)?;
                }
                for v in &self.related_ids {
                    os.write_int32(17, *v)?;
                };
                if let Some(v) = self.width {
                    os.write_double(100, v)?;
                }
                if let Some(v) = self.outline_rect_mm.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(101, v, os)?;
                }
                if let Some(v) = self.uid.as_ref() {
                    os.write_string(102, v)?;
                }
                for v in &self.related_uids {
                    os.write_string(103, &v)?;
                };
                if let Some(v) = self.minimal_bounding_box.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(104, v, os)?;
                }
                for v in &self.minimal_bounding_box_point {
                    ::protobuf::rt::write_message_field_with_cached_size(105, v, os)?;
                };
                if let Some(v) = self.ocr_text.as_ref() {
                    os.write_string(106, v)?;
                }
                for v in &self.ocr_character_position {
                    ::protobuf::rt::write_message_field_with_cached_size(107, v, os)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Pb_FeatureInfo {
                Pb_FeatureInfo::new()
            }

            fn clear(&mut self) {
                self.outline_rect_px.clear();
                self.probability = ::std::option::Option::None;
                self.length = ::std::option::Option::None;
                self.area = ::std::option::Option::None;
                self.angle = ::std::option::Option::None;
                self.number = ::std::option::Option::None;
                self.average = ::std::option::Option::None;
                self.maximum = ::std::option::Option::None;
                self.minimum = ::std::option::Option::None;
                self.area_edge = ::std::option::Option::None;
                self.area_length = ::std::option::Option::None;
                self.avggrayvalue = ::std::option::Option::None;
                self.maxgrayvalue = ::std::option::Option::None;
                self.mingrayvalue = ::std::option::Option::None;
                self.id = ::std::option::Option::None;
                self.related_ids.clear();
                self.width = ::std::option::Option::None;
                self.outline_rect_mm.clear();
                self.uid = ::std::option::Option::None;
                self.related_uids.clear();
                self.minimal_bounding_box.clear();
                self.minimal_bounding_box_point.clear();
                self.ocr_text = ::std::option::Option::None;
                self.ocr_character_position.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Pb_FeatureInfo {
                static instance: Pb_FeatureInfo = Pb_FeatureInfo {
                    outline_rect_px: ::protobuf::MessageField::none(),
                    probability: ::std::option::Option::None,
                    length: ::std::option::Option::None,
                    area: ::std::option::Option::None,
                    angle: ::std::option::Option::None,
                    number: ::std::option::Option::None,
                    average: ::std::option::Option::None,
                    maximum: ::std::option::Option::None,
                    minimum: ::std::option::Option::None,
                    area_edge: ::std::option::Option::None,
                    area_length: ::std::option::Option::None,
                    avggrayvalue: ::std::option::Option::None,
                    maxgrayvalue: ::std::option::Option::None,
                    mingrayvalue: ::std::option::Option::None,
                    id: ::std::option::Option::None,
                    related_ids: ::std::vec::Vec::new(),
                    width: ::std::option::Option::None,
                    outline_rect_mm: ::protobuf::MessageField::none(),
                    uid: ::std::option::Option::None,
                    related_uids: ::std::vec::Vec::new(),
                    minimal_bounding_box: ::protobuf::MessageField::none(),
                    minimal_bounding_box_point: ::std::vec::Vec::new(),
                    ocr_text: ::std::option::Option::None,
                    ocr_character_position: ::std::vec::Vec::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Pb_FeatureInfo {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("pb_Body_ImageResult.pb_Feature.pb_FeatureInfo").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Pb_FeatureInfo {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Pb_FeatureInfo {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:image_analysis.pb_Body_ImageResult.pb_ImageClassification)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Pb_ImageClassification {
        // message fields
        // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_ImageClassification.image_class_name)
        pub image_class_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_ImageClassification.image_quality_class)
        pub image_quality_class: ::std::option::Option<::protobuf::EnumOrUnknown<pb_image_classification::Pb_ImageQualityEnum>>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_ImageClassification.image_quality_code)
        pub image_quality_code: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_ImageClassification.image_quality_score)
        pub image_quality_score: ::std::option::Option<f64>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_ImageClassification.image_ok_score)
        pub image_ok_score: ::std::option::Option<f64>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_ImageClassification.image_avggrayvalue)
        pub image_avggrayvalue: ::std::option::Option<f64>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_ImageClassification.image_maxgrayvalue)
        pub image_maxgrayvalue: ::std::option::Option<f64>,
        // @@protoc_insertion_point(field:image_analysis.pb_Body_ImageResult.pb_ImageClassification.image_mingrayvalue)
        pub image_mingrayvalue: ::std::option::Option<f64>,
        // special fields
        // @@protoc_insertion_point(special_field:image_analysis.pb_Body_ImageResult.pb_ImageClassification.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Pb_ImageClassification {
        fn default() -> &'a Pb_ImageClassification {
            <Pb_ImageClassification as ::protobuf::Message>::default_instance()
        }
    }

    impl Pb_ImageClassification {
        pub fn new() -> Pb_ImageClassification {
            ::std::default::Default::default()
        }

        // optional string image_class_name = 1;

        pub fn image_class_name(&self) -> &str {
            match self.image_class_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_image_class_name(&mut self) {
            self.image_class_name = ::std::option::Option::None;
        }

        pub fn has_image_class_name(&self) -> bool {
            self.image_class_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_image_class_name(&mut self, v: ::std::string::String) {
            self.image_class_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_image_class_name(&mut self) -> &mut ::std::string::String {
            if self.image_class_name.is_none() {
                self.image_class_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.image_class_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_image_class_name(&mut self) -> ::std::string::String {
            self.image_class_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional .image_analysis.pb_Body_ImageResult.pb_ImageClassification.pb_ImageQualityEnum image_quality_class = 2;

        pub fn image_quality_class(&self) -> pb_image_classification::Pb_ImageQualityEnum {
            match self.image_quality_class {
                Some(e) => e.enum_value_or(pb_image_classification::Pb_ImageQualityEnum::UNDEFINED_QUALITY),
                None => pb_image_classification::Pb_ImageQualityEnum::UNDEFINED_QUALITY,
            }
        }

        pub fn clear_image_quality_class(&mut self) {
            self.image_quality_class = ::std::option::Option::None;
        }

        pub fn has_image_quality_class(&self) -> bool {
            self.image_quality_class.is_some()
        }

        // Param is passed by value, moved
        pub fn set_image_quality_class(&mut self, v: pb_image_classification::Pb_ImageQualityEnum) {
            self.image_quality_class = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional string image_quality_code = 3;

        pub fn image_quality_code(&self) -> &str {
            match self.image_quality_code.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_image_quality_code(&mut self) {
            self.image_quality_code = ::std::option::Option::None;
        }

        pub fn has_image_quality_code(&self) -> bool {
            self.image_quality_code.is_some()
        }

        // Param is passed by value, moved
        pub fn set_image_quality_code(&mut self, v: ::std::string::String) {
            self.image_quality_code = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_image_quality_code(&mut self) -> &mut ::std::string::String {
            if self.image_quality_code.is_none() {
                self.image_quality_code = ::std::option::Option::Some(::std::string::String::new());
            }
            self.image_quality_code.as_mut().unwrap()
        }

        // Take field
        pub fn take_image_quality_code(&mut self) -> ::std::string::String {
            self.image_quality_code.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional double image_quality_score = 4;

        pub fn image_quality_score(&self) -> f64 {
            self.image_quality_score.unwrap_or(-1e99f64)
        }

        pub fn clear_image_quality_score(&mut self) {
            self.image_quality_score = ::std::option::Option::None;
        }

        pub fn has_image_quality_score(&self) -> bool {
            self.image_quality_score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_image_quality_score(&mut self, v: f64) {
            self.image_quality_score = ::std::option::Option::Some(v);
        }

        // optional double image_ok_score = 5;

        pub fn image_ok_score(&self) -> f64 {
            self.image_ok_score.unwrap_or(-1e99f64)
        }

        pub fn clear_image_ok_score(&mut self) {
            self.image_ok_score = ::std::option::Option::None;
        }

        pub fn has_image_ok_score(&self) -> bool {
            self.image_ok_score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_image_ok_score(&mut self, v: f64) {
            self.image_ok_score = ::std::option::Option::Some(v);
        }

        // optional double image_avggrayvalue = 6;

        pub fn image_avggrayvalue(&self) -> f64 {
            self.image_avggrayvalue.unwrap_or(-1e99f64)
        }

        pub fn clear_image_avggrayvalue(&mut self) {
            self.image_avggrayvalue = ::std::option::Option::None;
        }

        pub fn has_image_avggrayvalue(&self) -> bool {
            self.image_avggrayvalue.is_some()
        }

        // Param is passed by value, moved
        pub fn set_image_avggrayvalue(&mut self, v: f64) {
            self.image_avggrayvalue = ::std::option::Option::Some(v);
        }

        // optional double image_maxgrayvalue = 7;

        pub fn image_maxgrayvalue(&self) -> f64 {
            self.image_maxgrayvalue.unwrap_or(-1e99f64)
        }

        pub fn clear_image_maxgrayvalue(&mut self) {
            self.image_maxgrayvalue = ::std::option::Option::None;
        }

        pub fn has_image_maxgrayvalue(&self) -> bool {
            self.image_maxgrayvalue.is_some()
        }

        // Param is passed by value, moved
        pub fn set_image_maxgrayvalue(&mut self, v: f64) {
            self.image_maxgrayvalue = ::std::option::Option::Some(v);
        }

        // optional double image_mingrayvalue = 8;

        pub fn image_mingrayvalue(&self) -> f64 {
            self.image_mingrayvalue.unwrap_or(-1e99f64)
        }

        pub fn clear_image_mingrayvalue(&mut self) {
            self.image_mingrayvalue = ::std::option::Option::None;
        }

        pub fn has_image_mingrayvalue(&self) -> bool {
            self.image_mingrayvalue.is_some()
        }

        // Param is passed by value, moved
        pub fn set_image_mingrayvalue(&mut self, v: f64) {
            self.image_mingrayvalue = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "image_class_name",
                |m: &Pb_ImageClassification| { &m.image_class_name },
                |m: &mut Pb_ImageClassification| { &mut m.image_class_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "image_quality_class",
                |m: &Pb_ImageClassification| { &m.image_quality_class },
                |m: &mut Pb_ImageClassification| { &mut m.image_quality_class },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "image_quality_code",
                |m: &Pb_ImageClassification| { &m.image_quality_code },
                |m: &mut Pb_ImageClassification| { &mut m.image_quality_code },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "image_quality_score",
                |m: &Pb_ImageClassification| { &m.image_quality_score },
                |m: &mut Pb_ImageClassification| { &mut m.image_quality_score },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "image_ok_score",
                |m: &Pb_ImageClassification| { &m.image_ok_score },
                |m: &mut Pb_ImageClassification| { &mut m.image_ok_score },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "image_avggrayvalue",
                |m: &Pb_ImageClassification| { &m.image_avggrayvalue },
                |m: &mut Pb_ImageClassification| { &mut m.image_avggrayvalue },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "image_maxgrayvalue",
                |m: &Pb_ImageClassification| { &m.image_maxgrayvalue },
                |m: &mut Pb_ImageClassification| { &mut m.image_maxgrayvalue },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "image_mingrayvalue",
                |m: &Pb_ImageClassification| { &m.image_mingrayvalue },
                |m: &mut Pb_ImageClassification| { &mut m.image_mingrayvalue },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_ImageClassification>(
                "pb_Body_ImageResult.pb_ImageClassification",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Pb_ImageClassification {
        const NAME: &'static str = "pb_ImageClassification";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.image_class_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.image_quality_class = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    26 => {
                        self.image_quality_code = ::std::option::Option::Some(is.read_string()?);
                    },
                    33 => {
                        self.image_quality_score = ::std::option::Option::Some(is.read_double()?);
                    },
                    41 => {
                        self.image_ok_score = ::std::option::Option::Some(is.read_double()?);
                    },
                    49 => {
                        self.image_avggrayvalue = ::std::option::Option::Some(is.read_double()?);
                    },
                    57 => {
                        self.image_maxgrayvalue = ::std::option::Option::Some(is.read_double()?);
                    },
                    65 => {
                        self.image_mingrayvalue = ::std::option::Option::Some(is.read_double()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.image_class_name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.image_quality_class {
                my_size += ::protobuf::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.image_quality_code.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.image_quality_score {
                my_size += 1 + 8;
            }
            if let Some(v) = self.image_ok_score {
                my_size += 1 + 8;
            }
            if let Some(v) = self.image_avggrayvalue {
                my_size += 1 + 8;
            }
            if let Some(v) = self.image_maxgrayvalue {
                my_size += 1 + 8;
            }
            if let Some(v) = self.image_mingrayvalue {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.image_class_name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.image_quality_class {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.image_quality_code.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.image_quality_score {
                os.write_double(4, v)?;
            }
            if let Some(v) = self.image_ok_score {
                os.write_double(5, v)?;
            }
            if let Some(v) = self.image_avggrayvalue {
                os.write_double(6, v)?;
            }
            if let Some(v) = self.image_maxgrayvalue {
                os.write_double(7, v)?;
            }
            if let Some(v) = self.image_mingrayvalue {
                os.write_double(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Pb_ImageClassification {
            Pb_ImageClassification::new()
        }

        fn clear(&mut self) {
            self.image_class_name = ::std::option::Option::None;
            self.image_quality_class = ::std::option::Option::None;
            self.image_quality_code = ::std::option::Option::None;
            self.image_quality_score = ::std::option::Option::None;
            self.image_ok_score = ::std::option::Option::None;
            self.image_avggrayvalue = ::std::option::Option::None;
            self.image_maxgrayvalue = ::std::option::Option::None;
            self.image_mingrayvalue = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Pb_ImageClassification {
            static instance: Pb_ImageClassification = Pb_ImageClassification {
                image_class_name: ::std::option::Option::None,
                image_quality_class: ::std::option::Option::None,
                image_quality_code: ::std::option::Option::None,
                image_quality_score: ::std::option::Option::None,
                image_ok_score: ::std::option::Option::None,
                image_avggrayvalue: ::std::option::Option::None,
                image_maxgrayvalue: ::std::option::Option::None,
                image_mingrayvalue: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Pb_ImageClassification {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("pb_Body_ImageResult.pb_ImageClassification").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Pb_ImageClassification {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Pb_ImageClassification {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `pb_ImageClassification`
    pub mod pb_image_classification {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:image_analysis.pb_Body_ImageResult.pb_ImageClassification.pb_ImageQualityEnum)
        pub enum Pb_ImageQualityEnum {
            // @@protoc_insertion_point(enum_value:image_analysis.pb_Body_ImageResult.pb_ImageClassification.pb_ImageQualityEnum.UNDEFINED_QUALITY)
            UNDEFINED_QUALITY = 0,
            // @@protoc_insertion_point(enum_value:image_analysis.pb_Body_ImageResult.pb_ImageClassification.pb_ImageQualityEnum.NO_ISSUE_QUALITY)
            NO_ISSUE_QUALITY = 1,
            // @@protoc_insertion_point(enum_value:image_analysis.pb_Body_ImageResult.pb_ImageClassification.pb_ImageQualityEnum.MINOR_ISSUE_QUALITY)
            MINOR_ISSUE_QUALITY = 2,
            // @@protoc_insertion_point(enum_value:image_analysis.pb_Body_ImageResult.pb_ImageClassification.pb_ImageQualityEnum.MAJOR_ISSUE_QUALITY)
            MAJOR_ISSUE_QUALITY = 3,
        }

        impl ::protobuf::Enum for Pb_ImageQualityEnum {
            const NAME: &'static str = "pb_ImageQualityEnum";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<Pb_ImageQualityEnum> {
                match value {
                    0 => ::std::option::Option::Some(Pb_ImageQualityEnum::UNDEFINED_QUALITY),
                    1 => ::std::option::Option::Some(Pb_ImageQualityEnum::NO_ISSUE_QUALITY),
                    2 => ::std::option::Option::Some(Pb_ImageQualityEnum::MINOR_ISSUE_QUALITY),
                    3 => ::std::option::Option::Some(Pb_ImageQualityEnum::MAJOR_ISSUE_QUALITY),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<Pb_ImageQualityEnum> {
                match str {
                    "UNDEFINED_QUALITY" => ::std::option::Option::Some(Pb_ImageQualityEnum::UNDEFINED_QUALITY),
                    "NO_ISSUE_QUALITY" => ::std::option::Option::Some(Pb_ImageQualityEnum::NO_ISSUE_QUALITY),
                    "MINOR_ISSUE_QUALITY" => ::std::option::Option::Some(Pb_ImageQualityEnum::MINOR_ISSUE_QUALITY),
                    "MAJOR_ISSUE_QUALITY" => ::std::option::Option::Some(Pb_ImageQualityEnum::MAJOR_ISSUE_QUALITY),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [Pb_ImageQualityEnum] = &[
                Pb_ImageQualityEnum::UNDEFINED_QUALITY,
                Pb_ImageQualityEnum::NO_ISSUE_QUALITY,
                Pb_ImageQualityEnum::MINOR_ISSUE_QUALITY,
                Pb_ImageQualityEnum::MAJOR_ISSUE_QUALITY,
            ];
        }

        impl ::protobuf::EnumFull for Pb_ImageQualityEnum {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("pb_Body_ImageResult.pb_ImageClassification.pb_ImageQualityEnum").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for Pb_ImageQualityEnum {
            fn default() -> Self {
                Pb_ImageQualityEnum::UNDEFINED_QUALITY
            }
        }

        impl Pb_ImageQualityEnum {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Pb_ImageQualityEnum>("pb_Body_ImageResult.pb_ImageClassification.pb_ImageQualityEnum")
            }
        }
    }
}

// @@protoc_insertion_point(message:image_analysis.pb_Body_InfoMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pb_Body_InfoMessage {
    // message fields
    // @@protoc_insertion_point(field:image_analysis.pb_Body_InfoMessage.info_type)
    pub info_type: ::std::option::Option<::protobuf::EnumOrUnknown<pb_body_info_message::Pb_InfoTypeEnum>>,
    // @@protoc_insertion_point(field:image_analysis.pb_Body_InfoMessage.numeric_code)
    pub numeric_code: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:image_analysis.pb_Body_InfoMessage.info_text)
    pub info_text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:image_analysis.pb_Body_InfoMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pb_Body_InfoMessage {
    fn default() -> &'a Pb_Body_InfoMessage {
        <Pb_Body_InfoMessage as ::protobuf::Message>::default_instance()
    }
}

impl Pb_Body_InfoMessage {
    pub fn new() -> Pb_Body_InfoMessage {
        ::std::default::Default::default()
    }

    // required .image_analysis.pb_Body_InfoMessage.pb_InfoTypeEnum info_type = 1;

    pub fn info_type(&self) -> pb_body_info_message::Pb_InfoTypeEnum {
        match self.info_type {
            Some(e) => e.enum_value_or(pb_body_info_message::Pb_InfoTypeEnum::UNDEFINED_IT),
            None => pb_body_info_message::Pb_InfoTypeEnum::UNDEFINED_IT,
        }
    }

    pub fn clear_info_type(&mut self) {
        self.info_type = ::std::option::Option::None;
    }

    pub fn has_info_type(&self) -> bool {
        self.info_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info_type(&mut self, v: pb_body_info_message::Pb_InfoTypeEnum) {
        self.info_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int32 numeric_code = 2;

    pub fn numeric_code(&self) -> i32 {
        self.numeric_code.unwrap_or(0)
    }

    pub fn clear_numeric_code(&mut self) {
        self.numeric_code = ::std::option::Option::None;
    }

    pub fn has_numeric_code(&self) -> bool {
        self.numeric_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numeric_code(&mut self, v: i32) {
        self.numeric_code = ::std::option::Option::Some(v);
    }

    // required string info_text = 3;

    pub fn info_text(&self) -> &str {
        match self.info_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_info_text(&mut self) {
        self.info_text = ::std::option::Option::None;
    }

    pub fn has_info_text(&self) -> bool {
        self.info_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info_text(&mut self, v: ::std::string::String) {
        self.info_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info_text(&mut self) -> &mut ::std::string::String {
        if self.info_text.is_none() {
            self.info_text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.info_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_info_text(&mut self) -> ::std::string::String {
        self.info_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "info_type",
            |m: &Pb_Body_InfoMessage| { &m.info_type },
            |m: &mut Pb_Body_InfoMessage| { &mut m.info_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "numeric_code",
            |m: &Pb_Body_InfoMessage| { &m.numeric_code },
            |m: &mut Pb_Body_InfoMessage| { &mut m.numeric_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "info_text",
            |m: &Pb_Body_InfoMessage| { &m.info_text },
            |m: &mut Pb_Body_InfoMessage| { &mut m.info_text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_Body_InfoMessage>(
            "pb_Body_InfoMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pb_Body_InfoMessage {
    const NAME: &'static str = "pb_Body_InfoMessage";

    fn is_initialized(&self) -> bool {
        if self.info_type.is_none() {
            return false;
        }
        if self.numeric_code.is_none() {
            return false;
        }
        if self.info_text.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.info_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.numeric_code = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.info_text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.info_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.numeric_code {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.info_text.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.info_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.numeric_code {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.info_text.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pb_Body_InfoMessage {
        Pb_Body_InfoMessage::new()
    }

    fn clear(&mut self) {
        self.info_type = ::std::option::Option::None;
        self.numeric_code = ::std::option::Option::None;
        self.info_text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pb_Body_InfoMessage {
        static instance: Pb_Body_InfoMessage = Pb_Body_InfoMessage {
            info_type: ::std::option::Option::None,
            numeric_code: ::std::option::Option::None,
            info_text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pb_Body_InfoMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("pb_Body_InfoMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pb_Body_InfoMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pb_Body_InfoMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `pb_Body_InfoMessage`
pub mod pb_body_info_message {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:image_analysis.pb_Body_InfoMessage.pb_InfoTypeEnum)
    pub enum Pb_InfoTypeEnum {
        // @@protoc_insertion_point(enum_value:image_analysis.pb_Body_InfoMessage.pb_InfoTypeEnum.UNDEFINED_IT)
        UNDEFINED_IT = 0,
        // @@protoc_insertion_point(enum_value:image_analysis.pb_Body_InfoMessage.pb_InfoTypeEnum.DEBUG_IT)
        DEBUG_IT = 1,
        // @@protoc_insertion_point(enum_value:image_analysis.pb_Body_InfoMessage.pb_InfoTypeEnum.INFO_IT)
        INFO_IT = 2,
        // @@protoc_insertion_point(enum_value:image_analysis.pb_Body_InfoMessage.pb_InfoTypeEnum.WARNING_IT)
        WARNING_IT = 3,
        // @@protoc_insertion_point(enum_value:image_analysis.pb_Body_InfoMessage.pb_InfoTypeEnum.ERROR_IT)
        ERROR_IT = 4,
    }

    impl ::protobuf::Enum for Pb_InfoTypeEnum {
        const NAME: &'static str = "pb_InfoTypeEnum";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Pb_InfoTypeEnum> {
            match value {
                0 => ::std::option::Option::Some(Pb_InfoTypeEnum::UNDEFINED_IT),
                1 => ::std::option::Option::Some(Pb_InfoTypeEnum::DEBUG_IT),
                2 => ::std::option::Option::Some(Pb_InfoTypeEnum::INFO_IT),
                3 => ::std::option::Option::Some(Pb_InfoTypeEnum::WARNING_IT),
                4 => ::std::option::Option::Some(Pb_InfoTypeEnum::ERROR_IT),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Pb_InfoTypeEnum> {
            match str {
                "UNDEFINED_IT" => ::std::option::Option::Some(Pb_InfoTypeEnum::UNDEFINED_IT),
                "DEBUG_IT" => ::std::option::Option::Some(Pb_InfoTypeEnum::DEBUG_IT),
                "INFO_IT" => ::std::option::Option::Some(Pb_InfoTypeEnum::INFO_IT),
                "WARNING_IT" => ::std::option::Option::Some(Pb_InfoTypeEnum::WARNING_IT),
                "ERROR_IT" => ::std::option::Option::Some(Pb_InfoTypeEnum::ERROR_IT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Pb_InfoTypeEnum] = &[
            Pb_InfoTypeEnum::UNDEFINED_IT,
            Pb_InfoTypeEnum::DEBUG_IT,
            Pb_InfoTypeEnum::INFO_IT,
            Pb_InfoTypeEnum::WARNING_IT,
            Pb_InfoTypeEnum::ERROR_IT,
        ];
    }

    impl ::protobuf::EnumFull for Pb_InfoTypeEnum {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("pb_Body_InfoMessage.pb_InfoTypeEnum").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Pb_InfoTypeEnum {
        fn default() -> Self {
            Pb_InfoTypeEnum::UNDEFINED_IT
        }
    }

    impl Pb_InfoTypeEnum {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Pb_InfoTypeEnum>("pb_Body_InfoMessage.pb_InfoTypeEnum")
        }
    }
}

// @@protoc_insertion_point(message:image_analysis.pb_Body_GetConfigFile_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pb_Body_GetConfigFile_Response {
    // message fields
    // @@protoc_insertion_point(field:image_analysis.pb_Body_GetConfigFile_Response.config_file_name)
    pub config_file_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:image_analysis.pb_Body_GetConfigFile_Response.config_content_json)
    pub config_content_json: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:image_analysis.pb_Body_GetConfigFile_Response.available_config_files)
    pub available_config_files: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:image_analysis.pb_Body_GetConfigFile_Response.current_default_file)
    pub current_default_file: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:image_analysis.pb_Body_GetConfigFile_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pb_Body_GetConfigFile_Response {
    fn default() -> &'a Pb_Body_GetConfigFile_Response {
        <Pb_Body_GetConfigFile_Response as ::protobuf::Message>::default_instance()
    }
}

impl Pb_Body_GetConfigFile_Response {
    pub fn new() -> Pb_Body_GetConfigFile_Response {
        ::std::default::Default::default()
    }

    // required string config_file_name = 1;

    pub fn config_file_name(&self) -> &str {
        match self.config_file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_config_file_name(&mut self) {
        self.config_file_name = ::std::option::Option::None;
    }

    pub fn has_config_file_name(&self) -> bool {
        self.config_file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config_file_name(&mut self, v: ::std::string::String) {
        self.config_file_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config_file_name(&mut self) -> &mut ::std::string::String {
        if self.config_file_name.is_none() {
            self.config_file_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.config_file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_config_file_name(&mut self) -> ::std::string::String {
        self.config_file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string config_content_json = 2;

    pub fn config_content_json(&self) -> &str {
        match self.config_content_json.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_config_content_json(&mut self) {
        self.config_content_json = ::std::option::Option::None;
    }

    pub fn has_config_content_json(&self) -> bool {
        self.config_content_json.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config_content_json(&mut self, v: ::std::string::String) {
        self.config_content_json = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config_content_json(&mut self) -> &mut ::std::string::String {
        if self.config_content_json.is_none() {
            self.config_content_json = ::std::option::Option::Some(::std::string::String::new());
        }
        self.config_content_json.as_mut().unwrap()
    }

    // Take field
    pub fn take_config_content_json(&mut self) -> ::std::string::String {
        self.config_content_json.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string current_default_file = 4;

    pub fn current_default_file(&self) -> &str {
        match self.current_default_file.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_current_default_file(&mut self) {
        self.current_default_file = ::std::option::Option::None;
    }

    pub fn has_current_default_file(&self) -> bool {
        self.current_default_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_default_file(&mut self, v: ::std::string::String) {
        self.current_default_file = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_current_default_file(&mut self) -> &mut ::std::string::String {
        if self.current_default_file.is_none() {
            self.current_default_file = ::std::option::Option::Some(::std::string::String::new());
        }
        self.current_default_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_current_default_file(&mut self) -> ::std::string::String {
        self.current_default_file.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "config_file_name",
            |m: &Pb_Body_GetConfigFile_Response| { &m.config_file_name },
            |m: &mut Pb_Body_GetConfigFile_Response| { &mut m.config_file_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "config_content_json",
            |m: &Pb_Body_GetConfigFile_Response| { &m.config_content_json },
            |m: &mut Pb_Body_GetConfigFile_Response| { &mut m.config_content_json },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "available_config_files",
            |m: &Pb_Body_GetConfigFile_Response| { &m.available_config_files },
            |m: &mut Pb_Body_GetConfigFile_Response| { &mut m.available_config_files },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_default_file",
            |m: &Pb_Body_GetConfigFile_Response| { &m.current_default_file },
            |m: &mut Pb_Body_GetConfigFile_Response| { &mut m.current_default_file },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_Body_GetConfigFile_Response>(
            "pb_Body_GetConfigFile_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pb_Body_GetConfigFile_Response {
    const NAME: &'static str = "pb_Body_GetConfigFile_Response";

    fn is_initialized(&self) -> bool {
        if self.config_file_name.is_none() {
            return false;
        }
        if self.config_content_json.is_none() {
            return false;
        }
        if self.current_default_file.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.config_file_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.config_content_json = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.available_config_files.push(is.read_string()?);
                },
                34 => {
                    self.current_default_file = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.config_file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.config_content_json.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.available_config_files {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(v) = self.current_default_file.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.config_file_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.config_content_json.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.available_config_files {
            os.write_string(3, &v)?;
        };
        if let Some(v) = self.current_default_file.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pb_Body_GetConfigFile_Response {
        Pb_Body_GetConfigFile_Response::new()
    }

    fn clear(&mut self) {
        self.config_file_name = ::std::option::Option::None;
        self.config_content_json = ::std::option::Option::None;
        self.available_config_files.clear();
        self.current_default_file = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pb_Body_GetConfigFile_Response {
        static instance: Pb_Body_GetConfigFile_Response = Pb_Body_GetConfigFile_Response {
            config_file_name: ::std::option::Option::None,
            config_content_json: ::std::option::Option::None,
            available_config_files: ::std::vec::Vec::new(),
            current_default_file: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pb_Body_GetConfigFile_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("pb_Body_GetConfigFile_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pb_Body_GetConfigFile_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pb_Body_GetConfigFile_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:image_analysis.pb_Body_SetConfigFile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pb_Body_SetConfigFile {
    // message fields
    // @@protoc_insertion_point(field:image_analysis.pb_Body_SetConfigFile.new_config_file_name)
    pub new_config_file_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:image_analysis.pb_Body_SetConfigFile.set_as_default)
    pub set_as_default: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:image_analysis.pb_Body_SetConfigFile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pb_Body_SetConfigFile {
    fn default() -> &'a Pb_Body_SetConfigFile {
        <Pb_Body_SetConfigFile as ::protobuf::Message>::default_instance()
    }
}

impl Pb_Body_SetConfigFile {
    pub fn new() -> Pb_Body_SetConfigFile {
        ::std::default::Default::default()
    }

    // required string new_config_file_name = 1;

    pub fn new_config_file_name(&self) -> &str {
        match self.new_config_file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_new_config_file_name(&mut self) {
        self.new_config_file_name = ::std::option::Option::None;
    }

    pub fn has_new_config_file_name(&self) -> bool {
        self.new_config_file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_config_file_name(&mut self, v: ::std::string::String) {
        self.new_config_file_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_new_config_file_name(&mut self) -> &mut ::std::string::String {
        if self.new_config_file_name.is_none() {
            self.new_config_file_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.new_config_file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_new_config_file_name(&mut self) -> ::std::string::String {
        self.new_config_file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bool set_as_default = 2;

    pub fn set_as_default(&self) -> bool {
        self.set_as_default.unwrap_or(false)
    }

    pub fn clear_set_as_default(&mut self) {
        self.set_as_default = ::std::option::Option::None;
    }

    pub fn has_set_as_default(&self) -> bool {
        self.set_as_default.is_some()
    }

    // Param is passed by value, moved
    pub fn set_set_as_default(&mut self, v: bool) {
        self.set_as_default = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "new_config_file_name",
            |m: &Pb_Body_SetConfigFile| { &m.new_config_file_name },
            |m: &mut Pb_Body_SetConfigFile| { &mut m.new_config_file_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "set_as_default",
            |m: &Pb_Body_SetConfigFile| { &m.set_as_default },
            |m: &mut Pb_Body_SetConfigFile| { &mut m.set_as_default },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_Body_SetConfigFile>(
            "pb_Body_SetConfigFile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pb_Body_SetConfigFile {
    const NAME: &'static str = "pb_Body_SetConfigFile";

    fn is_initialized(&self) -> bool {
        if self.new_config_file_name.is_none() {
            return false;
        }
        if self.set_as_default.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.new_config_file_name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.set_as_default = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.new_config_file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.set_as_default {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.new_config_file_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.set_as_default {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pb_Body_SetConfigFile {
        Pb_Body_SetConfigFile::new()
    }

    fn clear(&mut self) {
        self.new_config_file_name = ::std::option::Option::None;
        self.set_as_default = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pb_Body_SetConfigFile {
        static instance: Pb_Body_SetConfigFile = Pb_Body_SetConfigFile {
            new_config_file_name: ::std::option::Option::None,
            set_as_default: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pb_Body_SetConfigFile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("pb_Body_SetConfigFile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pb_Body_SetConfigFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pb_Body_SetConfigFile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:image_analysis.pb_Body_ModifyConfigFile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pb_Body_ModifyConfigFile {
    // message fields
    // @@protoc_insertion_point(field:image_analysis.pb_Body_ModifyConfigFile.config_file_name)
    pub config_file_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:image_analysis.pb_Body_ModifyConfigFile.config_content_json)
    pub config_content_json: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:image_analysis.pb_Body_ModifyConfigFile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pb_Body_ModifyConfigFile {
    fn default() -> &'a Pb_Body_ModifyConfigFile {
        <Pb_Body_ModifyConfigFile as ::protobuf::Message>::default_instance()
    }
}

impl Pb_Body_ModifyConfigFile {
    pub fn new() -> Pb_Body_ModifyConfigFile {
        ::std::default::Default::default()
    }

    // required string config_file_name = 1;

    pub fn config_file_name(&self) -> &str {
        match self.config_file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_config_file_name(&mut self) {
        self.config_file_name = ::std::option::Option::None;
    }

    pub fn has_config_file_name(&self) -> bool {
        self.config_file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config_file_name(&mut self, v: ::std::string::String) {
        self.config_file_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config_file_name(&mut self) -> &mut ::std::string::String {
        if self.config_file_name.is_none() {
            self.config_file_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.config_file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_config_file_name(&mut self) -> ::std::string::String {
        self.config_file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string config_content_json = 2;

    pub fn config_content_json(&self) -> &str {
        match self.config_content_json.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_config_content_json(&mut self) {
        self.config_content_json = ::std::option::Option::None;
    }

    pub fn has_config_content_json(&self) -> bool {
        self.config_content_json.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config_content_json(&mut self, v: ::std::string::String) {
        self.config_content_json = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config_content_json(&mut self) -> &mut ::std::string::String {
        if self.config_content_json.is_none() {
            self.config_content_json = ::std::option::Option::Some(::std::string::String::new());
        }
        self.config_content_json.as_mut().unwrap()
    }

    // Take field
    pub fn take_config_content_json(&mut self) -> ::std::string::String {
        self.config_content_json.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "config_file_name",
            |m: &Pb_Body_ModifyConfigFile| { &m.config_file_name },
            |m: &mut Pb_Body_ModifyConfigFile| { &mut m.config_file_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "config_content_json",
            |m: &Pb_Body_ModifyConfigFile| { &m.config_content_json },
            |m: &mut Pb_Body_ModifyConfigFile| { &mut m.config_content_json },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_Body_ModifyConfigFile>(
            "pb_Body_ModifyConfigFile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pb_Body_ModifyConfigFile {
    const NAME: &'static str = "pb_Body_ModifyConfigFile";

    fn is_initialized(&self) -> bool {
        if self.config_file_name.is_none() {
            return false;
        }
        if self.config_content_json.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.config_file_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.config_content_json = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.config_file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.config_content_json.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.config_file_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.config_content_json.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pb_Body_ModifyConfigFile {
        Pb_Body_ModifyConfigFile::new()
    }

    fn clear(&mut self) {
        self.config_file_name = ::std::option::Option::None;
        self.config_content_json = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pb_Body_ModifyConfigFile {
        static instance: Pb_Body_ModifyConfigFile = Pb_Body_ModifyConfigFile {
            config_file_name: ::std::option::Option::None,
            config_content_json: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pb_Body_ModifyConfigFile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("pb_Body_ModifyConfigFile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pb_Body_ModifyConfigFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pb_Body_ModifyConfigFile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:image_analysis.pb_Body_GetStatistics_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Pb_Body_GetStatistics_Response {
    // message fields
    // @@protoc_insertion_point(field:image_analysis.pb_Body_GetStatistics_Response.statistics_csv)
    pub statistics_csv: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:image_analysis.pb_Body_GetStatistics_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Pb_Body_GetStatistics_Response {
    fn default() -> &'a Pb_Body_GetStatistics_Response {
        <Pb_Body_GetStatistics_Response as ::protobuf::Message>::default_instance()
    }
}

impl Pb_Body_GetStatistics_Response {
    pub fn new() -> Pb_Body_GetStatistics_Response {
        ::std::default::Default::default()
    }

    // required string statistics_csv = 1;

    pub fn statistics_csv(&self) -> &str {
        match self.statistics_csv.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_statistics_csv(&mut self) {
        self.statistics_csv = ::std::option::Option::None;
    }

    pub fn has_statistics_csv(&self) -> bool {
        self.statistics_csv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statistics_csv(&mut self, v: ::std::string::String) {
        self.statistics_csv = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statistics_csv(&mut self) -> &mut ::std::string::String {
        if self.statistics_csv.is_none() {
            self.statistics_csv = ::std::option::Option::Some(::std::string::String::new());
        }
        self.statistics_csv.as_mut().unwrap()
    }

    // Take field
    pub fn take_statistics_csv(&mut self) -> ::std::string::String {
        self.statistics_csv.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "statistics_csv",
            |m: &Pb_Body_GetStatistics_Response| { &m.statistics_csv },
            |m: &mut Pb_Body_GetStatistics_Response| { &mut m.statistics_csv },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Pb_Body_GetStatistics_Response>(
            "pb_Body_GetStatistics_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Pb_Body_GetStatistics_Response {
    const NAME: &'static str = "pb_Body_GetStatistics_Response";

    fn is_initialized(&self) -> bool {
        if self.statistics_csv.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.statistics_csv = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.statistics_csv.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.statistics_csv.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Pb_Body_GetStatistics_Response {
        Pb_Body_GetStatistics_Response::new()
    }

    fn clear(&mut self) {
        self.statistics_csv = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Pb_Body_GetStatistics_Response {
        static instance: Pb_Body_GetStatistics_Response = Pb_Body_GetStatistics_Response {
            statistics_csv: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Pb_Body_GetStatistics_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("pb_Body_GetStatistics_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Pb_Body_GetStatistics_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pb_Body_GetStatistics_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:image_analysis.DataTypeEnum)
pub enum DataTypeEnum {
    // @@protoc_insertion_point(enum_value:image_analysis.DataTypeEnum.UNDEFINED_DT)
    UNDEFINED_DT = 0,
    // @@protoc_insertion_point(enum_value:image_analysis.DataTypeEnum.STRING_DT)
    STRING_DT = 1,
    // @@protoc_insertion_point(enum_value:image_analysis.DataTypeEnum.DOUBLE_DT)
    DOUBLE_DT = 2,
    // @@protoc_insertion_point(enum_value:image_analysis.DataTypeEnum.JSON_DT)
    JSON_DT = 3,
}

impl ::protobuf::Enum for DataTypeEnum {
    const NAME: &'static str = "DataTypeEnum";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DataTypeEnum> {
        match value {
            0 => ::std::option::Option::Some(DataTypeEnum::UNDEFINED_DT),
            1 => ::std::option::Option::Some(DataTypeEnum::STRING_DT),
            2 => ::std::option::Option::Some(DataTypeEnum::DOUBLE_DT),
            3 => ::std::option::Option::Some(DataTypeEnum::JSON_DT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DataTypeEnum> {
        match str {
            "UNDEFINED_DT" => ::std::option::Option::Some(DataTypeEnum::UNDEFINED_DT),
            "STRING_DT" => ::std::option::Option::Some(DataTypeEnum::STRING_DT),
            "DOUBLE_DT" => ::std::option::Option::Some(DataTypeEnum::DOUBLE_DT),
            "JSON_DT" => ::std::option::Option::Some(DataTypeEnum::JSON_DT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DataTypeEnum] = &[
        DataTypeEnum::UNDEFINED_DT,
        DataTypeEnum::STRING_DT,
        DataTypeEnum::DOUBLE_DT,
        DataTypeEnum::JSON_DT,
    ];
}

impl ::protobuf::EnumFull for DataTypeEnum {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DataTypeEnum").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DataTypeEnum {
    fn default() -> Self {
        DataTypeEnum::UNDEFINED_DT
    }
}

impl DataTypeEnum {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DataTypeEnum>("DataTypeEnum")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n$ImageAnalysis_ProtobufMessages.proto\x12\x0eimage_analysis\"\x91\x01\
    \n\x1bpb_ProtocolVersionDetection\x127\n\x16protocol_version_major\x18\
    \x01\x20\x01(\x05:\x011R\x14protocolVersionMajor\x129\n\x16protocol_vers\
    ion_minor\x18\x02\x20\x01(\x05:\x03119R\x14protocolVersionMinor\"\xcc\
    \x06\n\x10pb_MessageHeader\x12O\n\x0cmessage_type\x18\x01\x20\x02(\x0e2,\
    .image_analysis.pb_MessageHeader.MessageTypeR\x0bmessageType\x12\x1a\n\
    \x08response\x18\x02\x20\x02(\x08R\x08response\x12'\n\x0fmessage_counter\
    \x18\x03\x20\x02(\rR\x0emessageCounter\x12*\n\x11size_message_body\x18\
    \x04\x20\x02(\rR\x0fsizeMessageBody\x124\n\x16protocol_version_major\x18\
    \x05\x20\x01(\x05R\x14protocolVersionMajor\x124\n\x16protocol_version_mi\
    nor\x18\x06\x20\x01(\x05R\x14protocolVersionMinor\x12(\n\x10timestamp_ut\
    c_ms\x18\x07\x20\x02(\x03R\x0etimestampUtcMs\x12\x1d\n\nerror_code\x18\
    \x08\x20\x02(\x05R\terrorCode\x12\x1b\n\tinfo_text\x18\t\x20\x01(\tR\x08\
    infoText\x12\x1d\n\nint_values\x18\n\x20\x03(\x05R\tintValues\x12#\n\rdo\
    uble_values\x18\x0b\x20\x03(\x01R\x0cdoubleValues\x12#\n\rstring_values\
    \x18\x0c\x20\x03(\tR\x0cstringValues\"\xba\x02\n\x0bMessageType\x12\r\n\
    \tUNDEFINED\x10\0\x12\r\n\tGETSTATUS\x10\x01\x12\x0e\n\nGETVERSION\x10\
    \x02\x12\x08\n\x04INIT\x10\x03\x12\x0e\n\nGETPRESETS\x10\x04\x12\x11\n\r\
    GETPRESETINFO\x10\x05\x12\r\n\tSETCONFIG\x10\x06\x12\x10\n\x0cREMOVECONF\
    IG\x10\x07\x12\x13\n\x0fGETCONFIGPARAMS\x10\x08\x12\x13\n\x0fSETCONFIGPA\
    RAMS\x10\t\x12\x10\n\x0cANALYZEIMAGE\x10\n\x12\x0f\n\x0bIMAGERESULT\x10\
    \x0b\x12\x0f\n\x0bINFOMESSAGE\x10\x0c\x12\x12\n\rGETCONFIGFILE\x10\xe8\
    \x07\x12\x12\n\rSETCONFIGFILE\x10\xe9\x07\x12\x15\n\x10MODIFYCONFIGFILE\
    \x10\xea\x07\x12\x12\n\rGETSTATISTICS\x10\xeb\x07\"4\n\x0cpb_Body_Init\
    \x12$\n\x0einit_hash_code\x18\x01\x20\x02(\tR\x0cinitHashCode\"\x89\x03\
    \n\x1apb_Body_GetStatus_Response\x12$\n\x0einit_hash_code\x18\x01\x20\
    \x02(\tR\x0cinitHashCode\x121\n\x15init_timestamp_utc_ms\x18\x02\x20\x02\
    (\x03R\x12initTimestampUtcMs\x12-\n\x12configuration_sets\x18\x03\x20\
    \x03(\tR\x11configurationSets\x12h\n\x11images_in_process\x18\x04\x20\
    \x03(\x0b2<.image_analysis.pb_Body_GetStatus_Response.pb_ImageInProcessR\
    \x0fimagesInProcess\x1ay\n\x11pb_ImageInProcess\x12.\n\x13serial_number_\
    image\x18\x01\x20\x02(\tR\x11serialNumberImage\x124\n\x16configuration_s\
    et_name\x18\x02\x20\x02(\tR\x14configurationSetName\"i\n\x1bpb_Body_GetV\
    ersion_Response\x12!\n\x0cprogram_name\x18\x01\x20\x02(\tR\x0bprogramNam\
    e\x12'\n\x0fprogram_version\x18\x02\x20\x02(\tR\x0eprogramVersion\"G\n\
    \x1bpb_Body_GetPresets_Response\x12(\n\x10preset_name_list\x18\x01\x20\
    \x03(\tR\x0epresetNameList\"8\n\x15pb_Body_GetPresetInfo\x12\x1f\n\x0bpr\
    eset_name\x18\x01\x20\x02(\tR\npresetName\"\xd4\x06\n\x1epb_Body_GetPres\
    etInfo_Response\x12]\n\x0bpreset_info\x18\x01\x20\x01(\x0b2<.image_analy\
    sis.pb_Body_GetPresetInfo_Response.pb_PresetItemR\npresetInfo\x1a:\n\x0e\
    pb_AddInfoItem\x12\x12\n\x04name\x18\x01\x20\x02(\tR\x04name\x12\x14\n\
    \x05value\x18\x02\x20\x02(\tR\x05value\x1a\xe3\x01\n\x10pb_ParamInfoItem\
    \x12\x1d\n\nparam_name\x18\x01\x20\x02(\tR\tparamName\x12F\n\x08datatype\
    \x18\x02\x20\x02(\x0e2\x1c.image_analysis.DataTypeEnum:\x0cUNDEFINED_DTR\
    \x08datatype\x12h\n\tdirection\x18\x03\x20\x02(\x0e2<.image_analysis.pb_\
    Body_GetPresetInfo_Response.DirectionEnum:\x0cUNDEFINED_DRR\tdirection\
    \x1a\xe7\x02\n\rpb_PresetItem\x12\x1f\n\x0bpreset_name\x18\x01\x20\x02(\
    \tR\npresetName\x12\x12\n\x04date\x18\x02\x20\x01(\tR\x04date\x12\x18\n\
    \x07version\x18\x03\x20\x01(\tR\x07version\x12\x18\n\x07comment\x18\x04\
    \x20\x01(\tR\x07comment\x12#\n\rfeature_types\x18\x05\x20\x03(\tR\x0cfea\
    tureTypes\x12h\n\x10additional_infos\x18\x06\x20\x03(\x0b2=.image_analys\
    is.pb_Body_GetPresetInfo_Response.pb_AddInfoItemR\x0fadditionalInfos\x12\
    ^\n\nparam_list\x18\x07\x20\x03(\x0b2?.image_analysis.pb_Body_GetPresetI\
    nfo_Response.pb_ParamInfoItemR\tparamList\"G\n\rDirectionEnum\x12\x10\n\
    \x0cUNDEFINED_DR\x10\0\x12\t\n\x05IN_DR\x10\x01\x12\n\n\x06OUT_DR\x10\
    \x02\x12\r\n\tIN_OUT_DR\x10\x03\"\xd8\x01\n\x0epb_ConfigParam\x12\x1d\n\
    \nparam_name\x18\x01\x20\x02(\tR\tparamName\x12F\n\x08datatype\x18\x02\
    \x20\x02(\x0e2\x1c.image_analysis.DataTypeEnum:\x0cUNDEFINED_DTR\x08data\
    type\x12\x1d\n\nval_string\x18\x03\x20\x01(\tR\tvalString\x12\x19\n\x08v\
    al_json\x18\x04\x20\x01(\tR\x07valJson\x12%\n\nval_double\x18\x05\x20\
    \x01(\x01:\x06-1e+99R\tvalDouble\"\xb0\x05\n\x11pb_Body_SetConfig\x12%\n\
    \x0econfigset_name\x18\x01\x20\x02(\tR\rconfigsetName\x12J\n\tcell_info\
    \x18\x02\x20\x01(\x0b2-.image_analysis.pb_Body_SetConfig.pb_CellInfoR\
    \x08cellInfo\x12\x1f\n\x0bpreset_name\x18\x03\x20\x01(\tR\npresetName\
    \x12C\n\rconfig_params\x18\x04\x20\x03(\x0b2\x1e.image_analysis.pb_Confi\
    gParamR\x0cconfigParams\x1a\xc1\x03\n\x0bpb_CellInfo\x12%\n\x0cbusbar_co\
    unt\x18\x01\x20\x01(\x05:\x02-1R\x0bbusbarCount\x12\x83\x01\n\x12busbar_\
    orientation\x18\x02\x20\x01(\x0e2F.image_analysis.pb_Body_SetConfig.pb_C\
    ellInfo.pb_BusbarOrientationEnum:\x0cUNDEFINED_BOR\x11busbarOrientation\
    \x12q\n\x0ccrystal_type\x18\x03\x20\x01(\x0e2@.image_analysis.pb_Body_Se\
    tConfig.pb_CellInfo.pb_CrystalTypeEnum:\x0cUNDEFINED_CTR\x0bcrystalType\
    \"P\n\x18pb_BusbarOrientationEnum\x12\x10\n\x0cUNDEFINED_BO\x10\0\x12\
    \x11\n\rHORIZONTAL_BO\x10\x01\x12\x0f\n\x0bVERTICAL_BO\x10\x02\"@\n\x12p\
    b_CrystalTypeEnum\x12\x10\n\x0cUNDEFINED_CT\x10\0\x12\x0b\n\x07MONO_CT\
    \x10\x01\x12\x0b\n\x07POLY_CT\x10\x02\"=\n\x14pb_Body_RemoveConfig\x12%\
    \n\x0econfigset_name\x18\x01\x20\x02(\tR\rconfigsetName\"h\n\x17pb_Body_\
    GetConfigParams\x12%\n\x0econfigset_name\x18\x01\x20\x02(\tR\rconfigsetN\
    ame\x12&\n\x0fparam_name_list\x18\x02\x20\x03(\tR\rparamNameList\"\x8e\
    \x01\n\x20pb_Body_GetConfigParams_Response\x12%\n\x0econfigset_name\x18\
    \x01\x20\x02(\tR\rconfigsetName\x12C\n\rconfig_params\x18\x02\x20\x03(\
    \x0b2\x1e.image_analysis.pb_ConfigParamR\x0cconfigParams\"\x85\x01\n\x17\
    pb_Body_SetConfigParams\x12%\n\x0econfigset_name\x18\x01\x20\x02(\tR\rco\
    nfigsetName\x12C\n\rconfig_params\x18\x02\x20\x03(\x0b2\x1e.image_analys\
    is.pb_ConfigParamR\x0cconfigParams\"\xc1\x02\n\x0cpb_ImageData\x12Z\n\
    \x11image_file_format\x18\x01\x20\x02(\x0e2..image_analysis.pb_ImageData\
    .pb_FileFormatEnumR\x0fimageFileFormat\x12\x1d\n\nimage_data\x18\x02\x20\
    \x01(\x0cR\timageData\x12\x18\n\x05width\x18\x03\x20\x01(\x05:\x02-1R\
    \x05width\x12\x1a\n\x06height\x18\x04\x20\x01(\x05:\x02-1R\x06height\x12\
    \x1e\n\x08bitdepth\x18\x05\x20\x01(\x05:\x02-1R\x08bitdepth\"`\n\x11pb_F\
    ileFormatEnum\x12\x10\n\x0cUNDEFINED_FF\x10\0\x12\n\n\x06PNG_FF\x10\x01\
    \x12\n\n\x06JPG_FF\x10\x02\x12\n\n\x06RAW_FF\x10\x03\x12\t\n\x05BYTES\
    \x10d\x12\n\n\x06TIF_FF\x10e\"X\n\x0epb_MultiImages\x12\x12\n\x04name\
    \x18\x01\x20\x02(\tR\x04name\x122\n\x05image\x18\x02\x20\x01(\x0b2\x1c.i\
    mage_analysis.pb_ImageDataR\x05image\"\xd1\x02\n\x11pb_AdditionalData\
    \x12X\n\x0enumeric_values\x18\x01\x20\x03(\x0b21.image_analysis.pb_Addit\
    ionalData.pb_NumericValueR\rnumericValues\x12U\n\rstring_values\x18\x02\
    \x20\x03(\x0b20.image_analysis.pb_AdditionalData.pb_StringValueR\x0cstri\
    ngValues\x1aO\n\x0fpb_NumericValue\x12\x12\n\x04name\x18\x01\x20\x02(\tR\
    \x04name\x12\x12\n\x04unit\x18\x02\x20\x02(\tR\x04unit\x12\x14\n\x05valu\
    e\x18\x03\x20\x02(\x01R\x05value\x1a:\n\x0epb_StringValue\x12\x12\n\x04n\
    ame\x18\x01\x20\x02(\tR\x04name\x12\x14\n\x05value\x18\x02\x20\x02(\tR\
    \x05value\"\xb0\x02\n\x14pb_Body_AnalyzeImage\x12.\n\x13serial_number_im\
    age\x18\x01\x20\x02(\tR\x11serialNumberImage\x12%\n\x0econfigset_name\
    \x18\x02\x20\x02(\tR\rconfigsetName\x122\n\x05image\x18\x03\x20\x01(\x0b\
    2\x1c.image_analysis.pb_ImageDataR\x05image\x12J\n\x0fadditional_data\
    \x18\x04\x20\x01(\x0b2!.image_analysis.pb_AdditionalDataR\x0eadditionalD\
    ata\x12A\n\x0cmulti_images\x18\x05\x20\x03(\x0b2\x1e.image_analysis.pb_M\
    ultiImagesR\x0bmultiImages\"\xff\x18\n\x13pb_Body_ImageResult\x12.\n\x13\
    serial_number_image\x18\x01\x20\x02(\tR\x11serialNumberImage\x12%\n\x0ec\
    onfigset_name\x18\x02\x20\x02(\tR\rconfigsetName\x12J\n\x08features\x18\
    \x03\x20\x03(\x0b2..image_analysis.pb_Body_ImageResult.pb_FeatureR\x08fe\
    atures\x12m\n\x14image_classification\x18\x04\x20\x01(\x0b2:.image_analy\
    sis.pb_Body_ImageResult.pb_ImageClassificationR\x13imageClassification\
    \x12=\n\x0bimage_plain\x18\x05\x20\x01(\x0b2\x1c.image_analysis.pb_Image\
    DataR\nimagePlain\x12C\n\x0eimage_overlaid\x18\x06\x20\x01(\x0b2\x1c.ima\
    ge_analysis.pb_ImageDataR\rimageOverlaid\x12L\n\x12multi_images_plain\
    \x18\x07\x20\x03(\x0b2\x1e.image_analysis.pb_MultiImagesR\x10multiImages\
    Plain\x12R\n\x15multi_images_overlaid\x18\x08\x20\x03(\x0b2\x1e.image_an\
    alysis.pb_MultiImagesR\x13multiImagesOverlaid\x1aa\n\x07pb_Rect\x12\x13\
    \n\x05x_pos\x18\x01\x20\x01(\x01R\x04xPos\x12\x13\n\x05y_pos\x18\x02\x20\
    \x01(\x01R\x04yPos\x12\x14\n\x05width\x18\x03\x20\x01(\x01R\x05width\x12\
    \x16\n\x06height\x18\x04\x20\x01(\x01R\x06height\x1a+\n\rpb_DENK_Point\
    \x12\x0c\n\x01x\x18\x01\x20\x01(\x01R\x01x\x12\x0c\n\x01y\x18\x02\x20\
    \x01(\x01R\x01y\x1a\x96\x01\n\x1apb_DENK_MinimalBoundingBox\x12\x19\n\
    \x08center_x\x18\x01\x20\x01(\x01R\x07centerX\x12\x19\n\x08center_y\x18\
    \x02\x20\x01(\x01R\x07centerY\x12\x14\n\x05width\x18\x03\x20\x01(\x01R\
    \x05width\x12\x16\n\x06height\x18\x04\x20\x01(\x01R\x06height\x12\x14\n\
    \x05angle\x18\x05\x20\x01(\x01R\x05angle\x1aV\n\x14pb_DENK_OcrCharacter\
    \x12\x1c\n\tcharacter\x18\x01\x20\x01(\tR\tcharacter\x12\x20\n\x0bprobab\
    ility\x18\x02\x20\x01(\x01R\x0bprobability\x1a}\n\x1cpb_DENK_OcrCharacte\
    rPosition\x12]\n\rocr_character\x18\x01\x20\x03(\x0b28.image_analysis.pb\
    _Body_ImageResult.pb_DENK_OcrCharacterR\x0cocrCharacter\x1a\xbb\x0b\n\np\
    b_Feature\x12*\n\x11feature_type_name\x18\x01\x20\x02(\tR\x0ffeatureType\
    Name\x12b\n\rfeature_infos\x18\x02\x20\x03(\x0b2=.image_analysis.pb_Body\
    _ImageResult.pb_Feature.pb_FeatureInfoR\x0cfeatureInfos\x12*\n\x11multi_\
    image_names\x18\x03\x20\x03(\tR\x0fmultiImageNames\x12\x18\n\x07section\
    \x18d\x20\x03(\tR\x07section\x12!\n\x0cfiltered_out\x18e\x20\x01(\x08R\
    \x0bfilteredOut\x12\x1e\n\nclassifier\x18f\x20\x01(\x01R\nclassifier\x1a\
    \x93\t\n\x0epb_FeatureInfo\x12S\n\x0foutline_rect_px\x18\x01\x20\x01(\
    \x0b2+.image_analysis.pb_Body_ImageResult.pb_RectR\routlineRectPx\x12(\n\
    \x0bprobability\x18\x02\x20\x01(\x01:\x06-1e+99R\x0bprobability\x12\x1e\
    \n\x06length\x18\x03\x20\x01(\x01:\x06-1e+99R\x06length\x12\x1a\n\x04are\
    a\x18\x04\x20\x01(\x01:\x06-1e+99R\x04area\x12\x1c\n\x05angle\x18\x05\
    \x20\x01(\x01:\x06-1e+99R\x05angle\x12\x1e\n\x06number\x18\x06\x20\x01(\
    \x01:\x06-1e+99R\x06number\x12\x20\n\x07average\x18\x07\x20\x01(\x01:\
    \x06-1e+99R\x07average\x12\x20\n\x07maximum\x18\x08\x20\x01(\x01:\x06-1e\
    +99R\x07maximum\x12\x20\n\x07minimum\x18\t\x20\x01(\x01:\x06-1e+99R\x07m\
    inimum\x12#\n\tarea_edge\x18\n\x20\x01(\x01:\x06-1e+99R\x08areaEdge\x12'\
    \n\x0barea_length\x18\x0b\x20\x01(\x01:\x06-1e+99R\nareaLength\x12*\n\
    \x0cavggrayvalue\x18\r\x20\x01(\x01:\x06-1e+99R\x0cavggrayvalue\x12*\n\
    \x0cmaxgrayvalue\x18\x0e\x20\x01(\x01:\x06-1e+99R\x0cmaxgrayvalue\x12*\n\
    \x0cmingrayvalue\x18\x0f\x20\x01(\x01:\x06-1e+99R\x0cmingrayvalue\x12\
    \x12\n\x02id\x18\x10\x20\x01(\x05:\x02-1R\x02id\x12\x1f\n\x0brelated_ids\
    \x18\x11\x20\x03(\x05R\nrelatedIds\x12\x1c\n\x05width\x18d\x20\x01(\x01:\
    \x06-1e+99R\x05width\x12S\n\x0foutline_rect_mm\x18e\x20\x01(\x0b2+.image\
    _analysis.pb_Body_ImageResult.pb_RectR\routlineRectMm\x12\x10\n\x03uid\
    \x18f\x20\x01(\tR\x03uid\x12!\n\x0crelated_uids\x18g\x20\x03(\tR\x0brela\
    tedUids\x12p\n\x14minimal_bounding_box\x18h\x20\x01(\x0b2>.image_analysi\
    s.pb_Body_ImageResult.pb_DENK_MinimalBoundingBoxR\x12minimalBoundingBox\
    \x12n\n\x1aminimal_bounding_box_point\x18i\x20\x03(\x0b21.image_analysis\
    .pb_Body_ImageResult.pb_DENK_PointR\x17minimalBoundingBoxPoint\x12\x19\n\
    \x08ocr_text\x18j\x20\x01(\tR\x07ocrText\x12v\n\x16ocr_character_positio\
    n\x18k\x20\x03(\x0b2@.image_analysis.pb_Body_ImageResult.pb_DENK_OcrChar\
    acterPositionR\x14ocrCharacterPosition\x1a\xf1\x04\n\x16pb_ImageClassifi\
    cation\x12(\n\x10image_class_name\x18\x01\x20\x01(\tR\x0eimageClassName\
    \x12~\n\x13image_quality_class\x18\x02\x20\x01(\x0e2N.image_analysis.pb_\
    Body_ImageResult.pb_ImageClassification.pb_ImageQualityEnumR\x11imageQua\
    lityClass\x12,\n\x12image_quality_code\x18\x03\x20\x01(\tR\x10imageQuali\
    tyCode\x126\n\x13image_quality_score\x18\x04\x20\x01(\x01:\x06-1e+99R\
    \x11imageQualityScore\x12,\n\x0eimage_ok_score\x18\x05\x20\x01(\x01:\x06\
    -1e+99R\x0cimageOkScore\x125\n\x12image_avggrayvalue\x18\x06\x20\x01(\
    \x01:\x06-1e+99R\x11imageAvggrayvalue\x125\n\x12image_maxgrayvalue\x18\
    \x07\x20\x01(\x01:\x06-1e+99R\x11imageMaxgrayvalue\x125\n\x12image_mingr\
    ayvalue\x18\x08\x20\x01(\x01:\x06-1e+99R\x11imageMingrayvalue\"t\n\x13pb\
    _ImageQualityEnum\x12\x15\n\x11UNDEFINED_QUALITY\x10\0\x12\x14\n\x10NO_I\
    SSUE_QUALITY\x10\x01\x12\x17\n\x13MINOR_ISSUE_QUALITY\x10\x02\x12\x17\n\
    \x13MAJOR_ISSUE_QUALITY\x10\x03\"\x85\x02\n\x13pb_Body_InfoMessage\x12P\
    \n\tinfo_type\x18\x01\x20\x02(\x0e23.image_analysis.pb_Body_InfoMessage.\
    pb_InfoTypeEnumR\x08infoType\x12!\n\x0cnumeric_code\x18\x02\x20\x02(\x05\
    R\x0bnumericCode\x12\x1b\n\tinfo_text\x18\x03\x20\x02(\tR\x08infoText\"\
    \\\n\x0fpb_InfoTypeEnum\x12\x10\n\x0cUNDEFINED_IT\x10\0\x12\x0c\n\x08DEB\
    UG_IT\x10\x01\x12\x0b\n\x07INFO_IT\x10\x02\x12\x0e\n\nWARNING_IT\x10\x03\
    \x12\x0c\n\x08ERROR_IT\x10\x04\"\xe2\x01\n\x1epb_Body_GetConfigFile_Resp\
    onse\x12(\n\x10config_file_name\x18\x01\x20\x02(\tR\x0econfigFileName\
    \x12.\n\x13config_content_json\x18\x02\x20\x02(\tR\x11configContentJson\
    \x124\n\x16available_config_files\x18\x03\x20\x03(\tR\x14availableConfig\
    Files\x120\n\x14current_default_file\x18\x04\x20\x02(\tR\x12currentDefau\
    ltFile\"n\n\x15pb_Body_SetConfigFile\x12/\n\x14new_config_file_name\x18\
    \x01\x20\x02(\tR\x11newConfigFileName\x12$\n\x0eset_as_default\x18\x02\
    \x20\x02(\x08R\x0csetAsDefault\"t\n\x18pb_Body_ModifyConfigFile\x12(\n\
    \x10config_file_name\x18\x01\x20\x02(\tR\x0econfigFileName\x12.\n\x13con\
    fig_content_json\x18\x02\x20\x02(\tR\x11configContentJson\"G\n\x1epb_Bod\
    y_GetStatistics_Response\x12%\n\x0estatistics_csv\x18\x01\x20\x02(\tR\rs\
    tatisticsCsv*K\n\x0cDataTypeEnum\x12\x10\n\x0cUNDEFINED_DT\x10\0\x12\r\n\
    \tSTRING_DT\x10\x01\x12\r\n\tDOUBLE_DT\x10\x02\x12\x0b\n\x07JSON_DT\x10\
    \x03B-Z\x1bdenkproto-go/image-analysis\xaa\x02\rDENK.Proto.IAJ\xd4\xd8\
    \x01\n\x07\x12\x05;\0\x9f\x03\x01\n\xfa\x15\n\x01\x0c\x12\x03;\0\x122\
    \xbb\x02////////////////////////////////////////////////////////////////\
    ////////////////////////////////////\r\n\x20!!!!!!!!!!!\x20change\x20ver\
    sion\x20number\x20in\x20pb_ProtocolVersionDetection\x20when\x20protocol\
    \x20changed\x20!!!!!!!!!!!!!!!!!!!!!\r\n////////////////////////////////\
    ////////////////////////////////////////////////////////////////////\r\n\
    2\r\x20history\x20//\r\n24\x20v1.100\x20\x20\x20(Volker\x20Gutewort)\r\n\
    \x20initial\x20test\x20version\r\n2\x93\x01\x20v1.102\x20\x20\x20(Volker\
    \x20Gutewort)\r\n\x20all\x20tabs\x20converted\x20to\x20spaces\r\n\x20his\
    tory\x20added\r\n\x20changed\x20name\x20and\x20numeric\x20type\x20of\x20\
    timestamp\x20values\x20(uint64\x20-->\x20int64)\r\n2>\x20v1.103\x20\x20\
    \x20(Volker\x20Gutewort)\r\n\x20'failure'\x20changed\x20to\x20'feature'\
    \r\n2\x88\x03\x20v1.105\x20\x20\x20(Volker\x20Gutewort)\r\n\x20ATTENTION\
    :\x20changes\x20are\x20incompatible\x20to\x20previous\x20protocol\x20ver\
    sions\x20!!!!\r\n\x20new\x20message\x20added\x20\"GETPRESETS\"\x20\x20\
    \x20\x20(new\x20message\x20numbering)\r\n\x20message\x20GETCONFIGINFO\
    \x20changed\x20to\x20GETCONFIGPARAMS\r\n\x20new\x20message\x20added\x20S\
    ETCONFIGPARAMS\x20\r\n\x20new\x20message\x20parameters\x20for\x20pb_Body\
    _SetConfig\r\n\x20change\x20of\x20nomenclature\x20of\x20message\x20names\
    \x20of\x20responses\x20(use\x20underscore\x20in\x20front\x20of\x20_Respo\
    nse)\x20\r\n2\xaa\x02\x20v1.107\x20\x20\x20(Volker\x20Gutewort)\r\n\x20A\
    TTENTION:\x20changes\x20are\x20incompatible\x20to\x20previous\x20protoco\
    l\x20versions\x20!!!!\r\n\x20added\x20suffixes\x20to\x20most\x20of\x20th\
    e\x20enum\x20types\x20(otherwise\x20it's\x20possible\x20to\x20get\x20in\
    \x20trouble\x20with\x20some\x20internal\x20names\x20of\x20C++\x20like\
    \x20'IN',\x20'OUT',\x20'ERROR',\x20...)\r\n\x20added\x20classification\
    \x20in\x20IMAGERESULT\x20message\r\n2\xa5\x02\x20v1.109\x20\x20\x20(Volk\
    er\x20Gutewort)\r\n\x20added\x20new\x20optional\x20value\x20\"pb_Body_Im\
    ageResult.pb_ImageClassification.image_quality_score\r\n\x20added\x20new\
    \x20optional\x20value\x20\"pb_Body_ImageResult.pb_ImageClassification.im\
    age_ok_score\r\n\x20changed\x20default\x20value\x20of\x20pb_Body_SetConf\
    ig.pb_ConfigParam.val_double\x20from\x200\x20to\x20-1e99\r\n2\xef\x02\
    \x20v1.111\x20\x20\x20(Volker\x20Gutewort)\r\n\x20ATTENTION:\x20changes\
    \x20are\x20incompatible\x20to\x20previous\x20protocol\x20versions\x20!!!\
    !\r\n\x20defined\x20a\x20sub\x20message\x20pb_ImageData\x20to\x20transpo\
    rt\x20images\x20(can\x20be\x20used\x20in\x20different\x20messages)\r\n\
    \x20pb_Body_AnalyzeImage\x20uses\x20pb_ImageData\x20instead\x20an\x20own\
    \x20bytes\x20array\x20(incompatible\x20to\x20previous\x20versions)\r\n\
    \x20added\x20options\x20to\x20return\x20plain\x20and\x20overlayed\x20ima\
    ges\x20in\x20ImageResult\r\n2\xfc\x01\x20v1.113\x20\x20\x20(Volker\x20Gu\
    tewort)\r\n\x20added\x20new\x20optional\x20feature\x20parameters\x20\x20\
    (area_edge,\x20length_edge,\x20avggrayvalue,\x20maxgrayvalue,\x20mingray\
    value)\r\n\x20added\x20new\x20optional\x20image\x20classification\x20par\
    ameters\x20\x20(image_avggrayvalue,\x20image_maxgrayvalue,\x20image_ming\
    rayvalue)\r\n2\x85\x01\x20v1.115\x20\x20\x20(Volker\x20Gutewort)\r\n\x20\
    added\x20option\x20to\x20send\x20additional\x20data\x20(e.g.\x20Isc,\x20\
    Voc,\x20...)\x20in\x20AnalyzeImage\x20message\x20(pb_AdditionalData)\r\n\
    2e\x20v1.117\x20\x20\x20(Volker\x20Gutewort)\r\n\x20added\x20multiple\
    \x20images\x20support\x20in\x20AnalyzeImage\x20and\x20ImageResult\x20mes\
    sage\r\n2\x86\x01\x20v1.119\x20\x20\x20(Volker\x20Gutewort)\r\n\x20added\
    \x20optional\x20unique\x20ID\x20per\x20feature\x20and\x20possibility\x20\
    to\x20reference\x20to\x20related\x20features\x20(pb_FeatureInfo)\r\n2\
    \xcd\x01****************************************************************\
    ***************************\r\n\x20pb_MessageHeader\r\n*****************\
    ************************************************************************\
    **\r\n\n\x08\n\x01\x02\x12\x03=\0\x17\n\x08\n\x01\x08\x12\x03?\02\n\t\n\
    \x02\x08\x0b\x12\x03?\02\n\x08\n\x01\x08\x12\x03A\0*\n\t\n\x02\x08%\x12\
    \x03A\0*\n\n\n\x02\x04\0\x12\x04C\0F\x01\n\n\n\x03\x04\0\x01\x12\x03C\
    \x08#\n)\n\x04\x04\0\x02\0\x12\x03D\x04E\"\x1c\x20major\x20version\x20of\
    \x20protocol\r\n\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03D\x04\x0c\n\x0c\n\
    \x05\x04\0\x02\0\x05\x12\x03D\r\x12\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03D\
    \x19/\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03D56\n\x0c\n\x05\x04\0\x02\0\x08\
    \x12\x03D7D\n\x0c\n\x05\x04\0\x02\0\x07\x12\x03DBC\n\xa9\x01\n\x04\x04\0\
    \x02\x01\x12\x03E\x04G\"\x9b\x01\x20minor\x20version\x20of\x20protocol\
    \x20-\x203\x20digits\x20starting\x20from\x20100\x20(even\x20minor\x20ver\
    sion\x20(0,2,4,6,8,\x20...)\x20->\x20version\x20in\x20development;\x20\
    \x20odd\x20version\x20-->\x20release\x20version)\r\n\n\x0c\n\x05\x04\0\
    \x02\x01\x04\x12\x03E\x04\x0c\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03E\r\
    \x12\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03E\x19/\n\x0c\n\x05\x04\0\x02\
    \x01\x03\x12\x03E56\n\x0c\n\x05\x04\0\x02\x01\x08\x12\x03E7F\n\x0c\n\x05\
    \x04\0\x02\x01\x07\x12\x03EBE\n\n\n\x02\x04\x01\x12\x04H\0j\x01\n\n\n\
    \x03\x04\x01\x01\x12\x03H\x08\x18\n\x0c\n\x04\x04\x01\x04\0\x12\x04J\x04\
    \\\x05\n\x0c\n\x05\x04\x01\x04\0\x01\x12\x03J\t\x14\n\r\n\x06\x04\x01\
    \x04\0\x02\0\x12\x03K\x08\x1e\n\x0e\n\x07\x04\x01\x04\0\x02\0\x01\x12\
    \x03K\x08\x11\n\x0e\n\x07\x04\x01\x04\0\x02\0\x02\x12\x03K\x1c\x1d\nz\n\
    \x06\x04\x01\x04\0\x02\x01\x12\x03L\x08\x1e\"k\x20GUI\x20->\x20IA\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20send\x20status\x20\
    information\x20(available\x20config\x20sets,\x20image\x20analyses\x20in\
    \x20process,\x20...)\r\n\n\x0e\n\x07\x04\x01\x04\0\x02\x01\x01\x12\x03L\
    \x08\x11\n\x0e\n\x07\x04\x01\x04\0\x02\x01\x02\x12\x03L\x1c\x1d\nO\n\x06\
    \x04\x01\x04\0\x02\x02\x12\x03M\x08\x1e\"@\x20GUI\x20->\x20IA\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20send\x20name\x20and\
    \x20version\x20of\x20the\x20program\r\n\n\x0e\n\x07\x04\x01\x04\0\x02\
    \x02\x01\x12\x03M\x08\x12\n\x0e\n\x07\x04\x01\x04\0\x02\x02\x02\x12\x03M\
    \x1c\x1d\no\n\x06\x04\x01\x04\0\x02\x03\x12\x03N\x08\x1e\"`\x20GUI\x20->\
    \x20IA\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20initiali\
    ze\x20(remove\x20all\x20configurations\x20and\x20image\x20analyses\x20in\
    \x20process)\r\n\n\x0e\n\x07\x04\x01\x04\0\x02\x03\x01\x12\x03N\x08\x0c\
    \n\x0e\n\x07\x04\x01\x04\0\x02\x03\x02\x12\x03N\x1c\x1d\n`\n\x06\x04\x01\
    \x04\0\x02\x04\x12\x03O\x08\x1e\"Q\x20GUI\x20->\x20IA\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20get\x20a\x20list\x20of\x20avai\
    lable\x20configuration\x20presets\x20from\x20IA\r\n\n\x0e\n\x07\x04\x01\
    \x04\0\x02\x04\x01\x12\x03O\x08\x12\n\x0e\n\x07\x04\x01\x04\0\x02\x04\
    \x02\x12\x03O\x1c\x1d\nW\n\x06\x04\x01\x04\0\x02\x05\x12\x03P\x08\x1e\"H\
    \x20GUI\x20->\x20IA\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20/\
    /\x20get\x20detailed\x20information\x20of\x20a\x20preset\x20from\x20IA\r\
    \n\n\x0e\n\x07\x04\x01\x04\0\x02\x05\x01\x12\x03P\x08\x15\n\x0e\n\x07\
    \x04\x01\x04\0\x02\x05\x02\x12\x03P\x1c\x1d\nj\n\x06\x04\x01\x04\0\x02\
    \x06\x12\x03Q\x08\x1e\"[\x20GUI\x20->\x20IA\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20//\x20set\x20the\x20parameter\x20of\x20a\x20new\
    \x20or\x20currently\x20available\x20configuration\r\n\n\x0e\n\x07\x04\
    \x01\x04\0\x02\x06\x01\x12\x03Q\x08\x11\n\x0e\n\x07\x04\x01\x04\0\x02\
    \x06\x02\x12\x03Q\x1c\x1d\n_\n\x06\x04\x01\x04\0\x02\x07\x12\x03R\x08\
    \x1e\"P\x20GUI\x20->\x20IA\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20//\x20removes\x20config\x20set\x20from\x20available\x20configura\
    tion\x20list\r\n\n\x0e\n\x07\x04\x01\x04\0\x02\x07\x01\x12\x03R\x08\x14\
    \n\x0e\n\x07\x04\x01\x04\0\x02\x07\x02\x12\x03R\x1c\x1d\nN\n\x06\x04\x01\
    \x04\0\x02\x08\x12\x03S\x08\x1e\"?\x20GUI\x20->\x20IA\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20asks\x20for\x20a\x20list\x20of\
    \x20parameter\x20values\r\n\n\x0e\n\x07\x04\x01\x04\0\x02\x08\x01\x12\
    \x03S\x08\x17\n\x0e\n\x07\x04\x01\x04\0\x02\x08\x02\x12\x03S\x1c\x1d\nK\
    \n\x06\x04\x01\x04\0\x02\t\x12\x03T\x08\x1e\"<\x20GUI\x20->\x20IA\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20send\x20new\x20con\
    fig\x20parameters\x20to\x20IA\r\n\n\x0e\n\x07\x04\x01\x04\0\x02\t\x01\
    \x12\x03T\x08\x17\n\x0e\n\x07\x04\x01\x04\0\x02\t\x02\x12\x03T\x1c\x1d\n\
    C\n\x06\x04\x01\x04\0\x02\n\x12\x03U\x08\x1f\"4\x20GUI\x20->\x20IA\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20send\x20image\x20f\
    or\x20analyzing\r\n\n\x0e\n\x07\x04\x01\x04\0\x02\n\x01\x12\x03U\x08\x14\
    \n\x0e\n\x07\x04\x01\x04\0\x02\n\x02\x12\x03U\x1c\x1e\nK\n\x06\x04\x01\
    \x04\0\x02\x0b\x12\x03V\x08\x1f\"<\x20IA\x20->\x20GUI\x20\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20send\x20back\x20analysis\x20re\
    sult\x20to\x20GUI\r\n\n\x0e\n\x07\x04\x01\x04\0\x02\x0b\x01\x12\x03V\x08\
    \x13\n\x0e\n\x07\x04\x01\x04\0\x02\x0b\x02\x12\x03V\x1c\x1e\nU\n\x06\x04\
    \x01\x04\0\x02\x0c\x12\x03W\x08\x1f\"F\x20IA\x20->\x20GUI\x20\x20\x20\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20send\x20a\x20notification\
    \x20(will\x20be\x20shown\x20in\x20log)\r\n\n\x0e\n\x07\x04\x01\x04\0\x02\
    \x0c\x01\x12\x03W\x08\x13\n\x0e\n\x07\x04\x01\x04\0\x02\x0c\x02\x12\x03W\
    \x1c\x1e\n}\n\x06\x04\x01\x04\0\x02\r\x12\x03X\x08!\"n\x20GUI\x20->\x20I\
    A\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20Get\x20inform\
    ation\x20on\x20the\x20currently\x20used\x20config\x20file\x20and\x20othe\
    r\x20available\x20config\x20files\r\n\n\x0e\n\x07\x04\x01\x04\0\x02\r\
    \x01\x12\x03X\x08\x15\n\x0e\n\x07\x04\x01\x04\0\x02\r\x02\x12\x03X\x1c\
    \x20\nL\n\x06\x04\x01\x04\0\x02\x0e\x12\x03Y\x08!\"=\x20GUI\x20->\x20IA\
    \x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20Selects\x20a\
    \x20new\x20config\x20file\x20by\x20name\r\n\n\x0e\n\x07\x04\x01\x04\0\
    \x02\x0e\x01\x12\x03Y\x08\x15\n\x0e\n\x07\x04\x01\x04\0\x02\x0e\x02\x12\
    \x03Y\x1c\x20\n^\n\x06\x04\x01\x04\0\x02\x0f\x12\x03Z\x08!\"O\x20GUI\x20\
    ->\x20IA\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x20Overwr\
    ites\x20the\x20current\x20config\x20file\x20with\x20new\x20content\r\n\n\
    \x0e\n\x07\x04\x01\x04\0\x02\x0f\x01\x12\x03Z\x08\x18\n\x0e\n\x07\x04\
    \x01\x04\0\x02\x0f\x02\x12\x03Z\x1c\x20\nO\n\x06\x04\x01\x04\0\x02\x10\
    \x12\x03[\x08!\"@\x20GUI\x20->\x20IA\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20\x20//\x20Get\x20current\x20statistics\x20as\x20CSV\x20strin\
    g\r\n\n\x0e\n\x07\x04\x01\x04\0\x02\x10\x01\x12\x03[\x08\x15\n\x0e\n\x07\
    \x04\x01\x04\0\x02\x10\x02\x12\x03[\x1c\x20\n$\n\x04\x04\x01\x02\0\x12\
    \x03^\x047\"\x17\x20type\x20of\x20this\x20message\r\n\n\x0c\n\x05\x04\
    \x01\x02\0\x04\x12\x03^\x04\x0c\n\x0c\n\x05\x04\x01\x02\0\x06\x12\x03^\r\
    \x18\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03^\x19%\n\x0c\n\x05\x04\x01\x02\
    \0\x03\x12\x03^56\nG\n\x04\x04\x01\x02\x01\x12\x03_\x047\":\x20true/fals\
    e\x20\x20-->\x20is\x20this\x20message\x20a\x20response\x20or\x20a\x20mes\
    sage\r\n\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03_\x04\x0c\n\x0c\n\x05\
    \x04\x01\x02\x01\x05\x12\x03_\r\x11\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\
    \x03_\x19!\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03_56\nE\n\x04\x04\x01\
    \x02\x02\x12\x03`\x047\"8\x20will\x20be\x20increased\x20by\x20one\x20bef\
    ore\x20every\x20message\x20is\x20sent\r\n\n\x0c\n\x05\x04\x01\x02\x02\
    \x04\x12\x03`\x04\x0c\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03`\r\x13\n\
    \x0c\n\x05\x04\x01\x02\x02\x01\x12\x03`\x19(\n\x0c\n\x05\x04\x01\x02\x02\
    \x03\x12\x03`56\nV\n\x04\x04\x01\x02\x03\x12\x03a\x047\"I\x20size\x20of\
    \x20the\x20message\x20body\x20(could\x20be\x20used\x20to\x20jump\x20over\
    \x20unknown\x20messages)\r\n\n\x0c\n\x05\x04\x01\x02\x03\x04\x12\x03a\
    \x04\x0c\n\x0c\n\x05\x04\x01\x02\x03\x05\x12\x03a\r\x13\n\x0c\n\x05\x04\
    \x01\x02\x03\x01\x12\x03a\x19*\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03a5\
    6\n)\n\x04\x04\x01\x02\x04\x12\x03b\x047\"\x1c\x20major\x20version\x20of\
    \x20protocol\r\n\n\x0c\n\x05\x04\x01\x02\x04\x04\x12\x03b\x04\x0c\n\x0c\
    \n\x05\x04\x01\x02\x04\x05\x12\x03b\r\x12\n\x0c\n\x05\x04\x01\x02\x04\
    \x01\x12\x03b\x19/\n\x0c\n\x05\x04\x01\x02\x04\x03\x12\x03b56\n\xa8\x01\
    \n\x04\x04\x01\x02\x05\x12\x03c\x047\"\x9a\x01\x20minor\x20version\x20of\
    \x20protocol\x20-\x203gigits\x20starting\x20from\x20100\x20(even\x20mino\
    r\x20version\x20(0,2,4,6,8,\x20...)\x20->\x20version\x20in\x20developmen\
    t;\x20\x20odd\x20version\x20-->\x20release\x20version)\r\n\n\x0c\n\x05\
    \x04\x01\x02\x05\x04\x12\x03c\x04\x0c\n\x0c\n\x05\x04\x01\x02\x05\x05\
    \x12\x03c\r\x12\n\x0c\n\x05\x04\x01\x02\x05\x01\x12\x03c\x19/\n\x0c\n\
    \x05\x04\x01\x02\x05\x03\x12\x03c56\nM\n\x04\x04\x01\x02\x06\x12\x03d\
    \x047\"@\x20unix\x20like\x20datetime\x20value\x20(UTC)\x20in\x20millisec\
    onds\x20since\x201970/1/1\r\n\n\x0c\n\x05\x04\x01\x02\x06\x04\x12\x03d\
    \x04\x0c\n\x0c\n\x05\x04\x01\x02\x06\x05\x12\x03d\r\x12\n\x0c\n\x05\x04\
    \x01\x02\x06\x01\x12\x03d\x19)\n\x0c\n\x05\x04\x01\x02\x06\x03\x12\x03d5\
    6\nM\n\x04\x04\x01\x02\x07\x12\x03e\x047\"@\x200\x20means\x20no\x20error\
    \x20\x20\x20(negative\x20and\x20positive\x20values\x20are\x20allowed)\r\
    \n\n\x0c\n\x05\x04\x01\x02\x07\x04\x12\x03e\x04\x0c\n\x0c\n\x05\x04\x01\
    \x02\x07\x05\x12\x03e\r\x12\n\x0c\n\x05\x04\x01\x02\x07\x01\x12\x03e\x19\
    #\n\x0c\n\x05\x04\x01\x02\x07\x03\x12\x03e56\n\x0b\n\x04\x04\x01\x02\x08\
    \x12\x03f\x047\n\x0c\n\x05\x04\x01\x02\x08\x04\x12\x03f\x04\x0c\n\x0c\n\
    \x05\x04\x01\x02\x08\x05\x12\x03f\r\x13\n\x0c\n\x05\x04\x01\x02\x08\x01\
    \x12\x03f\x19\"\n\x0c\n\x05\x04\x01\x02\x08\x03\x12\x03f56\nJ\n\x04\x04\
    \x01\x02\t\x12\x03g\x048\"=\x20optional\x20integer\x20values\x20(could\
    \x20be\x20used\x20for\x20debug\x20purposes)\r\n\n\x0c\n\x05\x04\x01\x02\
    \t\x04\x12\x03g\x04\x0c\n\x0c\n\x05\x04\x01\x02\t\x05\x12\x03g\r\x12\n\
    \x0c\n\x05\x04\x01\x02\t\x01\x12\x03g\x19#\n\x0c\n\x05\x04\x01\x02\t\x03\
    \x12\x03g57\nI\n\x04\x04\x01\x02\n\x12\x03h\x048\"<\x20optional\x20doubl\
    e\x20values\x20(could\x20be\x20used\x20for\x20debug\x20purposes)\r\n\n\
    \x0c\n\x05\x04\x01\x02\n\x04\x12\x03h\x04\x0c\n\x0c\n\x05\x04\x01\x02\n\
    \x05\x12\x03h\r\x13\n\x0c\n\x05\x04\x01\x02\n\x01\x12\x03h\x19&\n\x0c\n\
    \x05\x04\x01\x02\n\x03\x12\x03h57\nI\n\x04\x04\x01\x02\x0b\x12\x03i\x048\
    \"<\x20optional\x20string\x20values\x20(could\x20be\x20used\x20for\x20de\
    bug\x20purposes)\r\n\n\x0c\n\x05\x04\x01\x02\x0b\x04\x12\x03i\x04\x0c\n\
    \x0c\n\x05\x04\x01\x02\x0b\x05\x12\x03i\r\x13\n\x0c\n\x05\x04\x01\x02\
    \x0b\x01\x12\x03i\x19&\n\x0c\n\x05\x04\x01\x02\x0b\x03\x12\x03i57\n\n\n\
    \x02\x04\x02\x12\x04n\0p\x01\n\n\n\x03\x04\x02\x01\x12\x03n\x08\x14\nT\n\
    \x04\x04\x02\x02\0\x12\x03o\x047\"G\x20IA\x20have\x20to\x20sent\x20this\
    \x20string\x20back\x20to\x20GUI\x20in\x20pb_Body_GetStatusResponse\r\n\n\
    \x0c\n\x05\x04\x02\x02\0\x04\x12\x03o\x04\x0c\n\x0c\n\x05\x04\x02\x02\0\
    \x05\x12\x03o\r\x13\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03o\x14\"\n\x0c\n\
    \x05\x04\x02\x02\0\x03\x12\x03o56\n\n\n\x02\x04\x03\x12\x04s\0|\x01\n\n\
    \n\x03\x04\x03\x01\x12\x03s\x08\"\n\x0c\n\x04\x04\x03\x03\0\x12\x04t\x04\
    w\x05\n\x0c\n\x05\x04\x03\x03\0\x01\x12\x03t\x0c\x1d\n\r\n\x06\x04\x03\
    \x03\0\x02\0\x12\x03u\x087\n\x0e\n\x07\x04\x03\x03\0\x02\0\x04\x12\x03u\
    \x08\x10\n\x0e\n\x07\x04\x03\x03\0\x02\0\x05\x12\x03u\x11\x17\n\x0e\n\
    \x07\x04\x03\x03\0\x02\0\x01\x12\x03u\x18+\n\x0e\n\x07\x04\x03\x03\0\x02\
    \0\x03\x12\x03u56\n\r\n\x06\x04\x03\x03\0\x02\x01\x12\x03v\x087\n\x0e\n\
    \x07\x04\x03\x03\0\x02\x01\x04\x12\x03v\x08\x10\n\x0e\n\x07\x04\x03\x03\
    \0\x02\x01\x05\x12\x03v\x11\x17\n\x0e\n\x07\x04\x03\x03\0\x02\x01\x01\
    \x12\x03v\x18.\n\x0e\n\x07\x04\x03\x03\0\x02\x01\x03\x12\x03v56\n'\n\x04\
    \x04\x03\x02\0\x12\x03x\x047\"\x1a\x20was\x20set\x20in\x20message\x20INI\
    T\r\n\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03x\x04\x0c\n\x0c\n\x05\x04\x03\
    \x02\0\x05\x12\x03x\r\x13\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03x\x14\"\n\
    \x0c\n\x05\x04\x03\x02\0\x03\x12\x03x56\nv\n\x04\x04\x03\x02\x01\x12\x03\
    y\x047\"i\x20timestamp\x20when\x20program\x20was\x20initialized\x20-\x20\
    unix\x20like\x20datetime\x20value\x20(UTC)\x20in\x20milliseconds\x20sinc\
    e\x201970/1/1\r\n\n\x0c\n\x05\x04\x03\x02\x01\x04\x12\x03y\x04\x0c\n\x0c\
    \n\x05\x04\x03\x02\x01\x05\x12\x03y\r\x12\n\x0c\n\x05\x04\x03\x02\x01\
    \x01\x12\x03y\x13(\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03y56\n5\n\x04\
    \x04\x03\x02\x02\x12\x03z\x047\"(\x20array\x20of\x20available\x20configu\
    ration\x20sets\r\n\n\x0c\n\x05\x04\x03\x02\x02\x04\x12\x03z\x04\x0c\n\
    \x0c\n\x05\x04\x03\x02\x02\x05\x12\x03z\r\x13\n\x0c\n\x05\x04\x03\x02\
    \x02\x01\x12\x03z\x14&\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03z56\n3\n\
    \x04\x04\x03\x02\x03\x12\x03{\x047\"&\x20list\x20of\x20images\x20current\
    ly\x20in\x20process\r\n\n\x0c\n\x05\x04\x03\x02\x03\x04\x12\x03{\x04\x0c\
    \n\x0c\n\x05\x04\x03\x02\x03\x06\x12\x03{\r\x1e\n\x0c\n\x05\x04\x03\x02\
    \x03\x01\x12\x03{\x1f0\n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x03{56\n\x0b\
    \n\x02\x04\x04\x12\x05\x7f\0\x82\x01\x01\n\n\n\x03\x04\x04\x01\x12\x03\
    \x7f\x08#\n$\n\x04\x04\x04\x02\0\x12\x04\x80\x01\x047\"\x16\x20name\x20o\
    f\x20the\x20program\r\n\n\r\n\x05\x04\x04\x02\0\x04\x12\x04\x80\x01\x04\
    \x0c\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\x80\x01\r\x13\n\r\n\x05\x04\x04\
    \x02\0\x01\x12\x04\x80\x01\x14\x20\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\
    \x80\x0156\n-\n\x04\x04\x04\x02\x01\x12\x04\x81\x01\x047\"\x1f\x20versio\
    n:\x20major.minor.release\r\n\n\r\n\x05\x04\x04\x02\x01\x04\x12\x04\x81\
    \x01\x04\x0c\n\r\n\x05\x04\x04\x02\x01\x05\x12\x04\x81\x01\r\x13\n\r\n\
    \x05\x04\x04\x02\x01\x01\x12\x04\x81\x01\x14#\n\r\n\x05\x04\x04\x02\x01\
    \x03\x12\x04\x81\x0156\n\x0c\n\x02\x04\x05\x12\x06\x85\x01\0\x87\x01\x01\
    \n\x0b\n\x03\x04\x05\x01\x12\x04\x85\x01\x08#\n*\n\x04\x04\x05\x02\0\x12\
    \x04\x86\x01\x047\"\x1c\x20list\x20of\x20available\x20presets\r\n\n\r\n\
    \x05\x04\x05\x02\0\x04\x12\x04\x86\x01\x04\x0c\n\r\n\x05\x04\x05\x02\0\
    \x05\x12\x04\x86\x01\r\x13\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\x86\x01\
    \x14$\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\x86\x0156\n\x0c\n\x02\x04\x06\
    \x12\x06\x8a\x01\0\x8c\x01\x01\n\x0b\n\x03\x04\x06\x01\x12\x04\x8a\x01\
    \x08\x1d\nT\n\x04\x04\x06\x02\0\x12\x04\x8b\x01\x047\"F\x20name\x20of\
    \x20the\x20preset\x20of\x20which\x20detailed\x20information\x20should\
    \x20be\x20returned\r\n\n\r\n\x05\x04\x06\x02\0\x04\x12\x04\x8b\x01\x04\
    \x0c\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\x8b\x01\r\x13\n\r\n\x05\x04\x06\
    \x02\0\x01\x12\x04\x8b\x01\x14\x1f\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\
    \x8b\x0156\n\x0c\n\x02\x04\x07\x12\x06\x8e\x01\0\xa9\x01\x01\n\x0b\n\x03\
    \x04\x07\x01\x12\x04\x8e\x01\x08&\n\x0e\n\x04\x04\x07\x03\0\x12\x06\x8f\
    \x01\x04\x92\x01\x05\n\r\n\x05\x04\x07\x03\0\x01\x12\x04\x8f\x01\x0c\x1a\
    \n/\n\x06\x04\x07\x03\0\x02\0\x12\x04\x90\x01\x087\"\x1f\x20name\x20of\
    \x20additional\x20info\x20item\r\n\n\x0f\n\x07\x04\x07\x03\0\x02\0\x04\
    \x12\x04\x90\x01\x08\x10\n\x0f\n\x07\x04\x07\x03\0\x02\0\x05\x12\x04\x90\
    \x01\x11\x17\n\x0f\n\x07\x04\x07\x03\0\x02\0\x01\x12\x04\x90\x01\x18\x1c\
    \n\x0f\n\x07\x04\x07\x03\0\x02\0\x03\x12\x04\x90\x0156\n7\n\x06\x04\x07\
    \x03\0\x02\x01\x12\x04\x91\x01\x087\"'\x20string\x20value\x20of\x20addit\
    ional\x20info\x20item\r\n\n\x0f\n\x07\x04\x07\x03\0\x02\x01\x04\x12\x04\
    \x91\x01\x08\x10\n\x0f\n\x07\x04\x07\x03\0\x02\x01\x05\x12\x04\x91\x01\
    \x11\x17\n\x0f\n\x07\x04\x07\x03\0\x02\x01\x01\x12\x04\x91\x01\x18\x1d\n\
    \x0f\n\x07\x04\x07\x03\0\x02\x01\x03\x12\x04\x91\x0156\n*\n\x04\x04\x07\
    \x04\0\x12\x06\x94\x01\x04\x99\x01\x05\"\x1a\x20communication\x20directi\
    on\r\n\n\r\n\x05\x04\x07\x04\0\x01\x12\x04\x94\x01\t\x16\n\x0e\n\x06\x04\
    \x07\x04\0\x02\0\x12\x04\x95\x01\x08%\n\x0f\n\x07\x04\x07\x04\0\x02\0\
    \x01\x12\x04\x95\x01\x08\x14\n\x0f\n\x07\x04\x07\x04\0\x02\0\x02\x12\x04\
    \x95\x01#$\nF\n\x06\x04\x07\x04\0\x02\x01\x12\x04\x96\x01\x08%\"6\x20par\
    ameter\x20can\x20be\x20set\x20by\x20the\x20GUI\x20(but\x20can't\x20be\
    \x20read)\r\n\n\x0f\n\x07\x04\x07\x04\0\x02\x01\x01\x12\x04\x96\x01\x08\
    \r\n\x0f\n\x07\x04\x07\x04\0\x02\x01\x02\x12\x04\x96\x01#$\nF\n\x06\x04\
    \x07\x04\0\x02\x02\x12\x04\x97\x01\x08%\"6\x20parameter\x20can\x20be\x20\
    read\x20by\x20the\x20GUI\x20(but\x20can't\x20be\x20set)\r\n\n\x0f\n\x07\
    \x04\x07\x04\0\x02\x02\x01\x12\x04\x97\x01\x08\x0e\n\x0f\n\x07\x04\x07\
    \x04\0\x02\x02\x02\x12\x04\x97\x01#$\n;\n\x06\x04\x07\x04\0\x02\x03\x12\
    \x04\x98\x01\x08%\"+\x20parameter\x20can\x20be\x20read\x20and\x20set\x20\
    by\x20the\x20GUI\r\n\n\x0f\n\x07\x04\x07\x04\0\x02\x03\x01\x12\x04\x98\
    \x01\x08\x11\n\x0f\n\x07\x04\x07\x04\0\x02\x03\x02\x12\x04\x98\x01#$\n\
    \x0e\n\x04\x04\x07\x03\x01\x12\x06\x9a\x01\x04\x9e\x01\x05\n\r\n\x05\x04\
    \x07\x03\x01\x01\x12\x04\x9a\x01\x0c\x1c\n)\n\x06\x04\x07\x03\x01\x02\0\
    \x12\x04\x9b\x01\x087\"\x19\x20name\x20of\x20the\x20parameters\r\n\n\x0f\
    \n\x07\x04\x07\x03\x01\x02\0\x04\x12\x04\x9b\x01\x08\x10\n\x0f\n\x07\x04\
    \x07\x03\x01\x02\0\x05\x12\x04\x9b\x01\x11\x17\n\x0f\n\x07\x04\x07\x03\
    \x01\x02\0\x01\x12\x04\x9b\x01\",\n\x0f\n\x07\x04\x07\x03\x01\x02\0\x03\
    \x12\x04\x9b\x0156\n.\n\x06\x04\x07\x03\x01\x02\x01\x12\x04\x9c\x01\x08P\
    \"\x1e\x20data\x20type\x20of\x20this\x20parameter\r\n\n\x0f\n\x07\x04\
    \x07\x03\x01\x02\x01\x04\x12\x04\x9c\x01\x08\x10\n\x0f\n\x07\x04\x07\x03\
    \x01\x02\x01\x06\x12\x04\x9c\x01\x11\x1d\n\x0f\n\x07\x04\x07\x03\x01\x02\
    \x01\x01\x12\x04\x9c\x01\"*\n\x0f\n\x07\x04\x07\x03\x01\x02\x01\x03\x12\
    \x04\x9c\x0156\n\x0f\n\x07\x04\x07\x03\x01\x02\x01\x08\x12\x04\x9c\x017O\
    \n\x0f\n\x07\x04\x07\x03\x01\x02\x01\x07\x12\x04\x9c\x01BN\nW\n\x06\x04\
    \x07\x03\x01\x02\x02\x12\x04\x9d\x01\x08P\"G\x20communication\x20directi\
    on\x20of\x20this\x20parameter\x20(can\x20be\x20in,\x20out\x20or\x20in/ou\
    t)\r\n\n\x0f\n\x07\x04\x07\x03\x01\x02\x02\x04\x12\x04\x9d\x01\x08\x10\n\
    \x0f\n\x07\x04\x07\x03\x01\x02\x02\x06\x12\x04\x9d\x01\x11\x1e\n\x0f\n\
    \x07\x04\x07\x03\x01\x02\x02\x01\x12\x04\x9d\x01\"+\n\x0f\n\x07\x04\x07\
    \x03\x01\x02\x02\x03\x12\x04\x9d\x0156\n\x0f\n\x07\x04\x07\x03\x01\x02\
    \x02\x08\x12\x04\x9d\x017O\n\x0f\n\x07\x04\x07\x03\x01\x02\x02\x07\x12\
    \x04\x9d\x01BN\n\x0e\n\x04\x04\x07\x03\x02\x12\x06\x9f\x01\x04\xa7\x01\
    \x05\n\r\n\x05\x04\x07\x03\x02\x01\x12\x04\x9f\x01\x0c\x19\n%\n\x06\x04\
    \x07\x03\x02\x02\0\x12\x04\xa0\x01\x087\"\x15\x20unique\x20preset\x20nam\
    e\r\n\n\x0f\n\x07\x04\x07\x03\x02\x02\0\x04\x12\x04\xa0\x01\x08\x10\n\
    \x0f\n\x07\x04\x07\x03\x02\x02\0\x05\x12\x04\xa0\x01\x11\x17\n\x0f\n\x07\
    \x04\x07\x03\x02\x02\0\x01\x12\x04\xa0\x01\"-\n\x0f\n\x07\x04\x07\x03\
    \x02\x02\0\x03\x12\x04\xa0\x0156\n6\n\x06\x04\x07\x03\x02\x02\x01\x12\
    \x04\xa1\x01\x087\"&\x20optional\x20date\x20string\x20of\x20this\x20pres\
    et\r\n\n\x0f\n\x07\x04\x07\x03\x02\x02\x01\x04\x12\x04\xa1\x01\x08\x10\n\
    \x0f\n\x07\x04\x07\x03\x02\x02\x01\x05\x12\x04\xa1\x01\x11\x17\n\x0f\n\
    \x07\x04\x07\x03\x02\x02\x01\x01\x12\x04\xa1\x01\"&\n\x0f\n\x07\x04\x07\
    \x03\x02\x02\x01\x03\x12\x04\xa1\x0156\n9\n\x06\x04\x07\x03\x02\x02\x02\
    \x12\x04\xa2\x01\x087\")\x20optional\x20version\x20string\x20of\x20this\
    \x20preset\r\n\n\x0f\n\x07\x04\x07\x03\x02\x02\x02\x04\x12\x04\xa2\x01\
    \x08\x10\n\x0f\n\x07\x04\x07\x03\x02\x02\x02\x05\x12\x04\xa2\x01\x11\x17\
    \n\x0f\n\x07\x04\x07\x03\x02\x02\x02\x01\x12\x04\xa2\x01\")\n\x0f\n\x07\
    \x04\x07\x03\x02\x02\x02\x03\x12\x04\xa2\x0156\n2\n\x06\x04\x07\x03\x02\
    \x02\x03\x12\x04\xa3\x01\x087\"\"\x20optional\x20comment\x20of\x20this\
    \x20preset\r\n\n\x0f\n\x07\x04\x07\x03\x02\x02\x03\x04\x12\x04\xa3\x01\
    \x08\x10\n\x0f\n\x07\x04\x07\x03\x02\x02\x03\x05\x12\x04\xa3\x01\x11\x17\
    \n\x0f\n\x07\x04\x07\x03\x02\x02\x03\x01\x12\x04\xa3\x01\")\n\x0f\n\x07\
    \x04\x07\x03\x02\x02\x03\x03\x12\x04\xa3\x0156\n[\n\x06\x04\x07\x03\x02\
    \x02\x04\x12\x04\xa4\x01\x087\"K\x20list\x20of\x20supported\x20feature\
    \x20types\x20(e.g.\x20Cracks,\x20Finger_Interuptions,\x20etc.)\r\n\n\x0f\
    \n\x07\x04\x07\x03\x02\x02\x04\x04\x12\x04\xa4\x01\x08\x10\n\x0f\n\x07\
    \x04\x07\x03\x02\x02\x04\x05\x12\x04\xa4\x01\x11\x17\n\x0f\n\x07\x04\x07\
    \x03\x02\x02\x04\x01\x12\x04\xa4\x01\"/\n\x0f\n\x07\x04\x07\x03\x02\x02\
    \x04\x03\x12\x04\xa4\x0156\n@\n\x06\x04\x07\x03\x02\x02\x05\x12\x04\xa5\
    \x01\x087\"0\x20list\x20of\x20additional\x20information\x20of\x20this\
    \x20preset\r\n\n\x0f\n\x07\x04\x07\x03\x02\x02\x05\x04\x12\x04\xa5\x01\
    \x08\x10\n\x0f\n\x07\x04\x07\x03\x02\x02\x05\x06\x12\x04\xa5\x01\x11\x1f\
    \n\x0f\n\x07\x04\x07\x03\x02\x02\x05\x01\x12\x04\xa5\x01\"2\n\x0f\n\x07\
    \x04\x07\x03\x02\x02\x05\x03\x12\x04\xa5\x0156\nI\n\x06\x04\x07\x03\x02\
    \x02\x06\x12\x04\xa6\x01\x087\"9\x20list\x20of\x20available\x20parameter\
    s\x20of\x20this\x20preset\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\r\
    \n\n\x0f\n\x07\x04\x07\x03\x02\x02\x06\x04\x12\x04\xa6\x01\x08\x10\n\x0f\
    \n\x07\x04\x07\x03\x02\x02\x06\x06\x12\x04\xa6\x01\x11!\n\x0f\n\x07\x04\
    \x07\x03\x02\x02\x06\x01\x12\x04\xa6\x01\",\n\x0f\n\x07\x04\x07\x03\x02\
    \x02\x06\x03\x12\x04\xa6\x0156\nO\n\x04\x04\x07\x02\0\x12\x04\xa8\x01\
    \x047\"A\x20information\x20of\x20the\x20requested\x20preset\x20(or\x20nu\
    ll\x20if\x20not\x20available)\r\n\n\r\n\x05\x04\x07\x02\0\x04\x12\x04\
    \xa8\x01\x04\x0c\n\r\n\x05\x04\x07\x02\0\x06\x12\x04\xa8\x01\r\x1a\n\r\n\
    \x05\x04\x07\x02\0\x01\x12\x04\xa8\x01\x20+\n\r\n\x05\x04\x07\x02\0\x03\
    \x12\x04\xa8\x0156\n,\n\x02\x05\0\x12\x06\xac\x01\0\xb1\x01\x01\"\x1e\
    \x20possible\x20type\x20of\x20parameters\r\n\n\x0b\n\x03\x05\0\x01\x12\
    \x04\xac\x01\x05\x11\n\x0c\n\x04\x05\0\x02\0\x12\x04\xad\x01\x04!\n\r\n\
    \x05\x05\0\x02\0\x01\x12\x04\xad\x01\x04\x10\n\r\n\x05\x05\0\x02\0\x02\
    \x12\x04\xad\x01\x1f\x20\n\x15\n\x04\x05\0\x02\x01\x12\x04\xae\x01\x04!\
    \"\x07\x20text\r\n\n\r\n\x05\x05\0\x02\x01\x01\x12\x04\xae\x01\x04\r\n\r\
    \n\x05\x05\0\x02\x01\x02\x12\x04\xae\x01\x1f\x20\n\x18\n\x04\x05\0\x02\
    \x02\x12\x04\xaf\x01\x04!\"\n\x20numeric\r\n\n\r\n\x05\x05\0\x02\x02\x01\
    \x12\x04\xaf\x01\x04\r\n\r\n\x05\x05\0\x02\x02\x02\x12\x04\xaf\x01\x1f\
    \x20\nA\n\x04\x05\0\x02\x03\x12\x04\xb0\x01\x04!\"3\x20special\x20string\
    \x20type\x20with\x20an\x20internal\x20JSON\x20format\r\n\n\r\n\x05\x05\0\
    \x02\x03\x01\x12\x04\xb0\x01\x04\x0b\n\r\n\x05\x05\0\x02\x03\x02\x12\x04\
    \xb0\x01\x1f\x20\n]\n\x02\x04\x08\x12\x06\xb4\x01\0\xba\x01\x01\x1aO\x20\
    type\x20will\x20be\x20used\x20in\x20SetConfig,\x20GetConfigParams_Respon\
    se\x20and\x20SetConfigParams\r\n\n\x0b\n\x03\x04\x08\x01\x12\x04\xb4\x01\
    \x08\x16\n'\n\x04\x04\x08\x02\0\x12\x04\xb5\x01\x08C\"\x19\x20name\x20of\
    \x20this\x20parameter\r\n\n\r\n\x05\x04\x08\x02\0\x04\x12\x04\xb5\x01\
    \x08\x10\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\xb5\x01\x11\x17\n\r\n\x05\
    \x04\x08\x02\0\x01\x12\x04\xb5\x01(2\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\
    \xb5\x01AB\n>\n\x04\x04\x08\x02\x01\x12\x04\xb6\x01\x08\\\"0\x20type\x20\
    of\x20this\x20parameter\x20(string,\x20double,\x20json)\r\n\n\r\n\x05\
    \x04\x08\x02\x01\x04\x12\x04\xb6\x01\x08\x10\n\r\n\x05\x04\x08\x02\x01\
    \x06\x12\x04\xb6\x01\x11\x1d\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xb6\
    \x01(0\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\xb6\x01AB\n\r\n\x05\x04\x08\
    \x02\x01\x08\x12\x04\xb6\x01C[\n\r\n\x05\x04\x08\x02\x01\x07\x12\x04\xb6\
    \x01NZ\n?\n\x04\x04\x08\x02\x02\x12\x04\xb7\x01\x08C\"1\x20value\x20of\
    \x20this\x20parameter\x20if\x20it's\x20a\x20string\x20value\r\n\n\r\n\
    \x05\x04\x08\x02\x02\x04\x12\x04\xb7\x01\x08\x10\n\r\n\x05\x04\x08\x02\
    \x02\x05\x12\x04\xb7\x01\x11\x17\n\r\n\x05\x04\x08\x02\x02\x01\x12\x04\
    \xb7\x01(2\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\xb7\x01AB\n=\n\x04\x04\
    \x08\x02\x03\x12\x04\xb8\x01\x08C\"/\x20value\x20of\x20this\x20parameter\
    \x20if\x20it's\x20a\x20JSON\x20value\r\n\n\r\n\x05\x04\x08\x02\x03\x04\
    \x12\x04\xb8\x01\x08\x10\n\r\n\x05\x04\x08\x02\x03\x05\x12\x04\xb8\x01\
    \x11\x17\n\r\n\x05\x04\x08\x02\x03\x01\x12\x04\xb8\x01(0\n\r\n\x05\x04\
    \x08\x02\x03\x03\x12\x04\xb8\x01AB\n?\n\x04\x04\x08\x02\x04\x12\x04\xb9\
    \x01\x08U\"1\x20value\x20of\x20this\x20parameter\x20if\x20it's\x20a\x20d\
    ouble\x20value\r\n\n\r\n\x05\x04\x08\x02\x04\x04\x12\x04\xb9\x01\x08\x10\
    \n\r\n\x05\x04\x08\x02\x04\x05\x12\x04\xb9\x01\x11\x17\n\r\n\x05\x04\x08\
    \x02\x04\x01\x12\x04\xb9\x01(2\n\r\n\x05\x04\x08\x02\x04\x03\x12\x04\xb9\
    \x01AB\n\r\n\x05\x04\x08\x02\x04\x08\x12\x04\xb9\x01CT\n\r\n\x05\x04\x08\
    \x02\x04\x07\x12\x04\xb9\x01NS\n\x0c\n\x02\x04\t\x12\x06\xbc\x01\0\xd0\
    \x01\x01\n\x0b\n\x03\x04\t\x01\x12\x04\xbc\x01\x08\x19\n\x0e\n\x04\x04\t\
    \x03\0\x12\x06\xbd\x01\x04\xcb\x01\x05\n\r\n\x05\x04\t\x03\0\x01\x12\x04\
    \xbd\x01\x0c\x17\n\x10\n\x06\x04\t\x03\0\x04\0\x12\x06\xbe\x01\x08\xc2\
    \x01\t\n\x0f\n\x07\x04\t\x03\0\x04\0\x01\x12\x04\xbe\x01\r%\n\x10\n\x08\
    \x04\t\x03\0\x04\0\x02\0\x12\x04\xbf\x01\x0c+\n\x11\n\t\x04\t\x03\0\x04\
    \0\x02\0\x01\x12\x04\xbf\x01\x0c\x18\n\x11\n\t\x04\t\x03\0\x04\0\x02\0\
    \x02\x12\x04\xbf\x01)*\n\x10\n\x08\x04\t\x03\0\x04\0\x02\x01\x12\x04\xc0\
    \x01\x0c+\n\x11\n\t\x04\t\x03\0\x04\0\x02\x01\x01\x12\x04\xc0\x01\x0c\
    \x19\n\x11\n\t\x04\t\x03\0\x04\0\x02\x01\x02\x12\x04\xc0\x01)*\n\x10\n\
    \x08\x04\t\x03\0\x04\0\x02\x02\x12\x04\xc1\x01\x0c+\n\x11\n\t\x04\t\x03\
    \0\x04\0\x02\x02\x01\x12\x04\xc1\x01\x0c\x17\n\x11\n\t\x04\t\x03\0\x04\0\
    \x02\x02\x02\x12\x04\xc1\x01)*\n\x10\n\x06\x04\t\x03\0\x04\x01\x12\x06\
    \xc3\x01\x08\xc7\x01\t\n\x0f\n\x07\x04\t\x03\0\x04\x01\x01\x12\x04\xc3\
    \x01\r\x1f\n\x10\n\x08\x04\t\x03\0\x04\x01\x02\0\x12\x04\xc4\x01\x0c+\n\
    \x11\n\t\x04\t\x03\0\x04\x01\x02\0\x01\x12\x04\xc4\x01\x0c\x18\n\x11\n\t\
    \x04\t\x03\0\x04\x01\x02\0\x02\x12\x04\xc4\x01)*\n\x10\n\x08\x04\t\x03\0\
    \x04\x01\x02\x01\x12\x04\xc5\x01\x0c+\n\x11\n\t\x04\t\x03\0\x04\x01\x02\
    \x01\x01\x12\x04\xc5\x01\x0c\x13\n\x11\n\t\x04\t\x03\0\x04\x01\x02\x01\
    \x02\x12\x04\xc5\x01)*\n\x10\n\x08\x04\t\x03\0\x04\x01\x02\x02\x12\x04\
    \xc6\x01\x0c+\n\x11\n\t\x04\t\x03\0\x04\x01\x02\x02\x01\x12\x04\xc6\x01\
    \x0c\x13\n\x11\n\t\x04\t\x03\0\x04\x01\x02\x02\x02\x12\x04\xc6\x01)*\n$\
    \n\x06\x04\t\x03\0\x02\0\x12\x04\xc8\x01\x08V\"\x14\x20number\x20of\x20b\
    usbars\r\n\n\x0f\n\x07\x04\t\x03\0\x02\0\x04\x12\x04\xc8\x01\x08\x10\n\
    \x0f\n\x07\x04\t\x03\0\x02\0\x05\x12\x04\xc8\x01\x11\x16\n\x0f\n\x07\x04\
    \t\x03\0\x02\0\x01\x12\x04\xc8\x01+7\n\x0f\n\x07\x04\t\x03\0\x02\0\x03\
    \x12\x04\xc8\x01DE\n\x0f\n\x07\x04\t\x03\0\x02\0\x08\x12\x04\xc8\x01GU\n\
    \x0f\n\x07\x04\t\x03\0\x02\0\x07\x12\x04\xc8\x01RT\n\x0e\n\x06\x04\t\x03\
    \0\x02\x01\x12\x04\xc9\x01\x08`\n\x0f\n\x07\x04\t\x03\0\x02\x01\x04\x12\
    \x04\xc9\x01\x08\x10\n\x0f\n\x07\x04\t\x03\0\x02\x01\x06\x12\x04\xc9\x01\
    \x11)\n\x0f\n\x07\x04\t\x03\0\x02\x01\x01\x12\x04\xc9\x01+=\n\x0f\n\x07\
    \x04\t\x03\0\x02\x01\x03\x12\x04\xc9\x01DE\n\x0f\n\x07\x04\t\x03\0\x02\
    \x01\x08\x12\x04\xc9\x01G_\n\x0f\n\x07\x04\t\x03\0\x02\x01\x07\x12\x04\
    \xc9\x01R^\n\x0e\n\x06\x04\t\x03\0\x02\x02\x12\x04\xca\x01\x08`\n\x0f\n\
    \x07\x04\t\x03\0\x02\x02\x04\x12\x04\xca\x01\x08\x10\n\x0f\n\x07\x04\t\
    \x03\0\x02\x02\x06\x12\x04\xca\x01\x11#\n\x0f\n\x07\x04\t\x03\0\x02\x02\
    \x01\x12\x04\xca\x01+7\n\x0f\n\x07\x04\t\x03\0\x02\x02\x03\x12\x04\xca\
    \x01DE\n\x0f\n\x07\x04\t\x03\0\x02\x02\x08\x12\x04\xca\x01G_\n\x0f\n\x07\
    \x04\t\x03\0\x02\x02\x07\x12\x04\xca\x01R^\nR\n\x04\x04\t\x02\0\x12\x04\
    \xcc\x01\x045\"D\x20name\x20to\x20identify\x20a\x20configuration\x20set\
    \x20(can\x20be\x20freely\x20given\x20by\x20GUI)\r\n\n\r\n\x05\x04\t\x02\
    \0\x04\x12\x04\xcc\x01\x04\x0c\n\r\n\x05\x04\t\x02\0\x05\x12\x04\xcc\x01\
    \r\x13\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xcc\x01\x1d+\n\r\n\x05\x04\t\
    \x02\0\x03\x12\x04\xcc\x0134\n/\n\x04\x04\t\x02\x01\x12\x04\xcd\x01\x045\
    \"!\x20information\x20for\x20used\x20cell\x20type\r\n\n\r\n\x05\x04\t\
    \x02\x01\x04\x12\x04\xcd\x01\x04\x0c\n\r\n\x05\x04\t\x02\x01\x06\x12\x04\
    \xcd\x01\r\x18\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xcd\x01\x1d&\n\r\n\
    \x05\x04\t\x02\x01\x03\x12\x04\xcd\x0134\n\x8f\x01\n\x04\x04\t\x02\x02\
    \x12\x04\xce\x01\x045\"\x80\x01\x20name\x20of\x20the\x20preset\x20which\
    \x20should\x20be\x20used\x20(use\x20a\x20default\x20one\x20when\x20null\
    \x20-\x20or\x20return\x20an\x20error\x20when\x20there\x20is\x20no\x20def\
    ault\x20available)\r\n\n\r\n\x05\x04\t\x02\x02\x04\x12\x04\xce\x01\x04\
    \x0c\n\r\n\x05\x04\t\x02\x02\x05\x12\x04\xce\x01\r\x13\n\r\n\x05\x04\t\
    \x02\x02\x01\x12\x04\xce\x01\x1d(\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\
    \xce\x0134\n\x91\x01\n\x04\x04\t\x02\x03\x12\x04\xcf\x01\x045\"\x82\x01\
    \x20list\x20of\x20configuration\x20parameters\x20used\x20in\x20this\x20c\
    onfiguration\x20set\x20\x20(definition\x20of\x20these\x20parameters\x20a\
    re\x20not\x20part\x20of\x20this\x20protocol)\r\n\n\r\n\x05\x04\t\x02\x03\
    \x04\x12\x04\xcf\x01\x04\x0c\n\r\n\x05\x04\t\x02\x03\x06\x12\x04\xcf\x01\
    \r\x1b\n\r\n\x05\x04\t\x02\x03\x01\x12\x04\xcf\x01\x1d*\n\r\n\x05\x04\t\
    \x02\x03\x03\x12\x04\xcf\x0134\n\x0c\n\x02\x04\n\x12\x06\xd3\x01\0\xd5\
    \x01\x01\n\x0b\n\x03\x04\n\x01\x12\x04\xd3\x01\x08\x1c\nk\n\x04\x04\n\
    \x02\0\x12\x04\xd4\x01\x048\"]\x20remove\x20given\x20configuration\x20se\
    t\x20or\x20all\x20configuration\x20sets\x20when\x20configset_name==\"ALL\
    CONFIGS\"\r\n\n\r\n\x05\x04\n\x02\0\x04\x12\x04\xd4\x01\x04\x0c\n\r\n\
    \x05\x04\n\x02\0\x05\x12\x04\xd4\x01\r\x13\n\r\n\x05\x04\n\x02\0\x01\x12\
    \x04\xd4\x01\x14\"\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xd4\x0167\n\x0c\n\
    \x02\x04\x0b\x12\x06\xd8\x01\0\xdb\x01\x01\n\x0b\n\x03\x04\x0b\x01\x12\
    \x04\xd8\x01\x08\x1f\n*\n\x04\x04\x0b\x02\0\x12\x04\xd9\x01\x048\"\x1c\
    \x20name\x20of\x20configuration\x20set\r\n\n\r\n\x05\x04\x0b\x02\0\x04\
    \x12\x04\xd9\x01\x04\x0c\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\xd9\x01\r\
    \x13\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xd9\x01\x14\"\n\r\n\x05\x04\x0b\
    \x02\0\x03\x12\x04\xd9\x0167\n<\n\x04\x04\x0b\x02\x01\x12\x04\xda\x01\
    \x048\".\x20list\x20of\x20parameters\x20which\x20should\x20be\x20returne\
    d\r\n\n\r\n\x05\x04\x0b\x02\x01\x04\x12\x04\xda\x01\x04\x0c\n\r\n\x05\
    \x04\x0b\x02\x01\x05\x12\x04\xda\x01\r\x13\n\r\n\x05\x04\x0b\x02\x01\x01\
    \x12\x04\xda\x01\x14#\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\xda\x0167\n\
    \x0c\n\x02\x04\x0c\x12\x06\xde\x01\0\xe1\x01\x01\n\x0b\n\x03\x04\x0c\x01\
    \x12\x04\xde\x01\x08(\n*\n\x04\x04\x0c\x02\0\x12\x04\xdf\x01\x048\"\x1c\
    \x20name\x20of\x20configuration\x20set\r\n\n\r\n\x05\x04\x0c\x02\0\x04\
    \x12\x04\xdf\x01\x04\x0c\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\xdf\x01\r\
    \x13\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xdf\x01\x1d+\n\r\n\x05\x04\x0c\
    \x02\0\x03\x12\x04\xdf\x0167\n7\n\x04\x04\x0c\x02\x01\x12\x04\xe0\x01\
    \x048\")\x20the\x20values\x20of\x20the\x20requested\x20parameters\r\n\n\
    \r\n\x05\x04\x0c\x02\x01\x04\x12\x04\xe0\x01\x04\x0c\n\r\n\x05\x04\x0c\
    \x02\x01\x06\x12\x04\xe0\x01\r\x1b\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\
    \xe0\x01\x1d*\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\xe0\x0167\n\x0c\n\
    \x02\x04\r\x12\x06\xe4\x01\0\xe7\x01\x01\n\x0b\n\x03\x04\r\x01\x12\x04\
    \xe4\x01\x08\x1f\n*\n\x04\x04\r\x02\0\x12\x04\xe5\x01\x048\"\x1c\x20name\
    \x20of\x20configuration\x20set\r\n\n\r\n\x05\x04\r\x02\0\x04\x12\x04\xe5\
    \x01\x04\x0c\n\r\n\x05\x04\r\x02\0\x05\x12\x04\xe5\x01\r\x13\n\r\n\x05\
    \x04\r\x02\0\x01\x12\x04\xe5\x01\x1d+\n\r\n\x05\x04\r\x02\0\x03\x12\x04\
    \xe5\x0167\n4\n\x04\x04\r\x02\x01\x12\x04\xe6\x01\x048\"&\x20the\x20valu\
    es\x20of\x20the\x20parameters\x20to\x20set\r\n\n\r\n\x05\x04\r\x02\x01\
    \x04\x12\x04\xe6\x01\x04\x0c\n\r\n\x05\x04\r\x02\x01\x06\x12\x04\xe6\x01\
    \r\x1b\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xe6\x01\x1d*\n\r\n\x05\x04\r\
    \x02\x01\x03\x12\x04\xe6\x0167\n\x0c\n\x02\x04\x0e\x12\x06\xea\x01\0\xf8\
    \x01\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\xea\x01\x08\x14\n\x0e\n\x04\x04\
    \x0e\x04\0\x12\x06\xeb\x01\x04\xf2\x01\x05\n\r\n\x05\x04\x0e\x04\0\x01\
    \x12\x04\xeb\x01\t\x1a\n\x0e\n\x06\x04\x0e\x04\0\x02\0\x12\x04\xec\x01\
    \x08!\n\x0f\n\x07\x04\x0e\x04\0\x02\0\x01\x12\x04\xec\x01\x08\x14\n\x0f\
    \n\x07\x04\x0e\x04\0\x02\0\x02\x12\x04\xec\x01\x1f\x20\n\x0e\n\x06\x04\
    \x0e\x04\0\x02\x01\x12\x04\xed\x01\x08!\n\x0f\n\x07\x04\x0e\x04\0\x02\
    \x01\x01\x12\x04\xed\x01\x08\x0e\n\x0f\n\x07\x04\x0e\x04\0\x02\x01\x02\
    \x12\x04\xed\x01\x1f\x20\n\x0e\n\x06\x04\x0e\x04\0\x02\x02\x12\x04\xee\
    \x01\x08!\n\x0f\n\x07\x04\x0e\x04\0\x02\x02\x01\x12\x04\xee\x01\x08\x0e\
    \n\x0f\n\x07\x04\x0e\x04\0\x02\x02\x02\x12\x04\xee\x01\x1f\x20\n\x0e\n\
    \x06\x04\x0e\x04\0\x02\x03\x12\x04\xef\x01\x08!\n\x0f\n\x07\x04\x0e\x04\
    \0\x02\x03\x01\x12\x04\xef\x01\x08\x0e\n\x0f\n\x07\x04\x0e\x04\0\x02\x03\
    \x02\x12\x04\xef\x01\x1f\x20\n\x0e\n\x06\x04\x0e\x04\0\x02\x04\x12\x04\
    \xf0\x01\x08#\n\x0f\n\x07\x04\x0e\x04\0\x02\x04\x01\x12\x04\xf0\x01\x08\
    \r\n\x0f\n\x07\x04\x0e\x04\0\x02\x04\x02\x12\x04\xf0\x01\x1f\"\n\x0e\n\
    \x06\x04\x0e\x04\0\x02\x05\x12\x04\xf1\x01\x08#\n\x0f\n\x07\x04\x0e\x04\
    \0\x02\x05\x01\x12\x04\xf1\x01\x08\x0e\n\x0f\n\x07\x04\x0e\x04\0\x02\x05\
    \x02\x12\x04\xf1\x01\x1f\"\n*\n\x04\x04\x0e\x02\0\x12\x04\xf3\x01\x04;\"\
    \x1c\x20file\x20format\x20of\x20image_data\r\n\n\r\n\x05\x04\x0e\x02\0\
    \x04\x12\x04\xf3\x01\x04\x0c\n\r\n\x05\x04\x0e\x02\0\x06\x12\x04\xf3\x01\
    \r\x1e\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xf3\x01!2\n\r\n\x05\x04\x0e\
    \x02\0\x03\x12\x04\xf3\x019:\n-\n\x04\x04\x0e\x02\x01\x12\x04\xf4\x01\
    \x04;\"\x1f\x20byte\x20array\x20of\x20the\x20image\x20data\r\n\n\r\n\x05\
    \x04\x0e\x02\x01\x04\x12\x04\xf4\x01\x04\x0c\n\r\n\x05\x04\x0e\x02\x01\
    \x05\x12\x04\xf4\x01\r\x12\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xf4\x01\
    !+\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xf4\x019:\nB\n\x04\x04\x0e\x02\
    \x02\x12\x04\xf5\x01\x04J\"4\x20width\x20of\x20image\x20(only\x20needed\
    \x20when\x20raw\x20format\x20used)\r\n\n\r\n\x05\x04\x0e\x02\x02\x04\x12\
    \x04\xf5\x01\x04\x0c\n\r\n\x05\x04\x0e\x02\x02\x05\x12\x04\xf5\x01\r\x12\
    \n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\xf5\x01!&\n\r\n\x05\x04\x0e\x02\
    \x02\x03\x12\x04\xf5\x019:\n\r\n\x05\x04\x0e\x02\x02\x08\x12\x04\xf5\x01\
    ;I\n\r\n\x05\x04\x0e\x02\x02\x07\x12\x04\xf5\x01FH\nC\n\x04\x04\x0e\x02\
    \x03\x12\x04\xf6\x01\x04J\"5\x20height\x20of\x20image\x20(only\x20needed\
    \x20when\x20raw\x20format\x20used)\r\n\n\r\n\x05\x04\x0e\x02\x03\x04\x12\
    \x04\xf6\x01\x04\x0c\n\r\n\x05\x04\x0e\x02\x03\x05\x12\x04\xf6\x01\r\x12\
    \n\r\n\x05\x04\x0e\x02\x03\x01\x12\x04\xf6\x01!'\n\r\n\x05\x04\x0e\x02\
    \x03\x03\x12\x04\xf6\x019:\n\r\n\x05\x04\x0e\x02\x03\x08\x12\x04\xf6\x01\
    ;I\n\r\n\x05\x04\x0e\x02\x03\x07\x12\x04\xf6\x01FH\n~\n\x04\x04\x0e\x02\
    \x04\x12\x04\xf7\x01\x04J\"p\x20bit\x20depth\x20of\x20image\x20-\x208\
    \x20or\x2016\x20bit\x20for\x20bw\x20images,\x2024bit\x20for\x20RGB\x20co\
    lor\x20images\x20(only\x20needed\x20when\x20raw\x20format\x20used)\r\n\n\
    \r\n\x05\x04\x0e\x02\x04\x04\x12\x04\xf7\x01\x04\x0c\n\r\n\x05\x04\x0e\
    \x02\x04\x05\x12\x04\xf7\x01\r\x12\n\r\n\x05\x04\x0e\x02\x04\x01\x12\x04\
    \xf7\x01!)\n\r\n\x05\x04\x0e\x02\x04\x03\x12\x04\xf7\x019:\n\r\n\x05\x04\
    \x0e\x02\x04\x08\x12\x04\xf7\x01;I\n\r\n\x05\x04\x0e\x02\x04\x07\x12\x04\
    \xf7\x01FH\n\x0c\n\x02\x04\x0f\x12\x06\xfa\x01\0\xfd\x01\x05\n\x0b\n\x03\
    \x04\x0f\x01\x12\x04\xfa\x01\x08\x16\n0\n\x04\x04\x0f\x02\0\x12\x04\xfb\
    \x01\x085\"\"\x20name\x20of\x20the\x20image\x20in\x20lower\x20case\r\n\n\
    \r\n\x05\x04\x0f\x02\0\x04\x12\x04\xfb\x01\x08\x10\n\r\n\x05\x04\x0f\x02\
    \0\x05\x12\x04\xfb\x01\x11\x17\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xfb\
    \x01!%\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xfb\x0134\n\x1b\n\x04\x04\x0f\
    \x02\x01\x12\x04\xfc\x01\x085\"\r\x20image\x20data\r\n\n\r\n\x05\x04\x0f\
    \x02\x01\x04\x12\x04\xfc\x01\x08\x10\n\r\n\x05\x04\x0f\x02\x01\x06\x12\
    \x04\xfc\x01\x11\x1d\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\xfc\x01!&\n\r\
    \n\x05\x04\x0f\x02\x01\x03\x12\x04\xfc\x0134\n\x0c\n\x02\x04\x10\x12\x06\
    \x80\x02\0\x8c\x02\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\x80\x02\x08\x19\n\
    \x0e\n\x04\x04\x10\x03\0\x12\x06\x81\x02\x04\x85\x02\x05\n\r\n\x05\x04\
    \x10\x03\0\x01\x12\x04\x81\x02\x0c\x1b\nH\n\x06\x04\x10\x03\0\x02\0\x12\
    \x04\x82\x02\x085\"8\x20name\x20of\x20the\x20transfered\x20parameter\x20\
    (e.g.\x20Voc,\x20Isc,\x20...)\r\n\n\x0f\n\x07\x04\x10\x03\0\x02\0\x04\
    \x12\x04\x82\x02\x08\x10\n\x0f\n\x07\x04\x10\x03\0\x02\0\x05\x12\x04\x82\
    \x02\x11\x17\n\x0f\n\x07\x04\x10\x03\0\x02\0\x01\x12\x04\x82\x02!%\n\x0f\
    \n\x07\x04\x10\x03\0\x02\0\x03\x12\x04\x82\x0234\n)\n\x06\x04\x10\x03\0\
    \x02\x01\x12\x04\x83\x02\x085\"\x19\x20unit\x20of\x20this\x20parameter\r\
    \n\n\x0f\n\x07\x04\x10\x03\0\x02\x01\x04\x12\x04\x83\x02\x08\x10\n\x0f\n\
    \x07\x04\x10\x03\0\x02\x01\x05\x12\x04\x83\x02\x11\x17\n\x0f\n\x07\x04\
    \x10\x03\0\x02\x01\x01\x12\x04\x83\x02!%\n\x0f\n\x07\x04\x10\x03\0\x02\
    \x01\x03\x12\x04\x83\x0234\n>\n\x06\x04\x10\x03\0\x02\x02\x12\x04\x84\
    \x02\x085\".\x20value\x20of\x20this\x20parameter\x20\x20\x20(-1e99\x20me\
    ans\x20NaN)\r\n\n\x0f\n\x07\x04\x10\x03\0\x02\x02\x04\x12\x04\x84\x02\
    \x08\x10\n\x0f\n\x07\x04\x10\x03\0\x02\x02\x05\x12\x04\x84\x02\x11\x17\n\
    \x0f\n\x07\x04\x10\x03\0\x02\x02\x01\x12\x04\x84\x02!&\n\x0f\n\x07\x04\
    \x10\x03\0\x02\x02\x03\x12\x04\x84\x0234\n\x0e\n\x04\x04\x10\x03\x01\x12\
    \x06\x86\x02\x08\x89\x02\x05\n\r\n\x05\x04\x10\x03\x01\x01\x12\x04\x86\
    \x02\x10\x1e\nZ\n\x06\x04\x10\x03\x01\x02\0\x12\x04\x87\x02\x085\"J\x20n\
    ame\x20of\x20the\x20transfered\x20parameter\x20in\x20lower\x20case\x20(e\
    .g.\x20celltypename,\x20...)\r\n\n\x0f\n\x07\x04\x10\x03\x01\x02\0\x04\
    \x12\x04\x87\x02\x08\x10\n\x0f\n\x07\x04\x10\x03\x01\x02\0\x05\x12\x04\
    \x87\x02\x11\x17\n\x0f\n\x07\x04\x10\x03\x01\x02\0\x01\x12\x04\x87\x02!%\
    \n\x0f\n\x07\x04\x10\x03\x01\x02\0\x03\x12\x04\x87\x0234\n*\n\x06\x04\
    \x10\x03\x01\x02\x01\x12\x04\x88\x02\x085\"\x1a\x20value\x20of\x20this\
    \x20parameter\r\n\n\x0f\n\x07\x04\x10\x03\x01\x02\x01\x04\x12\x04\x88\
    \x02\x08\x10\n\x0f\n\x07\x04\x10\x03\x01\x02\x01\x05\x12\x04\x88\x02\x11\
    \x17\n\x0f\n\x07\x04\x10\x03\x01\x02\x01\x01\x12\x04\x88\x02!&\n\x0f\n\
    \x07\x04\x10\x03\x01\x02\x01\x03\x12\x04\x88\x0234\n\x0c\n\x04\x04\x10\
    \x02\0\x12\x04\x8a\x02\x045\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\x8a\x02\
    \x04\x0c\n\r\n\x05\x04\x10\x02\0\x06\x12\x04\x8a\x02\x0e\x1d\n\r\n\x05\
    \x04\x10\x02\0\x01\x12\x04\x8a\x02!/\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\
    \x8a\x0234\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\x8b\x02\x045\n\r\n\x05\
    \x04\x10\x02\x01\x04\x12\x04\x8b\x02\x04\x0c\n\r\n\x05\x04\x10\x02\x01\
    \x06\x12\x04\x8b\x02\x0e\x1c\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\x8b\
    \x02!.\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\x8b\x0234\n\x0c\n\x02\x04\
    \x11\x12\x06\x8f\x02\0\x95\x02\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\x8f\
    \x02\x08\x1c\n8\n\x04\x04\x11\x02\0\x12\x04\x90\x02\x04;\"*\x20serial\
    \x20number\x20of\x20the\x20measurement\x20(GUID)\r\n\n\r\n\x05\x04\x11\
    \x02\0\x04\x12\x04\x90\x02\x04\x0c\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\
    \x90\x02\r\x13\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\x90\x02!4\n\r\n\x05\
    \x04\x11\x02\0\x03\x12\x04\x90\x029:\nS\n\x04\x04\x11\x02\x01\x12\x04\
    \x91\x02\x04;\"E\x20name\x20of\x20configuration\x20set\x20which\x20shoul\
    d\x20be\x20used\x20for\x20image\x20analyzing\r\n\n\r\n\x05\x04\x11\x02\
    \x01\x04\x12\x04\x91\x02\x04\x0c\n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\
    \x91\x02\r\x13\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\x91\x02!/\n\r\n\x05\
    \x04\x11\x02\x01\x03\x12\x04\x91\x029:\n]\n\x04\x04\x11\x02\x02\x12\x04\
    \x92\x02\x04;\"O\x20image\x20which\x20have\x20to\x20be\x20analyzed\x20(n\
    ot\x20needed\x20when\x20'multiple_images'\x20are\x20used)\r\n\n\r\n\x05\
    \x04\x11\x02\x02\x04\x12\x04\x92\x02\x04\x0c\n\r\n\x05\x04\x11\x02\x02\
    \x06\x12\x04\x92\x02\r\x19\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\x92\x02\
    !&\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\x92\x029:\nz\n\x04\x04\x11\x02\
    \x03\x12\x04\x93\x02\x04;\"l\x20additional\x20information\x20about\x20th\
    is\x20cell/measurement,\x20e.g.\x20Isc,\x20Voc\x20etc.\x20(could\x20be\
    \x20enabled/disabled\x20in\x20GUI)\r\n\n\r\n\x05\x04\x11\x02\x03\x04\x12\
    \x04\x93\x02\x04\x0c\n\r\n\x05\x04\x11\x02\x03\x06\x12\x04\x93\x02\r\x1e\
    \n\r\n\x05\x04\x11\x02\x03\x01\x12\x04\x93\x02!0\n\r\n\x05\x04\x11\x02\
    \x03\x03\x12\x04\x93\x029:\nl\n\x04\x04\x11\x02\x04\x12\x04\x94\x02\x04;\
    \"^\x20use\x20this\x20instead\x20of\x20'image'\x20to\x20transfer\x20mult\
    iple\x20images\x20for\x20combined\x20analysis\x20possibilities\r\n\n\r\n\
    \x05\x04\x11\x02\x04\x04\x12\x04\x94\x02\x04\x0c\n\r\n\x05\x04\x11\x02\
    \x04\x06\x12\x04\x94\x02\r\x1b\n\r\n\x05\x04\x11\x02\x04\x01\x12\x04\x94\
    \x02!-\n\r\n\x05\x04\x11\x02\x04\x03\x12\x04\x94\x029:\n\x0c\n\x02\x04\
    \x12\x12\x06\x99\x02\0\xf3\x02\x01\n\x0b\n\x03\x04\x12\x01\x12\x04\x99\
    \x02\x08\x1b\n\x0e\n\x04\x04\x12\x03\0\x12\x06\x9a\x02\x04\x9f\x02\x05\n\
    \r\n\x05\x04\x12\x03\0\x01\x12\x04\x9a\x02\x0c\x13\n$\n\x06\x04\x12\x03\
    \0\x02\0\x12\x04\x9b\x02\x08&\"\x14\x20upper\x20left\x20corner\r\n\n\x0f\
    \n\x07\x04\x12\x03\0\x02\0\x04\x12\x04\x9b\x02\x08\x10\n\x0f\n\x07\x04\
    \x12\x03\0\x02\0\x05\x12\x04\x9b\x02\x11\x17\n\x0f\n\x07\x04\x12\x03\0\
    \x02\0\x01\x12\x04\x9b\x02\x18\x1d\n\x0f\n\x07\x04\x12\x03\0\x02\0\x03\
    \x12\x04\x9b\x02$%\n\x0e\n\x06\x04\x12\x03\0\x02\x01\x12\x04\x9c\x02\x08\
    &\n\x0f\n\x07\x04\x12\x03\0\x02\x01\x04\x12\x04\x9c\x02\x08\x10\n\x0f\n\
    \x07\x04\x12\x03\0\x02\x01\x05\x12\x04\x9c\x02\x11\x17\n\x0f\n\x07\x04\
    \x12\x03\0\x02\x01\x01\x12\x04\x9c\x02\x18\x1d\n\x0f\n\x07\x04\x12\x03\0\
    \x02\x01\x03\x12\x04\x9c\x02$%\n\x0e\n\x06\x04\x12\x03\0\x02\x02\x12\x04\
    \x9d\x02\x08&\n\x0f\n\x07\x04\x12\x03\0\x02\x02\x04\x12\x04\x9d\x02\x08\
    \x10\n\x0f\n\x07\x04\x12\x03\0\x02\x02\x05\x12\x04\x9d\x02\x11\x17\n\x0f\
    \n\x07\x04\x12\x03\0\x02\x02\x01\x12\x04\x9d\x02\x18\x1d\n\x0f\n\x07\x04\
    \x12\x03\0\x02\x02\x03\x12\x04\x9d\x02$%\n\x0e\n\x06\x04\x12\x03\0\x02\
    \x03\x12\x04\x9e\x02\x08&\n\x0f\n\x07\x04\x12\x03\0\x02\x03\x04\x12\x04\
    \x9e\x02\x08\x10\n\x0f\n\x07\x04\x12\x03\0\x02\x03\x05\x12\x04\x9e\x02\
    \x11\x17\n\x0f\n\x07\x04\x12\x03\0\x02\x03\x01\x12\x04\x9e\x02\x18\x1e\n\
    \x0f\n\x07\x04\x12\x03\0\x02\x03\x03\x12\x04\x9e\x02$%\n\x0e\n\x04\x04\
    \x12\x03\x01\x12\x06\xa1\x02\x04\xa4\x02\x05\n\r\n\x05\x04\x12\x03\x01\
    \x01\x12\x04\xa1\x02\x0c\x19\n\x0e\n\x06\x04\x12\x03\x01\x02\0\x12\x04\
    \xa2\x02\x08\x1e\n\x0f\n\x07\x04\x12\x03\x01\x02\0\x04\x12\x04\xa2\x02\
    \x08\x10\n\x0f\n\x07\x04\x12\x03\x01\x02\0\x05\x12\x04\xa2\x02\x11\x17\n\
    \x0f\n\x07\x04\x12\x03\x01\x02\0\x01\x12\x04\xa2\x02\x18\x19\n\x0f\n\x07\
    \x04\x12\x03\x01\x02\0\x03\x12\x04\xa2\x02\x1c\x1d\n\x0e\n\x06\x04\x12\
    \x03\x01\x02\x01\x12\x04\xa3\x02\x08\x1e\n\x0f\n\x07\x04\x12\x03\x01\x02\
    \x01\x04\x12\x04\xa3\x02\x08\x10\n\x0f\n\x07\x04\x12\x03\x01\x02\x01\x05\
    \x12\x04\xa3\x02\x11\x17\n\x0f\n\x07\x04\x12\x03\x01\x02\x01\x01\x12\x04\
    \xa3\x02\x18\x19\n\x0f\n\x07\x04\x12\x03\x01\x02\x01\x03\x12\x04\xa3\x02\
    \x1c\x1d\n\x0e\n\x04\x04\x12\x03\x02\x12\x06\xa6\x02\x04\xac\x02\x05\n\r\
    \n\x05\x04\x12\x03\x02\x01\x12\x04\xa6\x02\x0c&\n\x0e\n\x06\x04\x12\x03\
    \x02\x02\0\x12\x04\xa7\x02\x08%\n\x0f\n\x07\x04\x12\x03\x02\x02\0\x04\
    \x12\x04\xa7\x02\x08\x10\n\x0f\n\x07\x04\x12\x03\x02\x02\0\x05\x12\x04\
    \xa7\x02\x11\x17\n\x0f\n\x07\x04\x12\x03\x02\x02\0\x01\x12\x04\xa7\x02\
    \x18\x20\n\x0f\n\x07\x04\x12\x03\x02\x02\0\x03\x12\x04\xa7\x02#$\n\x0e\n\
    \x06\x04\x12\x03\x02\x02\x01\x12\x04\xa8\x02\x08%\n\x0f\n\x07\x04\x12\
    \x03\x02\x02\x01\x04\x12\x04\xa8\x02\x08\x10\n\x0f\n\x07\x04\x12\x03\x02\
    \x02\x01\x05\x12\x04\xa8\x02\x11\x17\n\x0f\n\x07\x04\x12\x03\x02\x02\x01\
    \x01\x12\x04\xa8\x02\x18\x20\n\x0f\n\x07\x04\x12\x03\x02\x02\x01\x03\x12\
    \x04\xa8\x02#$\n\x0e\n\x06\x04\x12\x03\x02\x02\x02\x12\x04\xa9\x02\x08%\
    \n\x0f\n\x07\x04\x12\x03\x02\x02\x02\x04\x12\x04\xa9\x02\x08\x10\n\x0f\n\
    \x07\x04\x12\x03\x02\x02\x02\x05\x12\x04\xa9\x02\x11\x17\n\x0f\n\x07\x04\
    \x12\x03\x02\x02\x02\x01\x12\x04\xa9\x02\x18\x1d\n\x0f\n\x07\x04\x12\x03\
    \x02\x02\x02\x03\x12\x04\xa9\x02#$\n\x0e\n\x06\x04\x12\x03\x02\x02\x03\
    \x12\x04\xaa\x02\x08%\n\x0f\n\x07\x04\x12\x03\x02\x02\x03\x04\x12\x04\
    \xaa\x02\x08\x10\n\x0f\n\x07\x04\x12\x03\x02\x02\x03\x05\x12\x04\xaa\x02\
    \x11\x17\n\x0f\n\x07\x04\x12\x03\x02\x02\x03\x01\x12\x04\xaa\x02\x18\x1e\
    \n\x0f\n\x07\x04\x12\x03\x02\x02\x03\x03\x12\x04\xaa\x02#$\n\x0e\n\x06\
    \x04\x12\x03\x02\x02\x04\x12\x04\xab\x02\x08%\n\x0f\n\x07\x04\x12\x03\
    \x02\x02\x04\x04\x12\x04\xab\x02\x08\x10\n\x0f\n\x07\x04\x12\x03\x02\x02\
    \x04\x05\x12\x04\xab\x02\x11\x17\n\x0f\n\x07\x04\x12\x03\x02\x02\x04\x01\
    \x12\x04\xab\x02\x18\x1d\n\x0f\n\x07\x04\x12\x03\x02\x02\x04\x03\x12\x04\
    \xab\x02#$\n\x0e\n\x04\x04\x12\x03\x03\x12\x06\xae\x02\x04\xb1\x02\x05\n\
    \r\n\x05\x04\x12\x03\x03\x01\x12\x04\xae\x02\x0c\x20\n\x0e\n\x06\x04\x12\
    \x03\x03\x02\0\x12\x04\xaf\x02\x08(\n\x0f\n\x07\x04\x12\x03\x03\x02\0\
    \x04\x12\x04\xaf\x02\x08\x10\n\x0f\n\x07\x04\x12\x03\x03\x02\0\x05\x12\
    \x04\xaf\x02\x11\x17\n\x0f\n\x07\x04\x12\x03\x03\x02\0\x01\x12\x04\xaf\
    \x02\x18!\n\x0f\n\x07\x04\x12\x03\x03\x02\0\x03\x12\x04\xaf\x02&'\n\x0e\
    \n\x06\x04\x12\x03\x03\x02\x01\x12\x04\xb0\x02\x08(\n\x0f\n\x07\x04\x12\
    \x03\x03\x02\x01\x04\x12\x04\xb0\x02\x08\x10\n\x0f\n\x07\x04\x12\x03\x03\
    \x02\x01\x05\x12\x04\xb0\x02\x11\x17\n\x0f\n\x07\x04\x12\x03\x03\x02\x01\
    \x01\x12\x04\xb0\x02\x18#\n\x0f\n\x07\x04\x12\x03\x03\x02\x01\x03\x12\
    \x04\xb0\x02&'\n\x0e\n\x04\x04\x12\x03\x04\x12\x06\xb3\x02\x04\xb5\x02\
    \x05\n\r\n\x05\x04\x12\x03\x04\x01\x12\x04\xb3\x02\x0c(\n\x0e\n\x06\x04\
    \x12\x03\x04\x02\0\x12\x04\xb4\x02\x088\n\x0f\n\x07\x04\x12\x03\x04\x02\
    \0\x04\x12\x04\xb4\x02\x08\x10\n\x0f\n\x07\x04\x12\x03\x04\x02\0\x06\x12\
    \x04\xb4\x02\x11%\n\x0f\n\x07\x04\x12\x03\x04\x02\0\x01\x12\x04\xb4\x02&\
    3\n\x0f\n\x07\x04\x12\x03\x04\x02\0\x03\x12\x04\xb4\x0267\n\x0e\n\x04\
    \x04\x12\x03\x05\x12\x06\xb7\x02\x04\xd8\x02\x05\n\r\n\x05\x04\x12\x03\
    \x05\x01\x12\x04\xb7\x02\x0c\x16\n\x10\n\x06\x04\x12\x03\x05\x03\0\x12\
    \x06\xb8\x02\x08\xd1\x02\t\n\x0f\n\x07\x04\x12\x03\x05\x03\0\x01\x12\x04\
    \xb8\x02\x10\x1e\n0\n\x08\x04\x12\x03\x05\x03\0\x02\0\x12\x04\xb9\x02\
    \x0c:\"\x1e\x20outline\x20rectangle\x20in\x20pixels\r\n\n\x11\n\t\x04\
    \x12\x03\x05\x03\0\x02\0\x04\x12\x04\xb9\x02\x0c\x14\n\x11\n\t\x04\x12\
    \x03\x05\x03\0\x02\0\x06\x12\x04\xb9\x02\x15\x1c\n\x11\n\t\x04\x12\x03\
    \x05\x03\0\x02\0\x01\x12\x04\xb9\x02\x1d,\n\x11\n\t\x04\x12\x03\x05\x03\
    \0\x02\0\x03\x12\x04\xb9\x0289\nt\n\x08\x04\x12\x03\x05\x03\0\x02\x01\
    \x12\x04\xba\x02\x0cL\"b\x20probability\x20for\x20this\x20feature\x20(in\
    dependent\x20from\x20other\x20features,\x201.0\x20means\x20100%)\x20(opt\
    ional\x20value)\r\n\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x01\x04\x12\x04\
    \xba\x02\x0c\x14\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x01\x05\x12\x04\xba\
    \x02\x15\x1b\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x01\x01\x12\x04\xba\x02\
    \x1d(\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x01\x03\x12\x04\xba\x0289\n\
    \x11\n\t\x04\x12\x03\x05\x03\0\x02\x01\x08\x12\x04\xba\x02:K\n\x11\n\t\
    \x04\x12\x03\x05\x03\0\x02\x01\x07\x12\x04\xba\x02EJ\n-\n\x08\x04\x12\
    \x03\x05\x03\0\x02\x02\x12\x04\xbb\x02\x0cL\"\x1b\x20length\x20\x20(opti\
    onal\x20value)\r\n\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x02\x04\x12\x04\
    \xbb\x02\x0c\x14\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x02\x05\x12\x04\xbb\
    \x02\x15\x1b\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x02\x01\x12\x04\xbb\x02\
    \x1d#\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x02\x03\x12\x04\xbb\x0289\n\
    \x11\n\t\x04\x12\x03\x05\x03\0\x02\x02\x08\x12\x04\xbb\x02:K\n\x11\n\t\
    \x04\x12\x03\x05\x03\0\x02\x02\x07\x12\x04\xbb\x02EJ\n+\n\x08\x04\x12\
    \x03\x05\x03\0\x02\x03\x12\x04\xbc\x02\x0cL\"\x19\x20area\x20\x20(option\
    al\x20value)\r\n\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x03\x04\x12\x04\xbc\
    \x02\x0c\x14\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x03\x05\x12\x04\xbc\x02\
    \x15\x1b\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x03\x01\x12\x04\xbc\x02\x1d\
    !\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x03\x03\x12\x04\xbc\x0289\n\x11\n\
    \t\x04\x12\x03\x05\x03\0\x02\x03\x08\x12\x04\xbc\x02:K\n\x11\n\t\x04\x12\
    \x03\x05\x03\0\x02\x03\x07\x12\x04\xbc\x02EJ\n,\n\x08\x04\x12\x03\x05\
    \x03\0\x02\x04\x12\x04\xbd\x02\x0cL\"\x1a\x20angle\x20\x20(optional\x20v\
    alue)\r\n\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x04\x04\x12\x04\xbd\x02\
    \x0c\x14\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x04\x05\x12\x04\xbd\x02\x15\
    \x1b\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x04\x01\x12\x04\xbd\x02\x1d\"\n\
    \x11\n\t\x04\x12\x03\x05\x03\0\x02\x04\x03\x12\x04\xbd\x0289\n\x11\n\t\
    \x04\x12\x03\x05\x03\0\x02\x04\x08\x12\x04\xbd\x02:K\n\x11\n\t\x04\x12\
    \x03\x05\x03\0\x02\x04\x07\x12\x04\xbd\x02EJ\nA\n\x08\x04\x12\x03\x05\
    \x03\0\x02\x05\x12\x04\xbe\x02\x0cL\"/\x20number\x20-\x20can\x20be\x20fr\
    eely\x20used\x20(optional\x20value)\r\n\n\x11\n\t\x04\x12\x03\x05\x03\0\
    \x02\x05\x04\x12\x04\xbe\x02\x0c\x14\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\
    \x05\x05\x12\x04\xbe\x02\x15\x1b\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x05\
    \x01\x12\x04\xbe\x02\x1d#\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x05\x03\
    \x12\x04\xbe\x0289\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x05\x08\x12\x04\
    \xbe\x02:K\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x05\x07\x12\x04\xbe\x02EJ\
    \nB\n\x08\x04\x12\x03\x05\x03\0\x02\x06\x12\x04\xbf\x02\x0cL\"0\x20avera\
    ge\x20-\x20can\x20be\x20freely\x20used\x20(optional\x20value)\r\n\n\x11\
    \n\t\x04\x12\x03\x05\x03\0\x02\x06\x04\x12\x04\xbf\x02\x0c\x14\n\x11\n\t\
    \x04\x12\x03\x05\x03\0\x02\x06\x05\x12\x04\xbf\x02\x15\x1b\n\x11\n\t\x04\
    \x12\x03\x05\x03\0\x02\x06\x01\x12\x04\xbf\x02\x1d$\n\x11\n\t\x04\x12\
    \x03\x05\x03\0\x02\x06\x03\x12\x04\xbf\x0289\n\x11\n\t\x04\x12\x03\x05\
    \x03\0\x02\x06\x08\x12\x04\xbf\x02:K\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\
    \x06\x07\x12\x04\xbf\x02EJ\nB\n\x08\x04\x12\x03\x05\x03\0\x02\x07\x12\
    \x04\xc0\x02\x0cL\"0\x20maximum\x20-\x20can\x20be\x20freely\x20used\x20(\
    optional\x20value)\r\n\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x07\x04\x12\
    \x04\xc0\x02\x0c\x14\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x07\x05\x12\x04\
    \xc0\x02\x15\x1b\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x07\x01\x12\x04\xc0\
    \x02\x1d$\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x07\x03\x12\x04\xc0\x0289\
    \n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x07\x08\x12\x04\xc0\x02:K\n\x11\n\t\
    \x04\x12\x03\x05\x03\0\x02\x07\x07\x12\x04\xc0\x02EJ\nB\n\x08\x04\x12\
    \x03\x05\x03\0\x02\x08\x12\x04\xc1\x02\x0cL\"0\x20minimum\x20-\x20can\
    \x20be\x20freely\x20used\x20(optional\x20value)\r\n\n\x11\n\t\x04\x12\
    \x03\x05\x03\0\x02\x08\x04\x12\x04\xc1\x02\x0c\x14\n\x11\n\t\x04\x12\x03\
    \x05\x03\0\x02\x08\x05\x12\x04\xc1\x02\x15\x1b\n\x11\n\t\x04\x12\x03\x05\
    \x03\0\x02\x08\x01\x12\x04\xc1\x02\x1d$\n\x11\n\t\x04\x12\x03\x05\x03\0\
    \x02\x08\x03\x12\x04\xc1\x0289\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x08\
    \x08\x12\x04\xc1\x02:K\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x08\x07\x12\
    \x04\xc1\x02EJ\nW\n\x08\x04\x12\x03\x05\x03\0\x02\t\x12\x04\xc2\x02\x0cM\
    \"E\x20area_edge\x20-\x20optional\x20value\x20(area\x20inside\x20the\x20\
    edge\x20part\x20of\x20the\x20cell)\r\n\n\x11\n\t\x04\x12\x03\x05\x03\0\
    \x02\t\x04\x12\x04\xc2\x02\x0c\x14\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\t\
    \x05\x12\x04\xc2\x02\x15\x1b\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\t\x01\
    \x12\x04\xc2\x02\x1d&\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\t\x03\x12\x04\
    \xc2\x028:\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\t\x08\x12\x04\xc2\x02;L\n\
    \x11\n\t\x04\x12\x03\x05\x03\0\x02\t\x07\x12\x04\xc2\x02FK\n[\n\x08\x04\
    \x12\x03\x05\x03\0\x02\n\x12\x04\xc3\x02\x0cM\"I\x20area_length\x20-\x20\
    optional\x20value\x20(length\x20inside\x20the\x20edge\x20part\x20of\x20t\
    he\x20cell)\r\n\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\n\x04\x12\x04\xc3\
    \x02\x0c\x14\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\n\x05\x12\x04\xc3\x02\
    \x15\x1b\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\n\x01\x12\x04\xc3\x02\x1d(\
    \n\x11\n\t\x04\x12\x03\x05\x03\0\x02\n\x03\x12\x04\xc3\x028:\n\x11\n\t\
    \x04\x12\x03\x05\x03\0\x02\n\x08\x12\x04\xc3\x02;L\n\x11\n\t\x04\x12\x03\
    \x05\x03\0\x02\n\x07\x12\x04\xc3\x02FK\nG\n\x08\x04\x12\x03\x05\x03\0\
    \x02\x0b\x12\x04\xc4\x02\x0cM\"5\x20avggrayvalue\x20-\x20optional\x20val\
    ue\x20(average\x20gray\x20value)\r\n\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\
    \x0b\x04\x12\x04\xc4\x02\x0c\x14\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x0b\
    \x05\x12\x04\xc4\x02\x15\x1b\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x0b\x01\
    \x12\x04\xc4\x02\x1d)\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x0b\x03\x12\
    \x04\xc4\x028:\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x0b\x08\x12\x04\xc4\
    \x02;L\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x0b\x07\x12\x04\xc4\x02FK\nG\
    \n\x08\x04\x12\x03\x05\x03\0\x02\x0c\x12\x04\xc5\x02\x0cM\"5\x20maxgrayv\
    alue\x20-\x20optional\x20value\x20(maximum\x20gray\x20value)\r\n\n\x11\n\
    \t\x04\x12\x03\x05\x03\0\x02\x0c\x04\x12\x04\xc5\x02\x0c\x14\n\x11\n\t\
    \x04\x12\x03\x05\x03\0\x02\x0c\x05\x12\x04\xc5\x02\x15\x1b\n\x11\n\t\x04\
    \x12\x03\x05\x03\0\x02\x0c\x01\x12\x04\xc5\x02\x1d)\n\x11\n\t\x04\x12\
    \x03\x05\x03\0\x02\x0c\x03\x12\x04\xc5\x028:\n\x11\n\t\x04\x12\x03\x05\
    \x03\0\x02\x0c\x08\x12\x04\xc5\x02;L\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\
    \x0c\x07\x12\x04\xc5\x02FK\nG\n\x08\x04\x12\x03\x05\x03\0\x02\r\x12\x04\
    \xc6\x02\x0cM\"5\x20mingrayvalue\x20-\x20optional\x20value\x20(minimum\
    \x20gray\x20value)\r\n\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\r\x04\x12\x04\
    \xc6\x02\x0c\x14\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\r\x05\x12\x04\xc6\
    \x02\x15\x1b\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\r\x01\x12\x04\xc6\x02\
    \x1d)\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\r\x03\x12\x04\xc6\x028:\n\x11\
    \n\t\x04\x12\x03\x05\x03\0\x02\r\x08\x12\x04\xc6\x02;L\n\x11\n\t\x04\x12\
    \x03\x05\x03\0\x02\r\x07\x12\x04\xc6\x02FK\nw\n\x08\x04\x12\x03\x05\x03\
    \0\x02\x0e\x12\x04\xc7\x02\x0cJ\"e\x20optional\x20unique\x20ID\x20-\x20c\
    an\x20be\x20used\x20for\x20referencing\x20between\x20features\x20via\x20\
    related_ids\x20(scope:\x20message)\r\n\n\x11\n\t\x04\x12\x03\x05\x03\0\
    \x02\x0e\x04\x12\x04\xc7\x02\x0c\x14\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\
    \x0e\x05\x12\x04\xc7\x02\x15\x1a\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x0e\
    \x01\x12\x04\xc7\x02\x1d\x1f\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x0e\x03\
    \x12\x04\xc7\x028:\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x0e\x08\x12\x04\
    \xc7\x02;I\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x0e\x07\x12\x04\xc7\x02FH\
    \nM\n\x08\x04\x12\x03\x05\x03\0\x02\x0f\x12\x04\xc8\x02\x0c;\";\x20a\x20\
    derived\x20feature\x20can\x20references\x20its\x20base-features\x20by\
    \x20id\r\n\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x0f\x04\x12\x04\xc8\x02\
    \x0c\x14\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x0f\x05\x12\x04\xc8\x02\x15\
    \x1a\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x0f\x01\x12\x04\xc8\x02\x1d(\n\
    \x11\n\t\x04\x12\x03\x05\x03\0\x02\x0f\x03\x12\x04\xc8\x028:\n+\n\x08\
    \x04\x12\x03\x05\x03\0\x02\x10\x12\x04\xc9\x02\x0cN\"\x19\x20width\x20(o\
    ptional\x20value)\r\n\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x10\x04\x12\
    \x04\xc9\x02\x0c\x14\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x10\x05\x12\x04\
    \xc9\x02\x15\x1b\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x10\x01\x12\x04\xc9\
    \x02\x1d\"\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x10\x03\x12\x04\xc9\x028;\
    \n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x10\x08\x12\x04\xc9\x02<M\n\x11\n\t\
    \x04\x12\x03\x05\x03\0\x02\x10\x07\x12\x04\xc9\x02GL\n,\n\x08\x04\x12\
    \x03\x05\x03\0\x02\x11\x12\x04\xca\x02\x0c<\"\x1a\x20outline\x20rectangl\
    e\x20in\x20mm\r\n\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x11\x04\x12\x04\
    \xca\x02\x0c\x14\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x11\x06\x12\x04\xca\
    \x02\x15\x1c\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x11\x01\x12\x04\xca\x02\
    \x1d,\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x11\x03\x12\x04\xca\x028;\n;\n\
    \x08\x04\x12\x03\x05\x03\0\x02\x12\x12\x04\xcb\x02\x0c<\")\x20optional\
    \x20UID,\x20replaced\x20use\x20of\x20ID\x20above\r\n\n\x11\n\t\x04\x12\
    \x03\x05\x03\0\x02\x12\x04\x12\x04\xcb\x02\x0c\x14\n\x11\n\t\x04\x12\x03\
    \x05\x03\0\x02\x12\x05\x12\x04\xcb\x02\x15\x1b\n\x11\n\t\x04\x12\x03\x05\
    \x03\0\x02\x12\x01\x12\x04\xcb\x02\x1d\x20\n\x11\n\t\x04\x12\x03\x05\x03\
    \0\x02\x12\x03\x12\x04\xcb\x028;\n\x10\n\x08\x04\x12\x03\x05\x03\0\x02\
    \x13\x12\x04\xcc\x02\x0c<\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x13\x04\
    \x12\x04\xcc\x02\x0c\x14\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x13\x05\x12\
    \x04\xcc\x02\x15\x1b\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x13\x01\x12\x04\
    \xcc\x02\x1d)\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x13\x03\x12\x04\xcc\
    \x028;\n\x10\n\x08\x04\x12\x03\x05\x03\0\x02\x14\x12\x04\xcd\x02\x0cS\n\
    \x11\n\t\x04\x12\x03\x05\x03\0\x02\x14\x04\x12\x04\xcd\x02\x0c\x14\n\x11\
    \n\t\x04\x12\x03\x05\x03\0\x02\x14\x06\x12\x04\xcd\x02\x15/\n\x11\n\t\
    \x04\x12\x03\x05\x03\0\x02\x14\x01\x12\x04\xcd\x022F\n\x11\n\t\x04\x12\
    \x03\x05\x03\0\x02\x14\x03\x12\x04\xcd\x02OR\n\x10\n\x08\x04\x12\x03\x05\
    \x03\0\x02\x15\x12\x04\xce\x02\x0cS\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\
    \x15\x04\x12\x04\xce\x02\x0c\x14\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x15\
    \x06\x12\x04\xce\x02\x15\"\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x15\x01\
    \x12\x04\xce\x022L\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x15\x03\x12\x04\
    \xce\x02OR\n\x10\n\x08\x04\x12\x03\x05\x03\0\x02\x16\x12\x04\xcf\x02\x0c\
    S\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x16\x04\x12\x04\xcf\x02\x0c\x14\n\
    \x11\n\t\x04\x12\x03\x05\x03\0\x02\x16\x05\x12\x04\xcf\x02\x15\x1b\n\x11\
    \n\t\x04\x12\x03\x05\x03\0\x02\x16\x01\x12\x04\xcf\x022:\n\x11\n\t\x04\
    \x12\x03\x05\x03\0\x02\x16\x03\x12\x04\xcf\x02OR\n\x10\n\x08\x04\x12\x03\
    \x05\x03\0\x02\x17\x12\x04\xd0\x02\x0cS\n\x11\n\t\x04\x12\x03\x05\x03\0\
    \x02\x17\x04\x12\x04\xd0\x02\x0c\x14\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\
    \x17\x06\x12\x04\xd0\x02\x151\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x17\
    \x01\x12\x04\xd0\x022H\n\x11\n\t\x04\x12\x03\x05\x03\0\x02\x17\x03\x12\
    \x04\xd0\x02OR\n+\n\x06\x04\x12\x03\x05\x02\0\x12\x04\xd2\x02\x08:\"\x1b\
    \x20name\x20of\x20the\x20feature\x20type\r\n\n\x0f\n\x07\x04\x12\x03\x05\
    \x02\0\x04\x12\x04\xd2\x02\x08\x10\n\x0f\n\x07\x04\x12\x03\x05\x02\0\x05\
    \x12\x04\xd2\x02\x11\x17\n\x0f\n\x07\x04\x12\x03\x05\x02\0\x01\x12\x04\
    \xd2\x02\"3\n\x0f\n\x07\x04\x12\x03\x05\x02\0\x03\x12\x04\xd2\x0289\n<\n\
    \x06\x04\x12\x03\x05\x02\x01\x12\x04\xd3\x02\x08:\",\x20one\x20or\x20mor\
    e\x20features\x20of\x20this\x20feature\x20type\r\n\n\x0f\n\x07\x04\x12\
    \x03\x05\x02\x01\x04\x12\x04\xd3\x02\x08\x10\n\x0f\n\x07\x04\x12\x03\x05\
    \x02\x01\x06\x12\x04\xd3\x02\x11\x1f\n\x0f\n\x07\x04\x12\x03\x05\x02\x01\
    \x01\x12\x04\xd3\x02\"/\n\x0f\n\x07\x04\x12\x03\x05\x02\x01\x03\x12\x04\
    \xd3\x0289\n\xa9\x01\n\x06\x04\x12\x03\x05\x02\x02\x12\x04\xd4\x02\x08:\
    \"\x98\x01\x20if\x20'multi_images'\x20in\x20AnalyzeImage\x20were\x20used\
    \x20the\x20feature\x20can\x20be\x20associated\x20to\x20one\x20or\x20more\
    \x20images;\x20if\x20not\x20used\x20it's\x20assumed\x20corresponding\x20\
    to\x20all\x20images\r\n\n\x0f\n\x07\x04\x12\x03\x05\x02\x02\x04\x12\x04\
    \xd4\x02\x08\x10\n\x0f\n\x07\x04\x12\x03\x05\x02\x02\x05\x12\x04\xd4\x02\
    \x11\x17\n\x0f\n\x07\x04\x12\x03\x05\x02\x02\x01\x12\x04\xd4\x02\"3\n\
    \x0f\n\x07\x04\x12\x03\x05\x02\x02\x03\x12\x04\xd4\x0289\n@\n\x06\x04\
    \x12\x03\x05\x02\x03\x12\x04\xd5\x02\x08<\"0\x20one\x20or\x20more\x20are\
    as\x20that\x20the\x20defect\x20is\x20found\x20in\r\n\n\x0f\n\x07\x04\x12\
    \x03\x05\x02\x03\x04\x12\x04\xd5\x02\x08\x10\n\x0f\n\x07\x04\x12\x03\x05\
    \x02\x03\x05\x12\x04\xd5\x02\x11\x17\n\x0f\n\x07\x04\x12\x03\x05\x02\x03\
    \x01\x12\x04\xd5\x02\")\n\x0f\n\x07\x04\x12\x03\x05\x02\x03\x03\x12\x04\
    \xd5\x028;\nP\n\x06\x04\x12\x03\x05\x02\x04\x12\x04\xd6\x02\x08<\"@\x20w\
    hether\x20the\x20defect\x20was\x20filtered\x20out\x20by\x20the\x20filter\
    ing\x20criteria\r\n\n\x0f\n\x07\x04\x12\x03\x05\x02\x04\x04\x12\x04\xd6\
    \x02\x08\x10\n\x0f\n\x07\x04\x12\x03\x05\x02\x04\x05\x12\x04\xd6\x02\x11\
    \x15\n\x0f\n\x07\x04\x12\x03\x05\x02\x04\x01\x12\x04\xd6\x02\".\n\x0f\n\
    \x07\x04\x12\x03\x05\x02\x04\x03\x12\x04\xd6\x028;\nO\n\x06\x04\x12\x03\
    \x05\x02\x05\x12\x04\xd7\x02\x08<\"?\x20image\x20classifier\x20or\x20ano\
    maly\x20score,\x20depending\x20on\x20network\x20type\r\n\n\x0f\n\x07\x04\
    \x12\x03\x05\x02\x05\x04\x12\x04\xd7\x02\x08\x10\n\x0f\n\x07\x04\x12\x03\
    \x05\x02\x05\x05\x12\x04\xd7\x02\x11\x17\n\x0f\n\x07\x04\x12\x03\x05\x02\
    \x05\x01\x12\x04\xd7\x02\",\n\x0f\n\x07\x04\x12\x03\x05\x02\x05\x03\x12\
    \x04\xd7\x028;\n\x0e\n\x04\x04\x12\x03\x06\x12\x06\xda\x02\x04\xe9\x02\
    \x05\n\r\n\x05\x04\x12\x03\x06\x01\x12\x04\xda\x02\x0c\"\n\x10\n\x06\x04\
    \x12\x03\x06\x04\0\x12\x06\xdb\x02\x08\xe0\x02\t\n\x0f\n\x07\x04\x12\x03\
    \x06\x04\0\x01\x12\x04\xdb\x02\r\x20\n\x10\n\x08\x04\x12\x03\x06\x04\0\
    \x02\0\x12\x04\xdc\x02\x0c'\n\x11\n\t\x04\x12\x03\x06\x04\0\x02\0\x01\
    \x12\x04\xdc\x02\x0c\x1d\n\x11\n\t\x04\x12\x03\x06\x04\0\x02\0\x02\x12\
    \x04\xdc\x02%&\n-\n\x08\x04\x12\x03\x06\x04\0\x02\x01\x12\x04\xdd\x02\
    \x0c'\"\x1b\x20all\x20fine\x20with\x20this\x20image\r\n\n\x11\n\t\x04\
    \x12\x03\x06\x04\0\x02\x01\x01\x12\x04\xdd\x02\x0c\x1c\n\x11\n\t\x04\x12\
    \x03\x06\x04\0\x02\x01\x02\x12\x04\xdd\x02%&\n5\n\x08\x04\x12\x03\x06\
    \x04\0\x02\x02\x12\x04\xde\x02\x0c'\"#\x20there\x20was\x20an\x20minor\
    \x20problem\x20found\r\n\n\x11\n\t\x04\x12\x03\x06\x04\0\x02\x02\x01\x12\
    \x04\xde\x02\x0c\x1f\n\x11\n\t\x04\x12\x03\x06\x04\0\x02\x02\x02\x12\x04\
    \xde\x02%&\n5\n\x08\x04\x12\x03\x06\x04\0\x02\x03\x12\x04\xdf\x02\x0c'\"\
    #\x20there\x20was\x20an\x20major\x20problem\x20found\r\n\n\x11\n\t\x04\
    \x12\x03\x06\x04\0\x02\x03\x01\x12\x04\xdf\x02\x0c\x1f\n\x11\n\t\x04\x12\
    \x03\x06\x04\0\x02\x03\x02\x12\x04\xdf\x02%&\n.\n\x06\x04\x12\x03\x06\
    \x02\0\x12\x04\xe1\x02\x08?\"\x1e\x20optional\x20name\x20of\x20this\x20c\
    lass\r\n\n\x0f\n\x07\x04\x12\x03\x06\x02\0\x04\x12\x04\xe1\x02\x08\x10\n\
    \x0f\n\x07\x04\x12\x03\x06\x02\0\x05\x12\x04\xe1\x02\x11\x17\n\x0f\n\x07\
    \x04\x12\x03\x06\x02\0\x01\x12\x04\xe1\x02&6\n\x0f\n\x07\x04\x12\x03\x06\
    \x02\0\x03\x12\x04\xe1\x02=>\nG\n\x06\x04\x12\x03\x06\x02\x01\x12\x04\
    \xe2\x02\x08?\"7\x20optional\x20rough\x20information\x20about\x20final\
    \x20image\x20quality\r\n\n\x0f\n\x07\x04\x12\x03\x06\x02\x01\x04\x12\x04\
    \xe2\x02\x08\x10\n\x0f\n\x07\x04\x12\x03\x06\x02\x01\x06\x12\x04\xe2\x02\
    \x11$\n\x0f\n\x07\x04\x12\x03\x06\x02\x01\x01\x12\x04\xe2\x02&9\n\x0f\n\
    \x07\x04\x12\x03\x06\x02\x01\x03\x12\x04\xe2\x02=>\nl\n\x06\x04\x12\x03\
    \x06\x02\x02\x12\x04\xe3\x02\x08?\"\\\x20IA\x20can\x20use\x20this\x20to\
    \x20transfer\x20an\x20internal\x20reason/code\x20to\x20GUI\x20for\x20the\
    \x20current\x20classification\r\n\n\x0f\n\x07\x04\x12\x03\x06\x02\x02\
    \x04\x12\x04\xe3\x02\x08\x10\n\x0f\n\x07\x04\x12\x03\x06\x02\x02\x05\x12\
    \x04\xe3\x02\x11\x17\n\x0f\n\x07\x04\x12\x03\x06\x02\x02\x01\x12\x04\xe3\
    \x02&8\n\x0f\n\x07\x04\x12\x03\x06\x02\x02\x03\x12\x04\xe3\x02=>\n{\n\
    \x06\x04\x12\x03\x06\x02\x03\x12\x04\xe4\x02\x08Q\"k\x20IA\x20could\x20s\
    et\x20a\x20score\x20between\x201\x20and\x200\x20(1\x20indicates\x20the\
    \x20maximum\x20certainty\x20that\x20the\x20image\x20has\x20this\x20quali\
    ty)\r\n\n\x0f\n\x07\x04\x12\x03\x06\x02\x03\x04\x12\x04\xe4\x02\x08\x10\
    \n\x0f\n\x07\x04\x12\x03\x06\x02\x03\x05\x12\x04\xe4\x02\x11\x17\n\x0f\n\
    \x07\x04\x12\x03\x06\x02\x03\x01\x12\x04\xe4\x02&9\n\x0f\n\x07\x04\x12\
    \x03\x06\x02\x03\x03\x12\x04\xe4\x02=>\n\x0f\n\x07\x04\x12\x03\x06\x02\
    \x03\x08\x12\x04\xe4\x02?P\n\x0f\n\x07\x04\x12\x03\x06\x02\x03\x07\x12\
    \x04\xe4\x02JO\np\n\x06\x04\x12\x03\x06\x02\x04\x12\x04\xe5\x02\x08Q\"`\
    \x20IA\x20could\x20set\x20a\x20score\x20between\x201\x20and\x200\x20(1\
    \x20indicates\x20the\x20maximum\x20certainty\x20that\x20the\x20image\x20\
    is\x20OK)\r\n\n\x0f\n\x07\x04\x12\x03\x06\x02\x04\x04\x12\x04\xe5\x02\
    \x08\x10\n\x0f\n\x07\x04\x12\x03\x06\x02\x04\x05\x12\x04\xe5\x02\x11\x17\
    \n\x0f\n\x07\x04\x12\x03\x06\x02\x04\x01\x12\x04\xe5\x02&4\n\x0f\n\x07\
    \x04\x12\x03\x06\x02\x04\x03\x12\x04\xe5\x02=>\n\x0f\n\x07\x04\x12\x03\
    \x06\x02\x04\x08\x12\x04\xe5\x02?P\n\x0f\n\x07\x04\x12\x03\x06\x02\x04\
    \x07\x12\x04\xe5\x02JO\nE\n\x06\x04\x12\x03\x06\x02\x05\x12\x04\xe6\x02\
    \x08Q\"5\x20optional\x20value\x20(average\x20gray\x20value\x20of\x20whol\
    e\x20image)\r\n\n\x0f\n\x07\x04\x12\x03\x06\x02\x05\x04\x12\x04\xe6\x02\
    \x08\x10\n\x0f\n\x07\x04\x12\x03\x06\x02\x05\x05\x12\x04\xe6\x02\x11\x17\
    \n\x0f\n\x07\x04\x12\x03\x06\x02\x05\x01\x12\x04\xe6\x02&8\n\x0f\n\x07\
    \x04\x12\x03\x06\x02\x05\x03\x12\x04\xe6\x02=>\n\x0f\n\x07\x04\x12\x03\
    \x06\x02\x05\x08\x12\x04\xe6\x02?P\n\x0f\n\x07\x04\x12\x03\x06\x02\x05\
    \x07\x12\x04\xe6\x02JO\nE\n\x06\x04\x12\x03\x06\x02\x06\x12\x04\xe7\x02\
    \x08Q\"5\x20optional\x20value\x20(maximum\x20gray\x20value\x20of\x20whol\
    e\x20image)\r\n\n\x0f\n\x07\x04\x12\x03\x06\x02\x06\x04\x12\x04\xe7\x02\
    \x08\x10\n\x0f\n\x07\x04\x12\x03\x06\x02\x06\x05\x12\x04\xe7\x02\x11\x17\
    \n\x0f\n\x07\x04\x12\x03\x06\x02\x06\x01\x12\x04\xe7\x02&8\n\x0f\n\x07\
    \x04\x12\x03\x06\x02\x06\x03\x12\x04\xe7\x02=>\n\x0f\n\x07\x04\x12\x03\
    \x06\x02\x06\x08\x12\x04\xe7\x02?P\n\x0f\n\x07\x04\x12\x03\x06\x02\x06\
    \x07\x12\x04\xe7\x02JO\nE\n\x06\x04\x12\x03\x06\x02\x07\x12\x04\xe8\x02\
    \x08Q\"5\x20optional\x20value\x20(minimum\x20gray\x20value\x20of\x20whol\
    e\x20image)\r\n\n\x0f\n\x07\x04\x12\x03\x06\x02\x07\x04\x12\x04\xe8\x02\
    \x08\x10\n\x0f\n\x07\x04\x12\x03\x06\x02\x07\x05\x12\x04\xe8\x02\x11\x17\
    \n\x0f\n\x07\x04\x12\x03\x06\x02\x07\x01\x12\x04\xe8\x02&8\n\x0f\n\x07\
    \x04\x12\x03\x06\x02\x07\x03\x12\x04\xe8\x02=>\n\x0f\n\x07\x04\x12\x03\
    \x06\x02\x07\x08\x12\x04\xe8\x02?P\n\x0f\n\x07\x04\x12\x03\x06\x02\x07\
    \x07\x12\x04\xe8\x02JO\n8\n\x04\x04\x12\x02\0\x12\x04\xeb\x02\x04D\"*\
    \x20serial\x20number\x20of\x20the\x20measurement\x20(GUID)\r\n\n\r\n\x05\
    \x04\x12\x02\0\x04\x12\x04\xeb\x02\x04\x0c\n\r\n\x05\x04\x12\x02\0\x05\
    \x12\x04\xeb\x02\r\x13\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xeb\x02(;\n\r\
    \n\x05\x04\x12\x02\0\x03\x12\x04\xeb\x02BC\nE\n\x04\x04\x12\x02\x01\x12\
    \x04\xec\x02\x04D\"7\x20name\x20of\x20config\x20set\x20which\x20was\x20u\
    sed\x20for\x20image\x20analysis\r\n\n\r\n\x05\x04\x12\x02\x01\x04\x12\
    \x04\xec\x02\x04\x0c\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\xec\x02\r\x13\
    \n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\xec\x02(6\n\r\n\x05\x04\x12\x02\
    \x01\x03\x12\x04\xec\x02BC\n-\n\x04\x04\x12\x02\x02\x12\x04\xed\x02\x04D\
    \"\x1f\x20array\x20of\x20found\x20feature\x20types\r\n\n\r\n\x05\x04\x12\
    \x02\x02\x04\x12\x04\xed\x02\x04\x0c\n\r\n\x05\x04\x12\x02\x02\x06\x12\
    \x04\xed\x02\r\x17\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\xed\x02(0\n\r\n\
    \x05\x04\x12\x02\x02\x03\x12\x04\xed\x02BC\n=\n\x04\x04\x12\x02\x03\x12\
    \x04\xee\x02\x04D\"/\x20optional\x20final\x20classification\x20of\x20thi\
    s\x20image\x20\r\n\n\r\n\x05\x04\x12\x02\x03\x04\x12\x04\xee\x02\x04\x0c\
    \n\r\n\x05\x04\x12\x02\x03\x06\x12\x04\xee\x02\r#\n\r\n\x05\x04\x12\x02\
    \x03\x01\x12\x04\xee\x02(<\n\r\n\x05\x04\x12\x02\x03\x03\x12\x04\xee\x02\
    BC\nn\n\x04\x04\x12\x02\x04\x12\x04\xef\x02\x04D\"`\x20option\x20to\x20r\
    eturn\x20the\x20plain\x20image\x20(e.g.\x20when\x20the\x20image\x20trans\
    fered\x20in\x20AnalyzeImage\x20was\x20changed)\r\n\n\r\n\x05\x04\x12\x02\
    \x04\x04\x12\x04\xef\x02\x04\x0c\n\r\n\x05\x04\x12\x02\x04\x06\x12\x04\
    \xef\x02\r\x19\n\r\n\x05\x04\x12\x02\x04\x01\x12\x04\xef\x02(3\n\r\n\x05\
    \x04\x12\x02\x04\x03\x12\x04\xef\x02BC\nK\n\x04\x04\x12\x02\x05\x12\x04\
    \xf0\x02\x04D\"=\x20option\x20to\x20return\x20the\x20image\x20overlaid\
    \x20with\x20the\x20found\x20defects\r\n\n\r\n\x05\x04\x12\x02\x05\x04\
    \x12\x04\xf0\x02\x04\x0c\n\r\n\x05\x04\x12\x02\x05\x06\x12\x04\xf0\x02\r\
    \x19\n\r\n\x05\x04\x12\x02\x05\x01\x12\x04\xf0\x02(6\n\r\n\x05\x04\x12\
    \x02\x05\x03\x12\x04\xf0\x02BC\nr\n\x04\x04\x12\x02\x06\x12\x04\xf1\x02\
    \x04D\"d\x20option\x20to\x20return\x20the\x20plain\x20images\x20for\x20e\
    very\x20transfered\x20image\x20in\x20'multi_images'\x20from\x20\x20Analy\
    zeImage\r\n\n\r\n\x05\x04\x12\x02\x06\x04\x12\x04\xf1\x02\x04\x0c\n\r\n\
    \x05\x04\x12\x02\x06\x06\x12\x04\xf1\x02\r\x1b\n\r\n\x05\x04\x12\x02\x06\
    \x01\x12\x04\xf1\x02(:\n\r\n\x05\x04\x12\x02\x06\x03\x12\x04\xf1\x02BC\n\
    \x8b\x01\n\x04\x04\x12\x02\x07\x12\x04\xf2\x02\x04D\"}\x20option\x20to\
    \x20return\x20the\x20image\x20overlaid\x20with\x20the\x20found\x20defect\
    s\x20for\x20every\x20transfered\x20image\x20in\x20'multi_images'\x20from\
    \x20\x20AnalyzeImage\r\n\n\r\n\x05\x04\x12\x02\x07\x04\x12\x04\xf2\x02\
    \x04\x0c\n\r\n\x05\x04\x12\x02\x07\x06\x12\x04\xf2\x02\r\x1b\n\r\n\x05\
    \x04\x12\x02\x07\x01\x12\x04\xf2\x02(=\n\r\n\x05\x04\x12\x02\x07\x03\x12\
    \x04\xf2\x02BC\n\x0c\n\x02\x04\x13\x12\x06\xf7\x02\0\x82\x03\x01\n\x0b\n\
    \x03\x04\x13\x01\x12\x04\xf7\x02\x08\x1b\n\x0e\n\x04\x04\x13\x04\0\x12\
    \x06\xf8\x02\x04\xfe\x02\x05\n\r\n\x05\x04\x13\x04\0\x01\x12\x04\xf8\x02\
    \t\x18\n\x0e\n\x06\x04\x13\x04\0\x02\0\x12\x04\xf9\x02\x08!\n\x0f\n\x07\
    \x04\x13\x04\0\x02\0\x01\x12\x04\xf9\x02\x08\x14\n\x0f\n\x07\x04\x13\x04\
    \0\x02\0\x02\x12\x04\xf9\x02\x1f\x20\n\x0e\n\x06\x04\x13\x04\0\x02\x01\
    \x12\x04\xfa\x02\x08!\n\x0f\n\x07\x04\x13\x04\0\x02\x01\x01\x12\x04\xfa\
    \x02\x08\x10\n\x0f\n\x07\x04\x13\x04\0\x02\x01\x02\x12\x04\xfa\x02\x1f\
    \x20\n\x0e\n\x06\x04\x13\x04\0\x02\x02\x12\x04\xfb\x02\x08!\n\x0f\n\x07\
    \x04\x13\x04\0\x02\x02\x01\x12\x04\xfb\x02\x08\x0f\n\x0f\n\x07\x04\x13\
    \x04\0\x02\x02\x02\x12\x04\xfb\x02\x1f\x20\n\x0e\n\x06\x04\x13\x04\0\x02\
    \x03\x12\x04\xfc\x02\x08!\n\x0f\n\x07\x04\x13\x04\0\x02\x03\x01\x12\x04\
    \xfc\x02\x08\x12\n\x0f\n\x07\x04\x13\x04\0\x02\x03\x02\x12\x04\xfc\x02\
    \x1f\x20\n\x0e\n\x06\x04\x13\x04\0\x02\x04\x12\x04\xfd\x02\x08!\n\x0f\n\
    \x07\x04\x13\x04\0\x02\x04\x01\x12\x04\xfd\x02\x08\x10\n\x0f\n\x07\x04\
    \x13\x04\0\x02\x04\x02\x12\x04\xfd\x02\x1f\x20\n\x0c\n\x04\x04\x13\x02\0\
    \x12\x04\xff\x02\x045\n\r\n\x05\x04\x13\x02\0\x04\x12\x04\xff\x02\x04\
    \x0c\n\r\n\x05\x04\x13\x02\0\x06\x12\x04\xff\x02\r\x1c\n\r\n\x05\x04\x13\
    \x02\0\x01\x12\x04\xff\x02\x20)\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xff\
    \x0234\n\x0c\n\x04\x04\x13\x02\x01\x12\x04\x80\x03\x045\n\r\n\x05\x04\
    \x13\x02\x01\x04\x12\x04\x80\x03\x04\x0c\n\r\n\x05\x04\x13\x02\x01\x05\
    \x12\x04\x80\x03\r\x12\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\x80\x03\x20\
    ,\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\x80\x0334\n\x0c\n\x04\x04\x13\
    \x02\x02\x12\x04\x81\x03\x045\n\r\n\x05\x04\x13\x02\x02\x04\x12\x04\x81\
    \x03\x04\x0c\n\r\n\x05\x04\x13\x02\x02\x05\x12\x04\x81\x03\r\x13\n\r\n\
    \x05\x04\x13\x02\x02\x01\x12\x04\x81\x03\x20)\n\r\n\x05\x04\x13\x02\x02\
    \x03\x12\x04\x81\x0334\n\x0c\n\x02\x04\x14\x12\x06\x86\x03\0\x8b\x03\x01\
    \n\x0b\n\x03\x04\x14\x01\x12\x04\x86\x03\x08&\n\x0c\n\x04\x04\x14\x02\0\
    \x12\x04\x87\x03\x04;\n\r\n\x05\x04\x14\x02\0\x04\x12\x04\x87\x03\x04\
    \x0c\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\x87\x03\r\x13\n\r\n\x05\x04\x14\
    \x02\0\x01\x12\x04\x87\x03\x200\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\x87\
    \x039:\n\x0c\n\x04\x04\x14\x02\x01\x12\x04\x88\x03\x04;\n\r\n\x05\x04\
    \x14\x02\x01\x04\x12\x04\x88\x03\x04\x0c\n\r\n\x05\x04\x14\x02\x01\x05\
    \x12\x04\x88\x03\r\x13\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\x88\x03\x20\
    3\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\x88\x039:\n\x0c\n\x04\x04\x14\
    \x02\x02\x12\x04\x89\x03\x04;\n\r\n\x05\x04\x14\x02\x02\x04\x12\x04\x89\
    \x03\x04\x0c\n\r\n\x05\x04\x14\x02\x02\x05\x12\x04\x89\x03\r\x13\n\r\n\
    \x05\x04\x14\x02\x02\x01\x12\x04\x89\x03\x206\n\r\n\x05\x04\x14\x02\x02\
    \x03\x12\x04\x89\x039:\n\x0c\n\x04\x04\x14\x02\x03\x12\x04\x8a\x03\x04;\
    \n\r\n\x05\x04\x14\x02\x03\x04\x12\x04\x8a\x03\x04\x0c\n\r\n\x05\x04\x14\
    \x02\x03\x05\x12\x04\x8a\x03\r\x13\n\r\n\x05\x04\x14\x02\x03\x01\x12\x04\
    \x8a\x03\x204\n\r\n\x05\x04\x14\x02\x03\x03\x12\x04\x8a\x039:\n\x0c\n\
    \x02\x04\x15\x12\x06\x8f\x03\0\x92\x03\x01\n\x0b\n\x03\x04\x15\x01\x12\
    \x04\x8f\x03\x08\x1d\n\x0c\n\x04\x04\x15\x02\0\x12\x04\x90\x03\x04;\n\r\
    \n\x05\x04\x15\x02\0\x04\x12\x04\x90\x03\x04\x0c\n\r\n\x05\x04\x15\x02\0\
    \x05\x12\x04\x90\x03\r\x13\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\x90\x03\
    \x204\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\x90\x039:\n\x0c\n\x04\x04\x15\
    \x02\x01\x12\x04\x91\x03\x04;\n\r\n\x05\x04\x15\x02\x01\x04\x12\x04\x91\
    \x03\x04\x0c\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\x91\x03\r\x11\n\r\n\
    \x05\x04\x15\x02\x01\x01\x12\x04\x91\x03\x20.\n\r\n\x05\x04\x15\x02\x01\
    \x03\x12\x04\x91\x039:\n\x0c\n\x02\x04\x16\x12\x06\x96\x03\0\x99\x03\x01\
    \n\x0b\n\x03\x04\x16\x01\x12\x04\x96\x03\x08\x20\n\x8f\x01\n\x04\x04\x16\
    \x02\0\x12\x04\x97\x03\x04;\"\x80\x01\x20name\x20of\x20the\x20config\x20\
    file;\x20if\x20the\x20file\x20doesn't\x20exist\x20it\x20will\x20be\x20cr\
    eated;\x20if\x20empty,\x20the\x20currently\x20loaded\x20config\x20will\
    \x20be\x20modified\r\n\n\r\n\x05\x04\x16\x02\0\x04\x12\x04\x97\x03\x04\
    \x0c\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\x97\x03\r\x13\n\r\n\x05\x04\x16\
    \x02\0\x01\x12\x04\x97\x03\x200\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\x97\
    \x039:\n\x0c\n\x04\x04\x16\x02\x01\x12\x04\x98\x03\x04;\n\r\n\x05\x04\
    \x16\x02\x01\x04\x12\x04\x98\x03\x04\x0c\n\r\n\x05\x04\x16\x02\x01\x05\
    \x12\x04\x98\x03\r\x13\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\x98\x03\x20\
    3\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\x98\x039:\n\x0c\n\x02\x04\x17\
    \x12\x06\x9d\x03\0\x9f\x03\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\x9d\x03\
    \x08&\n\x0c\n\x04\x04\x17\x02\0\x12\x04\x9e\x03\x04;\n\r\n\x05\x04\x17\
    \x02\0\x04\x12\x04\x9e\x03\x04\x0c\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\
    \x9e\x03\r\x13\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\x9e\x03\x20.\n\r\n\
    \x05\x04\x17\x02\0\x03\x12\x04\x9e\x039:\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(39);
            messages.push(Pb_ProtocolVersionDetection::generated_message_descriptor_data());
            messages.push(Pb_MessageHeader::generated_message_descriptor_data());
            messages.push(Pb_Body_Init::generated_message_descriptor_data());
            messages.push(Pb_Body_GetStatus_Response::generated_message_descriptor_data());
            messages.push(Pb_Body_GetVersion_Response::generated_message_descriptor_data());
            messages.push(Pb_Body_GetPresets_Response::generated_message_descriptor_data());
            messages.push(Pb_Body_GetPresetInfo::generated_message_descriptor_data());
            messages.push(Pb_Body_GetPresetInfo_Response::generated_message_descriptor_data());
            messages.push(Pb_ConfigParam::generated_message_descriptor_data());
            messages.push(Pb_Body_SetConfig::generated_message_descriptor_data());
            messages.push(Pb_Body_RemoveConfig::generated_message_descriptor_data());
            messages.push(Pb_Body_GetConfigParams::generated_message_descriptor_data());
            messages.push(Pb_Body_GetConfigParams_Response::generated_message_descriptor_data());
            messages.push(Pb_Body_SetConfigParams::generated_message_descriptor_data());
            messages.push(Pb_ImageData::generated_message_descriptor_data());
            messages.push(Pb_MultiImages::generated_message_descriptor_data());
            messages.push(Pb_AdditionalData::generated_message_descriptor_data());
            messages.push(Pb_Body_AnalyzeImage::generated_message_descriptor_data());
            messages.push(Pb_Body_ImageResult::generated_message_descriptor_data());
            messages.push(Pb_Body_InfoMessage::generated_message_descriptor_data());
            messages.push(Pb_Body_GetConfigFile_Response::generated_message_descriptor_data());
            messages.push(Pb_Body_SetConfigFile::generated_message_descriptor_data());
            messages.push(Pb_Body_ModifyConfigFile::generated_message_descriptor_data());
            messages.push(Pb_Body_GetStatistics_Response::generated_message_descriptor_data());
            messages.push(pb_body_get_status_response::Pb_ImageInProcess::generated_message_descriptor_data());
            messages.push(pb_body_get_preset_info_response::Pb_AddInfoItem::generated_message_descriptor_data());
            messages.push(pb_body_get_preset_info_response::Pb_ParamInfoItem::generated_message_descriptor_data());
            messages.push(pb_body_get_preset_info_response::Pb_PresetItem::generated_message_descriptor_data());
            messages.push(pb_body_set_config::Pb_CellInfo::generated_message_descriptor_data());
            messages.push(pb_additional_data::Pb_NumericValue::generated_message_descriptor_data());
            messages.push(pb_additional_data::Pb_StringValue::generated_message_descriptor_data());
            messages.push(pb_body_image_result::Pb_Rect::generated_message_descriptor_data());
            messages.push(pb_body_image_result::Pb_DENK_Point::generated_message_descriptor_data());
            messages.push(pb_body_image_result::Pb_DENK_MinimalBoundingBox::generated_message_descriptor_data());
            messages.push(pb_body_image_result::Pb_DENK_OcrCharacter::generated_message_descriptor_data());
            messages.push(pb_body_image_result::Pb_DENK_OcrCharacterPosition::generated_message_descriptor_data());
            messages.push(pb_body_image_result::Pb_Feature::generated_message_descriptor_data());
            messages.push(pb_body_image_result::Pb_ImageClassification::generated_message_descriptor_data());
            messages.push(pb_body_image_result::pb_feature::Pb_FeatureInfo::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(8);
            enums.push(DataTypeEnum::generated_enum_descriptor_data());
            enums.push(pb_message_header::MessageType::generated_enum_descriptor_data());
            enums.push(pb_body_get_preset_info_response::DirectionEnum::generated_enum_descriptor_data());
            enums.push(pb_body_set_config::pb_cell_info::Pb_BusbarOrientationEnum::generated_enum_descriptor_data());
            enums.push(pb_body_set_config::pb_cell_info::Pb_CrystalTypeEnum::generated_enum_descriptor_data());
            enums.push(pb_image_data::Pb_FileFormatEnum::generated_enum_descriptor_data());
            enums.push(pb_body_image_result::pb_image_classification::Pb_ImageQualityEnum::generated_enum_descriptor_data());
            enums.push(pb_body_info_message::Pb_InfoTypeEnum::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
