// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `DENKbuffer.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:denkproto.Image)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Image {
    // message fields
    ///  Image output id
    // @@protoc_insertion_point(field:denkproto.Image.id)
    pub id: ::std::string::String,
    ///  Encoded Image
    // @@protoc_insertion_point(field:denkproto.Image.data)
    pub data: ::std::vec::Vec<u8>,
    ///  H height
    // @@protoc_insertion_point(field:denkproto.Image.height)
    pub height: i32,
    ///  W width
    // @@protoc_insertion_point(field:denkproto.Image.width)
    pub width: i32,
    ///  C channels [1-3]
    // @@protoc_insertion_point(field:denkproto.Image.channels)
    pub channels: i32,
    ///  filename (optional)
    // @@protoc_insertion_point(field:denkproto.Image.filename)
    pub filename: ::std::string::String,
    ///  Image type
    // @@protoc_insertion_point(field:denkproto.Image.imageType)
    pub imageType: ::protobuf::EnumOrUnknown<ImageTypes>,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.Image.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Image {
    fn default() -> &'a Image {
        <Image as ::protobuf::Message>::default_instance()
    }
}

impl Image {
    pub fn new() -> Image {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Image {
    const NAME: &'static str = "Image";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.data = is.read_bytes()?;
                },
                24 => {
                    self.height = is.read_int32()?;
                },
                32 => {
                    self.width = is.read_int32()?;
                },
                40 => {
                    self.channels = is.read_int32()?;
                },
                50 => {
                    self.filename = is.read_string()?;
                },
                56 => {
                    self.imageType = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.height);
        }
        if self.width != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.width);
        }
        if self.channels != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.channels);
        }
        if !self.filename.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.filename);
        }
        if self.imageType != ::protobuf::EnumOrUnknown::new(ImageTypes::Raw) {
            my_size += ::protobuf::rt::int32_size(7, self.imageType.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        if self.height != 0 {
            os.write_int32(3, self.height)?;
        }
        if self.width != 0 {
            os.write_int32(4, self.width)?;
        }
        if self.channels != 0 {
            os.write_int32(5, self.channels)?;
        }
        if !self.filename.is_empty() {
            os.write_string(6, &self.filename)?;
        }
        if self.imageType != ::protobuf::EnumOrUnknown::new(ImageTypes::Raw) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.imageType))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Image {
        Image::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.data.clear();
        self.height = 0;
        self.width = 0;
        self.channels = 0;
        self.filename.clear();
        self.imageType = ::protobuf::EnumOrUnknown::new(ImageTypes::Raw);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Image {
        static instance: Image = Image {
            id: ::std::string::String::new(),
            data: ::std::vec::Vec::new(),
            height: 0,
            width: 0,
            channels: 0,
            filename: ::std::string::String::new(),
            imageType: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:denkproto.FloatMapChannel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FloatMapChannel {
    // message fields
    ///  uuid of the associated class
    // @@protoc_insertion_point(field:denkproto.FloatMapChannel.class_label_id)
    pub class_label_id: ::std::string::String,
    ///  data. H x W uint8
    // @@protoc_insertion_point(field:denkproto.FloatMapChannel.data)
    pub data: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.FloatMapChannel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FloatMapChannel {
    fn default() -> &'a FloatMapChannel {
        <FloatMapChannel as ::protobuf::Message>::default_instance()
    }
}

impl FloatMapChannel {
    pub fn new() -> FloatMapChannel {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FloatMapChannel {
    const NAME: &'static str = "FloatMapChannel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.class_label_id = is.read_string()?;
                },
                18 => {
                    self.data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.class_label_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.class_label_id);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.class_label_id.is_empty() {
            os.write_string(1, &self.class_label_id)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FloatMapChannel {
        FloatMapChannel::new()
    }

    fn clear(&mut self) {
        self.class_label_id.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FloatMapChannel {
        static instance: FloatMapChannel = FloatMapChannel {
            class_label_id: ::std::string::String::new(),
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

///  AnomalyDetection: 1xHxW
///  SegmentationPrediction: CxHxW
// @@protoc_insertion_point(message:denkproto.FloatMapPrediction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FloatMapPrediction {
    // message fields
    ///  each channel contains H x W images, 0-255 uint8 values.
    ///  Should be color-mapped to for visualization.
    // @@protoc_insertion_point(field:denkproto.FloatMapPrediction.channels)
    pub channels: ::std::vec::Vec<FloatMapChannel>,
    ///  H height
    // @@protoc_insertion_point(field:denkproto.FloatMapPrediction.height)
    pub height: i32,
    ///  W width
    // @@protoc_insertion_point(field:denkproto.FloatMapPrediction.width)
    pub width: i32,
    ///  threshold that is used for binarization
    // @@protoc_insertion_point(field:denkproto.FloatMapPrediction.threshold)
    pub threshold: i32,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.FloatMapPrediction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FloatMapPrediction {
    fn default() -> &'a FloatMapPrediction {
        <FloatMapPrediction as ::protobuf::Message>::default_instance()
    }
}

impl FloatMapPrediction {
    pub fn new() -> FloatMapPrediction {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for FloatMapPrediction {
    const NAME: &'static str = "FloatMapPrediction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.channels.push(is.read_message()?);
                },
                16 => {
                    self.height = is.read_int32()?;
                },
                24 => {
                    self.width = is.read_int32()?;
                },
                32 => {
                    self.threshold = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.channels {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.height != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.height);
        }
        if self.width != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.width);
        }
        if self.threshold != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.threshold);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.channels {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.height != 0 {
            os.write_int32(2, self.height)?;
        }
        if self.width != 0 {
            os.write_int32(3, self.width)?;
        }
        if self.threshold != 0 {
            os.write_int32(4, self.threshold)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FloatMapPrediction {
        FloatMapPrediction::new()
    }

    fn clear(&mut self) {
        self.channels.clear();
        self.height = 0;
        self.width = 0;
        self.threshold = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FloatMapPrediction {
        static instance: FloatMapPrediction = FloatMapPrediction {
            channels: ::std::vec::Vec::new(),
            height: 0,
            width: 0,
            threshold: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:denkproto.ClassificationObject)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClassificationObject {
    // message fields
    // @@protoc_insertion_point(field:denkproto.ClassificationObject.class_label_id)
    pub class_label_id: ::std::string::String,
    // @@protoc_insertion_point(field:denkproto.ClassificationObject.score)
    pub score: f64,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.ClassificationObject.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClassificationObject {
    fn default() -> &'a ClassificationObject {
        <ClassificationObject as ::protobuf::Message>::default_instance()
    }
}

impl ClassificationObject {
    pub fn new() -> ClassificationObject {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ClassificationObject {
    const NAME: &'static str = "ClassificationObject";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.class_label_id = is.read_string()?;
                },
                17 => {
                    self.score = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.class_label_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.class_label_id);
        }
        if self.score != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.class_label_id.is_empty() {
            os.write_string(1, &self.class_label_id)?;
        }
        if self.score != 0. {
            os.write_double(2, self.score)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClassificationObject {
        ClassificationObject::new()
    }

    fn clear(&mut self) {
        self.class_label_id.clear();
        self.score = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClassificationObject {
        static instance: ClassificationObject = ClassificationObject {
            class_label_id: ::std::string::String::new(),
            score: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:denkproto.BoundingBox)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BoundingBox {
    // message fields
    ///  top left x [0, 1]
    // @@protoc_insertion_point(field:denkproto.BoundingBox.x1)
    pub x1: f64,
    ///  bottom right x [0, 1]
    // @@protoc_insertion_point(field:denkproto.BoundingBox.x2)
    pub x2: f64,
    ///  top left y [0, 1]
    // @@protoc_insertion_point(field:denkproto.BoundingBox.y1)
    pub y1: f64,
    ///  bottom right y [0, 1]
    // @@protoc_insertion_point(field:denkproto.BoundingBox.y2)
    pub y2: f64,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.BoundingBox.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BoundingBox {
    fn default() -> &'a BoundingBox {
        <BoundingBox as ::protobuf::Message>::default_instance()
    }
}

impl BoundingBox {
    pub fn new() -> BoundingBox {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for BoundingBox {
    const NAME: &'static str = "BoundingBox";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.x1 = is.read_double()?;
                },
                17 => {
                    self.x2 = is.read_double()?;
                },
                25 => {
                    self.y1 = is.read_double()?;
                },
                33 => {
                    self.y2 = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.x1 != 0. {
            my_size += 1 + 8;
        }
        if self.x2 != 0. {
            my_size += 1 + 8;
        }
        if self.y1 != 0. {
            my_size += 1 + 8;
        }
        if self.y2 != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.x1 != 0. {
            os.write_double(1, self.x1)?;
        }
        if self.x2 != 0. {
            os.write_double(2, self.x2)?;
        }
        if self.y1 != 0. {
            os.write_double(3, self.y1)?;
        }
        if self.y2 != 0. {
            os.write_double(4, self.y2)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BoundingBox {
        BoundingBox::new()
    }

    fn clear(&mut self) {
        self.x1 = 0.;
        self.x2 = 0.;
        self.y1 = 0.;
        self.y2 = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BoundingBox {
        static instance: BoundingBox = BoundingBox {
            x1: 0.,
            x2: 0.,
            y1: 0.,
            y2: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:denkproto.ObjectDetectionObject)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ObjectDetectionObject {
    // message fields
    ///  uuid of the associated class
    // @@protoc_insertion_point(field:denkproto.ObjectDetectionObject.class_label_id)
    pub class_label_id: ::std::string::String,
    ///  score of the detected object
    // @@protoc_insertion_point(field:denkproto.ObjectDetectionObject.score)
    pub score: f64,
    ///  bounding box
    // @@protoc_insertion_point(field:denkproto.ObjectDetectionObject.box)
    pub box_: ::protobuf::MessageField<BoundingBox>,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.ObjectDetectionObject.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ObjectDetectionObject {
    fn default() -> &'a ObjectDetectionObject {
        <ObjectDetectionObject as ::protobuf::Message>::default_instance()
    }
}

impl ObjectDetectionObject {
    pub fn new() -> ObjectDetectionObject {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ObjectDetectionObject {
    const NAME: &'static str = "ObjectDetectionObject";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.class_label_id = is.read_string()?;
                },
                17 => {
                    self.score = is.read_double()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.box_)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.class_label_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.class_label_id);
        }
        if self.score != 0. {
            my_size += 1 + 8;
        }
        if let Some(v) = self.box_.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.class_label_id.is_empty() {
            os.write_string(1, &self.class_label_id)?;
        }
        if self.score != 0. {
            os.write_double(2, self.score)?;
        }
        if let Some(v) = self.box_.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ObjectDetectionObject {
        ObjectDetectionObject::new()
    }

    fn clear(&mut self) {
        self.class_label_id.clear();
        self.score = 0.;
        self.box_.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ObjectDetectionObject {
        static instance: ObjectDetectionObject = ObjectDetectionObject {
            class_label_id: ::std::string::String::new(),
            score: 0.,
            box_: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:denkproto.Point2d)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Point2d {
    // message fields
    ///  [0, 1]
    // @@protoc_insertion_point(field:denkproto.Point2d.x)
    pub x: f64,
    ///  [0, 1]
    // @@protoc_insertion_point(field:denkproto.Point2d.y)
    pub y: f64,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.Point2d.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Point2d {
    fn default() -> &'a Point2d {
        <Point2d as ::protobuf::Message>::default_instance()
    }
}

impl Point2d {
    pub fn new() -> Point2d {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Point2d {
    const NAME: &'static str = "Point2d";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.x = is.read_double()?;
                },
                17 => {
                    self.y = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.x != 0. {
            my_size += 1 + 8;
        }
        if self.y != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.x != 0. {
            os.write_double(1, self.x)?;
        }
        if self.y != 0. {
            os.write_double(2, self.y)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Point2d {
        Point2d::new()
    }

    fn clear(&mut self) {
        self.x = 0.;
        self.y = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Point2d {
        static instance: Point2d = Point2d {
            x: 0.,
            y: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:denkproto.Contour)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Contour {
    // message fields
    // @@protoc_insertion_point(field:denkproto.Contour.points)
    pub points: ::std::vec::Vec<Point2d>,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.Contour.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Contour {
    fn default() -> &'a Contour {
        <Contour as ::protobuf::Message>::default_instance()
    }
}

impl Contour {
    pub fn new() -> Contour {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Contour {
    const NAME: &'static str = "Contour";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.points.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.points {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.points {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Contour {
        Contour::new()
    }

    fn clear(&mut self) {
        self.points.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Contour {
        static instance: Contour = Contour {
            points: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:denkproto.Polygon)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Polygon {
    // message fields
    ///  outer contour
    // @@protoc_insertion_point(field:denkproto.Polygon.outer)
    pub outer: ::protobuf::MessageField<Contour>,
    ///  holes
    // @@protoc_insertion_point(field:denkproto.Polygon.holes)
    pub holes: ::std::vec::Vec<Contour>,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.Polygon.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Polygon {
    fn default() -> &'a Polygon {
        <Polygon as ::protobuf::Message>::default_instance()
    }
}

impl Polygon {
    pub fn new() -> Polygon {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Polygon {
    const NAME: &'static str = "Polygon";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.outer)?;
                },
                18 => {
                    self.holes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.outer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.holes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.outer.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.holes {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Polygon {
        Polygon::new()
    }

    fn clear(&mut self) {
        self.outer.clear();
        self.holes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Polygon {
        static instance: Polygon = Polygon {
            outer: ::protobuf::MessageField::none(),
            holes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:denkproto.InstanceSegmentationObject)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct InstanceSegmentationObject {
    // message fields
    ///  uuid of the associated class
    // @@protoc_insertion_point(field:denkproto.InstanceSegmentationObject.class_label_id)
    pub class_label_id: ::std::string::String,
    ///  score of the detected object
    // @@protoc_insertion_point(field:denkproto.InstanceSegmentationObject.score)
    pub score: f64,
    ///  bounding box with score
    // @@protoc_insertion_point(field:denkproto.InstanceSegmentationObject.box)
    pub box_: ::protobuf::MessageField<BoundingBox>,
    ///  mask that should be rendered inside the box
    // @@protoc_insertion_point(field:denkproto.InstanceSegmentationObject.mask)
    pub mask: ::protobuf::MessageField<FloatMapPrediction>,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.InstanceSegmentationObject.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InstanceSegmentationObject {
    fn default() -> &'a InstanceSegmentationObject {
        <InstanceSegmentationObject as ::protobuf::Message>::default_instance()
    }
}

impl InstanceSegmentationObject {
    pub fn new() -> InstanceSegmentationObject {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for InstanceSegmentationObject {
    const NAME: &'static str = "InstanceSegmentationObject";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.class_label_id = is.read_string()?;
                },
                17 => {
                    self.score = is.read_double()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.box_)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.mask)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.class_label_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.class_label_id);
        }
        if self.score != 0. {
            my_size += 1 + 8;
        }
        if let Some(v) = self.box_.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.class_label_id.is_empty() {
            os.write_string(1, &self.class_label_id)?;
        }
        if self.score != 0. {
            os.write_double(2, self.score)?;
        }
        if let Some(v) = self.box_.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.mask.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InstanceSegmentationObject {
        InstanceSegmentationObject::new()
    }

    fn clear(&mut self) {
        self.class_label_id.clear();
        self.score = 0.;
        self.box_.clear();
        self.mask.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InstanceSegmentationObject {
        static instance: InstanceSegmentationObject = InstanceSegmentationObject {
            class_label_id: ::std::string::String::new(),
            score: 0.,
            box_: ::protobuf::MessageField::none(),
            mask: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:denkproto.OCRObject)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OCRObject {
    // message fields
    ///  uuid of the associated class
    // @@protoc_insertion_point(field:denkproto.OCRObject.class_label_id)
    pub class_label_id: ::std::string::String,
    ///  Contains boundaries. Can be Rectangle or Polygon. If polygon, the polygon might contain zero or more holes.
    // @@protoc_insertion_point(field:denkproto.OCRObject.polygon)
    pub polygon: ::protobuf::MessageField<Polygon>,
    ///  Score of this prediction
    // @@protoc_insertion_point(field:denkproto.OCRObject.score)
    pub score: f64,
    ///  detected text
    // @@protoc_insertion_point(field:denkproto.OCRObject.text)
    pub text: ::std::vec::Vec<u8>,
    ///  individual scores for every character
    // @@protoc_insertion_point(field:denkproto.OCRObject.char_scores)
    pub char_scores: ::std::vec::Vec<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.OCRObject.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OCRObject {
    fn default() -> &'a OCRObject {
        <OCRObject as ::protobuf::Message>::default_instance()
    }
}

impl OCRObject {
    pub fn new() -> OCRObject {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for OCRObject {
    const NAME: &'static str = "OCRObject";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.class_label_id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.polygon)?;
                },
                25 => {
                    self.score = is.read_double()?;
                },
                34 => {
                    self.text = is.read_bytes()?;
                },
                42 => {
                    is.read_repeated_packed_double_into(&mut self.char_scores)?;
                },
                41 => {
                    self.char_scores.push(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.class_label_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.class_label_id);
        }
        if let Some(v) = self.polygon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.score != 0. {
            my_size += 1 + 8;
        }
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.text);
        }
        my_size += 9 * self.char_scores.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.class_label_id.is_empty() {
            os.write_string(1, &self.class_label_id)?;
        }
        if let Some(v) = self.polygon.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.score != 0. {
            os.write_double(3, self.score)?;
        }
        if !self.text.is_empty() {
            os.write_bytes(4, &self.text)?;
        }
        for v in &self.char_scores {
            os.write_double(5, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OCRObject {
        OCRObject::new()
    }

    fn clear(&mut self) {
        self.class_label_id.clear();
        self.polygon.clear();
        self.score = 0.;
        self.text.clear();
        self.char_scores.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OCRObject {
        static instance: OCRObject = OCRObject {
            class_label_id: ::std::string::String::new(),
            polygon: ::protobuf::MessageField::none(),
            score: 0.,
            text: ::std::vec::Vec::new(),
            char_scores: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:denkproto.CodeObject)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CodeObject {
    // message fields
    // @@protoc_insertion_point(field:denkproto.CodeObject.class_label_id)
    pub class_label_id: ::std::string::String,
    ///  Contains boundaries. Can be Rectangle or Polygon. If polygon, the polygon might contain zero or more holes.
    // @@protoc_insertion_point(field:denkproto.CodeObject.polygon)
    pub polygon: ::protobuf::MessageField<Polygon>,
    // @@protoc_insertion_point(field:denkproto.CodeObject.code_type)
    pub code_type: ::std::string::String,
    // @@protoc_insertion_point(field:denkproto.CodeObject.text)
    pub text: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.CodeObject.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CodeObject {
    fn default() -> &'a CodeObject {
        <CodeObject as ::protobuf::Message>::default_instance()
    }
}

impl CodeObject {
    pub fn new() -> CodeObject {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CodeObject {
    const NAME: &'static str = "CodeObject";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.class_label_id = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.polygon)?;
                },
                26 => {
                    self.code_type = is.read_string()?;
                },
                34 => {
                    self.text = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.class_label_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.class_label_id);
        }
        if let Some(v) = self.polygon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.code_type.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.code_type);
        }
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.text);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.class_label_id.is_empty() {
            os.write_string(1, &self.class_label_id)?;
        }
        if let Some(v) = self.polygon.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.code_type.is_empty() {
            os.write_string(3, &self.code_type)?;
        }
        if !self.text.is_empty() {
            os.write_bytes(4, &self.text)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CodeObject {
        CodeObject::new()
    }

    fn clear(&mut self) {
        self.class_label_id.clear();
        self.polygon.clear();
        self.code_type.clear();
        self.text.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CodeObject {
        static instance: CodeObject = CodeObject {
            class_label_id: ::std::string::String::new(),
            polygon: ::protobuf::MessageField::none(),
            code_type: ::std::string::String::new(),
            text: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:denkproto.ComputedPropertyValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ComputedPropertyValue {
    // message oneof groups
    pub value: ::std::option::Option<computed_property_value::Value>,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.ComputedPropertyValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ComputedPropertyValue {
    fn default() -> &'a ComputedPropertyValue {
        <ComputedPropertyValue as ::protobuf::Message>::default_instance()
    }
}

impl ComputedPropertyValue {
    pub fn new() -> ComputedPropertyValue {
        ::std::default::Default::default()
    }

    // int64 _int64 = 1;

    pub fn _int64(&self) -> i64 {
        match self.value {
            ::std::option::Option::Some(computed_property_value::Value::Int64(v)) => v,
            _ => 0,
        }
    }

    pub fn clear__int64(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has__int64(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(computed_property_value::Value::Int64(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set__int64(&mut self, v: i64) {
        self.value = ::std::option::Option::Some(computed_property_value::Value::Int64(v))
    }

    // double _double = 2;

    pub fn _double(&self) -> f64 {
        match self.value {
            ::std::option::Option::Some(computed_property_value::Value::Double(v)) => v,
            _ => 0.,
        }
    }

    pub fn clear__double(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has__double(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(computed_property_value::Value::Double(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set__double(&mut self, v: f64) {
        self.value = ::std::option::Option::Some(computed_property_value::Value::Double(v))
    }

    // string _string = 3;

    pub fn _string(&self) -> &str {
        match self.value {
            ::std::option::Option::Some(computed_property_value::Value::String(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear__string(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has__string(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(computed_property_value::Value::String(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set__string(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(computed_property_value::Value::String(v))
    }

    // Mutable pointer to the field.
    pub fn mut__string(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(computed_property_value::Value::String(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(computed_property_value::Value::String(::std::string::String::new()));
        }
        match self.value {
            ::std::option::Option::Some(computed_property_value::Value::String(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take__string(&mut self) -> ::std::string::String {
        if self.has__string() {
            match self.value.take() {
                ::std::option::Option::Some(computed_property_value::Value::String(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for ComputedPropertyValue {
    const NAME: &'static str = "ComputedPropertyValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.value = ::std::option::Option::Some(computed_property_value::Value::Int64(is.read_int64()?));
                },
                17 => {
                    self.value = ::std::option::Option::Some(computed_property_value::Value::Double(is.read_double()?));
                },
                26 => {
                    self.value = ::std::option::Option::Some(computed_property_value::Value::String(is.read_string()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &computed_property_value::Value::Int64(v) => {
                    my_size += ::protobuf::rt::int64_size(1, v);
                },
                &computed_property_value::Value::Double(v) => {
                    my_size += 1 + 8;
                },
                &computed_property_value::Value::String(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &computed_property_value::Value::Int64(v) => {
                    os.write_int64(1, v)?;
                },
                &computed_property_value::Value::Double(v) => {
                    os.write_double(2, v)?;
                },
                &computed_property_value::Value::String(ref v) => {
                    os.write_string(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ComputedPropertyValue {
        ComputedPropertyValue::new()
    }

    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ComputedPropertyValue {
        static instance: ComputedPropertyValue = ComputedPropertyValue {
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `ComputedPropertyValue`
pub mod computed_property_value {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:denkproto.ComputedPropertyValue.value)
    pub enum Value {
        // @@protoc_insertion_point(oneof_field:denkproto.ComputedPropertyValue._int64)
        Int64(i64),
        // @@protoc_insertion_point(oneof_field:denkproto.ComputedPropertyValue._double)
        Double(f64),
        // @@protoc_insertion_point(oneof_field:denkproto.ComputedPropertyValue._string)
        String(::std::string::String),
    }

    impl ::protobuf::Oneof for Value {
    }

    impl Value {
    }
}

// @@protoc_insertion_point(message:denkproto.ComputedProperty)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ComputedProperty {
    // message fields
    // @@protoc_insertion_point(field:denkproto.ComputedProperty.subject)
    pub subject: ::protobuf::EnumOrUnknown<ComputedPropertySubjects>,
    // @@protoc_insertion_point(field:denkproto.ComputedProperty.value)
    pub value: ::protobuf::MessageField<ComputedPropertyValue>,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.ComputedProperty.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ComputedProperty {
    fn default() -> &'a ComputedProperty {
        <ComputedProperty as ::protobuf::Message>::default_instance()
    }
}

impl ComputedProperty {
    pub fn new() -> ComputedProperty {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ComputedProperty {
    const NAME: &'static str = "ComputedProperty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.subject = is.read_enum_or_unknown()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.value)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.subject != ::protobuf::EnumOrUnknown::new(ComputedPropertySubjects::COMPUTED_PROPERTY_SUBJECT_MEAN_GRAY_VALUE) {
            my_size += ::protobuf::rt::int32_size(1, self.subject.value());
        }
        if let Some(v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.subject != ::protobuf::EnumOrUnknown::new(ComputedPropertySubjects::COMPUTED_PROPERTY_SUBJECT_MEAN_GRAY_VALUE) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.subject))?;
        }
        if let Some(v) = self.value.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ComputedProperty {
        ComputedProperty::new()
    }

    fn clear(&mut self) {
        self.subject = ::protobuf::EnumOrUnknown::new(ComputedPropertySubjects::COMPUTED_PROPERTY_SUBJECT_MEAN_GRAY_VALUE);
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ComputedProperty {
        static instance: ComputedProperty = ComputedProperty {
            subject: ::protobuf::EnumOrUnknown::from_i32(0),
            value: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:denkproto.InferenceObject)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct InferenceObject {
    // message fields
    ///  these properties will be computed on the fly
    ///  example: meanGrayValue.
    ///  It will be only computed if there is a filter- or decision-rule that evaluates meanGrayValue
    ///  Once computed, values can be cached here and can fetched by other rules that also evaluate the same property.
    ///  Reason: We don't want to waste compute time for values that we don't need.
    // @@protoc_insertion_point(field:denkproto.InferenceObject.computed_properties)
    pub computed_properties: ::std::vec::Vec<ComputedProperty>,
    // message oneof groups
    pub inference_object: ::std::option::Option<inference_object::Inference_object>,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.InferenceObject.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InferenceObject {
    fn default() -> &'a InferenceObject {
        <InferenceObject as ::protobuf::Message>::default_instance()
    }
}

impl InferenceObject {
    pub fn new() -> InferenceObject {
        ::std::default::Default::default()
    }

    // .denkproto.ClassificationObject classification_object = 1;

    pub fn classification_object(&self) -> &ClassificationObject {
        match self.inference_object {
            ::std::option::Option::Some(inference_object::Inference_object::ClassificationObject(ref v)) => v,
            _ => <ClassificationObject as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_classification_object(&mut self) {
        self.inference_object = ::std::option::Option::None;
    }

    pub fn has_classification_object(&self) -> bool {
        match self.inference_object {
            ::std::option::Option::Some(inference_object::Inference_object::ClassificationObject(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_classification_object(&mut self, v: ClassificationObject) {
        self.inference_object = ::std::option::Option::Some(inference_object::Inference_object::ClassificationObject(v))
    }

    // Mutable pointer to the field.
    pub fn mut_classification_object(&mut self) -> &mut ClassificationObject {
        if let ::std::option::Option::Some(inference_object::Inference_object::ClassificationObject(_)) = self.inference_object {
        } else {
            self.inference_object = ::std::option::Option::Some(inference_object::Inference_object::ClassificationObject(ClassificationObject::new()));
        }
        match self.inference_object {
            ::std::option::Option::Some(inference_object::Inference_object::ClassificationObject(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_classification_object(&mut self) -> ClassificationObject {
        if self.has_classification_object() {
            match self.inference_object.take() {
                ::std::option::Option::Some(inference_object::Inference_object::ClassificationObject(v)) => v,
                _ => panic!(),
            }
        } else {
            ClassificationObject::new()
        }
    }

    // .denkproto.ObjectDetectionObject object_detection_object = 2;

    pub fn object_detection_object(&self) -> &ObjectDetectionObject {
        match self.inference_object {
            ::std::option::Option::Some(inference_object::Inference_object::ObjectDetectionObject(ref v)) => v,
            _ => <ObjectDetectionObject as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_object_detection_object(&mut self) {
        self.inference_object = ::std::option::Option::None;
    }

    pub fn has_object_detection_object(&self) -> bool {
        match self.inference_object {
            ::std::option::Option::Some(inference_object::Inference_object::ObjectDetectionObject(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_object_detection_object(&mut self, v: ObjectDetectionObject) {
        self.inference_object = ::std::option::Option::Some(inference_object::Inference_object::ObjectDetectionObject(v))
    }

    // Mutable pointer to the field.
    pub fn mut_object_detection_object(&mut self) -> &mut ObjectDetectionObject {
        if let ::std::option::Option::Some(inference_object::Inference_object::ObjectDetectionObject(_)) = self.inference_object {
        } else {
            self.inference_object = ::std::option::Option::Some(inference_object::Inference_object::ObjectDetectionObject(ObjectDetectionObject::new()));
        }
        match self.inference_object {
            ::std::option::Option::Some(inference_object::Inference_object::ObjectDetectionObject(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_object_detection_object(&mut self) -> ObjectDetectionObject {
        if self.has_object_detection_object() {
            match self.inference_object.take() {
                ::std::option::Option::Some(inference_object::Inference_object::ObjectDetectionObject(v)) => v,
                _ => panic!(),
            }
        } else {
            ObjectDetectionObject::new()
        }
    }

    // .denkproto.InstanceSegmentationObject instance_segmentation_object = 3;

    pub fn instance_segmentation_object(&self) -> &InstanceSegmentationObject {
        match self.inference_object {
            ::std::option::Option::Some(inference_object::Inference_object::InstanceSegmentationObject(ref v)) => v,
            _ => <InstanceSegmentationObject as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_instance_segmentation_object(&mut self) {
        self.inference_object = ::std::option::Option::None;
    }

    pub fn has_instance_segmentation_object(&self) -> bool {
        match self.inference_object {
            ::std::option::Option::Some(inference_object::Inference_object::InstanceSegmentationObject(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_instance_segmentation_object(&mut self, v: InstanceSegmentationObject) {
        self.inference_object = ::std::option::Option::Some(inference_object::Inference_object::InstanceSegmentationObject(v))
    }

    // Mutable pointer to the field.
    pub fn mut_instance_segmentation_object(&mut self) -> &mut InstanceSegmentationObject {
        if let ::std::option::Option::Some(inference_object::Inference_object::InstanceSegmentationObject(_)) = self.inference_object {
        } else {
            self.inference_object = ::std::option::Option::Some(inference_object::Inference_object::InstanceSegmentationObject(InstanceSegmentationObject::new()));
        }
        match self.inference_object {
            ::std::option::Option::Some(inference_object::Inference_object::InstanceSegmentationObject(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_instance_segmentation_object(&mut self) -> InstanceSegmentationObject {
        if self.has_instance_segmentation_object() {
            match self.inference_object.take() {
                ::std::option::Option::Some(inference_object::Inference_object::InstanceSegmentationObject(v)) => v,
                _ => panic!(),
            }
        } else {
            InstanceSegmentationObject::new()
        }
    }

    // .denkproto.OCRObject ocr_object = 4;

    pub fn ocr_object(&self) -> &OCRObject {
        match self.inference_object {
            ::std::option::Option::Some(inference_object::Inference_object::OcrObject(ref v)) => v,
            _ => <OCRObject as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_ocr_object(&mut self) {
        self.inference_object = ::std::option::Option::None;
    }

    pub fn has_ocr_object(&self) -> bool {
        match self.inference_object {
            ::std::option::Option::Some(inference_object::Inference_object::OcrObject(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ocr_object(&mut self, v: OCRObject) {
        self.inference_object = ::std::option::Option::Some(inference_object::Inference_object::OcrObject(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ocr_object(&mut self) -> &mut OCRObject {
        if let ::std::option::Option::Some(inference_object::Inference_object::OcrObject(_)) = self.inference_object {
        } else {
            self.inference_object = ::std::option::Option::Some(inference_object::Inference_object::OcrObject(OCRObject::new()));
        }
        match self.inference_object {
            ::std::option::Option::Some(inference_object::Inference_object::OcrObject(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ocr_object(&mut self) -> OCRObject {
        if self.has_ocr_object() {
            match self.inference_object.take() {
                ::std::option::Option::Some(inference_object::Inference_object::OcrObject(v)) => v,
                _ => panic!(),
            }
        } else {
            OCRObject::new()
        }
    }

    // .denkproto.CodeObject code_object = 5;

    pub fn code_object(&self) -> &CodeObject {
        match self.inference_object {
            ::std::option::Option::Some(inference_object::Inference_object::CodeObject(ref v)) => v,
            _ => <CodeObject as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_code_object(&mut self) {
        self.inference_object = ::std::option::Option::None;
    }

    pub fn has_code_object(&self) -> bool {
        match self.inference_object {
            ::std::option::Option::Some(inference_object::Inference_object::CodeObject(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_code_object(&mut self, v: CodeObject) {
        self.inference_object = ::std::option::Option::Some(inference_object::Inference_object::CodeObject(v))
    }

    // Mutable pointer to the field.
    pub fn mut_code_object(&mut self) -> &mut CodeObject {
        if let ::std::option::Option::Some(inference_object::Inference_object::CodeObject(_)) = self.inference_object {
        } else {
            self.inference_object = ::std::option::Option::Some(inference_object::Inference_object::CodeObject(CodeObject::new()));
        }
        match self.inference_object {
            ::std::option::Option::Some(inference_object::Inference_object::CodeObject(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_code_object(&mut self) -> CodeObject {
        if self.has_code_object() {
            match self.inference_object.take() {
                ::std::option::Option::Some(inference_object::Inference_object::CodeObject(v)) => v,
                _ => panic!(),
            }
        } else {
            CodeObject::new()
        }
    }
}

impl ::protobuf::Message for InferenceObject {
    const NAME: &'static str = "InferenceObject";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.inference_object = ::std::option::Option::Some(inference_object::Inference_object::ClassificationObject(is.read_message()?));
                },
                18 => {
                    self.inference_object = ::std::option::Option::Some(inference_object::Inference_object::ObjectDetectionObject(is.read_message()?));
                },
                26 => {
                    self.inference_object = ::std::option::Option::Some(inference_object::Inference_object::InstanceSegmentationObject(is.read_message()?));
                },
                34 => {
                    self.inference_object = ::std::option::Option::Some(inference_object::Inference_object::OcrObject(is.read_message()?));
                },
                42 => {
                    self.inference_object = ::std::option::Option::Some(inference_object::Inference_object::CodeObject(is.read_message()?));
                },
                162 => {
                    self.computed_properties.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.computed_properties {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let ::std::option::Option::Some(ref v) = self.inference_object {
            match v {
                &inference_object::Inference_object::ClassificationObject(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &inference_object::Inference_object::ObjectDetectionObject(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &inference_object::Inference_object::InstanceSegmentationObject(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &inference_object::Inference_object::OcrObject(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &inference_object::Inference_object::CodeObject(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.computed_properties {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        };
        if let ::std::option::Option::Some(ref v) = self.inference_object {
            match v {
                &inference_object::Inference_object::ClassificationObject(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &inference_object::Inference_object::ObjectDetectionObject(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &inference_object::Inference_object::InstanceSegmentationObject(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &inference_object::Inference_object::OcrObject(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &inference_object::Inference_object::CodeObject(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InferenceObject {
        InferenceObject::new()
    }

    fn clear(&mut self) {
        self.inference_object = ::std::option::Option::None;
        self.inference_object = ::std::option::Option::None;
        self.inference_object = ::std::option::Option::None;
        self.inference_object = ::std::option::Option::None;
        self.inference_object = ::std::option::Option::None;
        self.computed_properties.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InferenceObject {
        static instance: InferenceObject = InferenceObject {
            computed_properties: ::std::vec::Vec::new(),
            inference_object: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `InferenceObject`
pub mod inference_object {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:denkproto.InferenceObject.inference_object)
    pub enum Inference_object {
        // @@protoc_insertion_point(oneof_field:denkproto.InferenceObject.classification_object)
        ClassificationObject(super::ClassificationObject),
        // @@protoc_insertion_point(oneof_field:denkproto.InferenceObject.object_detection_object)
        ObjectDetectionObject(super::ObjectDetectionObject),
        // @@protoc_insertion_point(oneof_field:denkproto.InferenceObject.instance_segmentation_object)
        InstanceSegmentationObject(super::InstanceSegmentationObject),
        // @@protoc_insertion_point(oneof_field:denkproto.InferenceObject.ocr_object)
        OcrObject(super::OCRObject),
        // @@protoc_insertion_point(oneof_field:denkproto.InferenceObject.code_object)
        CodeObject(super::CodeObject),
    }

    impl ::protobuf::Oneof for Inference_object {
    }

    impl Inference_object {
    }
}

// @@protoc_insertion_point(message:denkproto.InferenceObjects)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct InferenceObjects {
    // message fields
    // @@protoc_insertion_point(field:denkproto.InferenceObjects.inference_objects)
    pub inference_objects: ::std::vec::Vec<InferenceObject>,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.InferenceObjects.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a InferenceObjects {
    fn default() -> &'a InferenceObjects {
        <InferenceObjects as ::protobuf::Message>::default_instance()
    }
}

impl InferenceObjects {
    pub fn new() -> InferenceObjects {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for InferenceObjects {
    const NAME: &'static str = "InferenceObjects";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.inference_objects.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.inference_objects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.inference_objects {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> InferenceObjects {
        InferenceObjects::new()
    }

    fn clear(&mut self) {
        self.inference_objects.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static InferenceObjects {
        static instance: InferenceObjects = InferenceObjects {
            inference_objects: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

///  Contains "raw" predictions made by AI nodes.
///  Examples: Both ImageSegmentation and AnomalyDetection generate a FloatMap.
///  NOTE: Stored lossy! Use only for visualization!
// @@protoc_insertion_point(message:denkproto.Prediction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Prediction {
    // message oneof groups
    pub prediction: ::std::option::Option<prediction::Prediction>,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.Prediction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Prediction {
    fn default() -> &'a Prediction {
        <Prediction as ::protobuf::Message>::default_instance()
    }
}

impl Prediction {
    pub fn new() -> Prediction {
        ::std::default::Default::default()
    }

    // .denkproto.FloatMapPrediction floatmap_prediction = 1;

    pub fn floatmap_prediction(&self) -> &FloatMapPrediction {
        match self.prediction {
            ::std::option::Option::Some(prediction::Prediction::FloatmapPrediction(ref v)) => v,
            _ => <FloatMapPrediction as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_floatmap_prediction(&mut self) {
        self.prediction = ::std::option::Option::None;
    }

    pub fn has_floatmap_prediction(&self) -> bool {
        match self.prediction {
            ::std::option::Option::Some(prediction::Prediction::FloatmapPrediction(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_floatmap_prediction(&mut self, v: FloatMapPrediction) {
        self.prediction = ::std::option::Option::Some(prediction::Prediction::FloatmapPrediction(v))
    }

    // Mutable pointer to the field.
    pub fn mut_floatmap_prediction(&mut self) -> &mut FloatMapPrediction {
        if let ::std::option::Option::Some(prediction::Prediction::FloatmapPrediction(_)) = self.prediction {
        } else {
            self.prediction = ::std::option::Option::Some(prediction::Prediction::FloatmapPrediction(FloatMapPrediction::new()));
        }
        match self.prediction {
            ::std::option::Option::Some(prediction::Prediction::FloatmapPrediction(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_floatmap_prediction(&mut self) -> FloatMapPrediction {
        if self.has_floatmap_prediction() {
            match self.prediction.take() {
                ::std::option::Option::Some(prediction::Prediction::FloatmapPrediction(v)) => v,
                _ => panic!(),
            }
        } else {
            FloatMapPrediction::new()
        }
    }
}

impl ::protobuf::Message for Prediction {
    const NAME: &'static str = "Prediction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.prediction = ::std::option::Option::Some(prediction::Prediction::FloatmapPrediction(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.prediction {
            match v {
                &prediction::Prediction::FloatmapPrediction(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.prediction {
            match v {
                &prediction::Prediction::FloatmapPrediction(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Prediction {
        Prediction::new()
    }

    fn clear(&mut self) {
        self.prediction = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Prediction {
        static instance: Prediction = Prediction {
            prediction: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `Prediction`
pub mod prediction {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:denkproto.Prediction.prediction)
    pub enum Prediction {
        // @@protoc_insertion_point(oneof_field:denkproto.Prediction.floatmap_prediction)
        FloatmapPrediction(super::FloatMapPrediction),
    }

    impl ::protobuf::Oneof for Prediction {
    }

    impl Prediction {
    }
}

// @@protoc_insertion_point(message:denkproto.Result)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Result {
    // message fields
    // @@protoc_insertion_point(field:denkproto.Result.grade)
    pub grade: i32,
    // @@protoc_insertion_point(field:denkproto.Result.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:denkproto.Result.color)
    pub color: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.Result.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Result {
    fn default() -> &'a Result {
        <Result as ::protobuf::Message>::default_instance()
    }
}

impl Result {
    pub fn new() -> Result {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Result {
    const NAME: &'static str = "Result";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.grade = is.read_int32()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.color = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.grade != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.grade);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.color.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.color);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.grade != 0 {
            os.write_int32(1, self.grade)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.color.is_empty() {
            os.write_string(3, &self.color)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Result {
        Result::new()
    }

    fn clear(&mut self) {
        self.grade = 0;
        self.name.clear();
        self.color.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Result {
        static instance: Result = Result {
            grade: 0,
            name: ::std::string::String::new(),
            color: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:denkproto.ClassLabel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClassLabel {
    // message fields
    ///  uuid of the class
    // @@protoc_insertion_point(field:denkproto.ClassLabel.id)
    pub id: ::std::string::String,
    ///  uuid of the network
    // @@protoc_insertion_point(field:denkproto.ClassLabel.network_id)
    pub network_id: ::std::string::String,
    ///  index of the class (as it is present in network)
    // @@protoc_insertion_point(field:denkproto.ClassLabel.index)
    pub index: i32,
    ///  name o the class
    // @@protoc_insertion_point(field:denkproto.ClassLabel.name)
    pub name: ::std::string::String,
    ///  all css color formats allowed
    // @@protoc_insertion_point(field:denkproto.ClassLabel.color)
    pub color: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.ClassLabel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClassLabel {
    fn default() -> &'a ClassLabel {
        <ClassLabel as ::protobuf::Message>::default_instance()
    }
}

impl ClassLabel {
    pub fn new() -> ClassLabel {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ClassLabel {
    const NAME: &'static str = "ClassLabel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.network_id = is.read_string()?;
                },
                24 => {
                    self.index = is.read_int32()?;
                },
                34 => {
                    self.name = is.read_string()?;
                },
                42 => {
                    self.color = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.network_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.network_id);
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.index);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.name);
        }
        if !self.color.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.color);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.network_id.is_empty() {
            os.write_string(2, &self.network_id)?;
        }
        if self.index != 0 {
            os.write_int32(3, self.index)?;
        }
        if !self.name.is_empty() {
            os.write_string(4, &self.name)?;
        }
        if !self.color.is_empty() {
            os.write_string(5, &self.color)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClassLabel {
        ClassLabel::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.network_id.clear();
        self.index = 0;
        self.name.clear();
        self.color.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClassLabel {
        static instance: ClassLabel = ClassLabel {
            id: ::std::string::String::new(),
            network_id: ::std::string::String::new(),
            index: 0,
            name: ::std::string::String::new(),
            color: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:denkproto.DENKbuffer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DENKbuffer {
    // message fields
    ///  uuid of the buffer
    // @@protoc_insertion_point(field:denkproto.DENKbuffer.id)
    pub id: ::std::string::String,
    ///  uuid of the user that was logged-in when the buffer was created
    // @@protoc_insertion_point(field:denkproto.DENKbuffer.created_by_user_id)
    pub created_by_user_id: ::std::string::String,
    ///  uuid of the group this buffer belongs to
    // @@protoc_insertion_point(field:denkproto.DENKbuffer.owned_by_group_id)
    pub owned_by_group_id: ::std::string::String,
    ///  the time when this buffer was created
    ///  if triggers are present, this should be equal to latest trigger timestamp
    // @@protoc_insertion_point(field:denkproto.DENKbuffer.created_at)
    pub created_at: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    ///  pipeline config that was used to produce this buffer
    ///  can be used to reconstruct full pipeline
    ///  yaml format
    // @@protoc_insertion_point(field:denkproto.DENKbuffer.pipeline_config)
    pub pipeline_config: ::std::string::String,
    ///  output_port_id -> port_name
    ///  contains readable names for the output ports of the pipeline.
    // @@protoc_insertion_point(field:denkproto.DENKbuffer.port_names)
    pub port_names: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    ///  class_label_id -> class_label.
    ///  Is part of every buffer object and pre-filled by pipeline service.
    ///  Can be used to draw correct colors for detected objects.
    // @@protoc_insertion_point(field:denkproto.DENKbuffer.class_labels)
    pub class_labels: ::std::collections::HashMap<::std::string::String, ClassLabel>,
    ///  trigger timestamps
    ///  latest timestamp should be equal to buffer.created_at
    ///  output_port_id -> image
    // @@protoc_insertion_point(field:denkproto.DENKbuffer.triggers)
    pub triggers: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::timestamp::Timestamp>,
    ///  Pipeline images
    // @@protoc_insertion_point(field:denkproto.DENKbuffer.images)
    pub images: ::std::collections::HashMap<::std::string::String, Image>,
    ///  Encoded thumbnail images. Can be JPEG, PNG, WEBP
    ///  Can be used to show thumbnails for quick loading.
    ///  output_port_id -> image
    // @@protoc_insertion_point(field:denkproto.DENKbuffer.predictions)
    pub predictions: ::std::collections::HashMap<::std::string::String, Prediction>,
    ///  Contains more user-friendly representation of predictions.
    ///  Are used in filter and decision node.
    ///  Are used in clients to draw found objects.
    ///  output_port_id -> objects
    // @@protoc_insertion_point(field:denkproto.DENKbuffer.objects)
    pub objects: ::std::collections::HashMap<::std::string::String, InferenceObjects>,
    ///  Contains over all results.
    ///  (Possible future use-case: Multiple results possible when multiple decision nodes are used.)
    ///  output_port_id -> result
    // @@protoc_insertion_point(field:denkproto.DENKbuffer.results)
    pub results: ::std::collections::HashMap<::std::string::String, Result>,
    ///  contains tags that can be used to identify this denkbuffer
    // @@protoc_insertion_point(field:denkproto.DENKbuffer.tags)
    pub tags: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:denkproto.DENKbuffer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DENKbuffer {
    fn default() -> &'a DENKbuffer {
        <DENKbuffer as ::protobuf::Message>::default_instance()
    }
}

impl DENKbuffer {
    pub fn new() -> DENKbuffer {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DENKbuffer {
    const NAME: &'static str = "DENKbuffer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.created_by_user_id = is.read_string()?;
                },
                26 => {
                    self.owned_by_group_id = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                42 => {
                    self.pipeline_config = is.read_string()?;
                },
                50 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.port_names.insert(key, value);
                },
                90 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.class_labels.insert(key, value);
                },
                170 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.triggers.insert(key, value);
                },
                250 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.images.insert(key, value);
                },
                410 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.predictions.insert(key, value);
                },
                490 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.objects.insert(key, value);
                },
                570 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.results.insert(key, value);
                },
                810 => {
                    self.tags.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.created_by_user_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.created_by_user_id);
        }
        if !self.owned_by_group_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.owned_by_group_id);
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.pipeline_config.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.pipeline_config);
        }
        for (k, v) in &self.port_names {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.class_labels {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.triggers {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.images {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.predictions {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.objects {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.results {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(101, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.created_by_user_id.is_empty() {
            os.write_string(2, &self.created_by_user_id)?;
        }
        if !self.owned_by_group_id.is_empty() {
            os.write_string(3, &self.owned_by_group_id)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if !self.pipeline_config.is_empty() {
            os.write_string(5, &self.pipeline_config)?;
        }
        for (k, v) in &self.port_names {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(50)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        for (k, v) in &self.class_labels {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(90)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.triggers {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(170)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.images {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(250)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.predictions {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(410)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.objects {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(490)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.results {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(570)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.tags {
            os.write_string(101, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DENKbuffer {
        DENKbuffer::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.created_by_user_id.clear();
        self.owned_by_group_id.clear();
        self.created_at.clear();
        self.pipeline_config.clear();
        self.port_names.clear();
        self.class_labels.clear();
        self.triggers.clear();
        self.images.clear();
        self.predictions.clear();
        self.objects.clear();
        self.results.clear();
        self.tags.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DENKbuffer {
        static instance: ::protobuf::rt::Lazy<DENKbuffer> = ::protobuf::rt::Lazy::new();
        instance.get(DENKbuffer::new)
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:denkproto.ImageTypes)
pub enum ImageTypes {
    // @@protoc_insertion_point(enum_value:denkproto.ImageTypes.Raw)
    Raw = 0,
    // @@protoc_insertion_point(enum_value:denkproto.ImageTypes.Preview)
    Preview = 1,
}

impl ::protobuf::Enum for ImageTypes {
    const NAME: &'static str = "ImageTypes";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ImageTypes> {
        match value {
            0 => ::std::option::Option::Some(ImageTypes::Raw),
            1 => ::std::option::Option::Some(ImageTypes::Preview),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ImageTypes> {
        match str {
            "Raw" => ::std::option::Option::Some(ImageTypes::Raw),
            "Preview" => ::std::option::Option::Some(ImageTypes::Preview),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ImageTypes] = &[
        ImageTypes::Raw,
        ImageTypes::Preview,
    ];
}

impl ::std::default::Default for ImageTypes {
    fn default() -> Self {
        ImageTypes::Raw
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:denkproto.ComputedPropertySubjects)
pub enum ComputedPropertySubjects {
    // @@protoc_insertion_point(enum_value:denkproto.ComputedPropertySubjects.COMPUTED_PROPERTY_SUBJECT_MEAN_GRAY_VALUE)
    COMPUTED_PROPERTY_SUBJECT_MEAN_GRAY_VALUE = 0,
}

impl ::protobuf::Enum for ComputedPropertySubjects {
    const NAME: &'static str = "ComputedPropertySubjects";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ComputedPropertySubjects> {
        match value {
            0 => ::std::option::Option::Some(ComputedPropertySubjects::COMPUTED_PROPERTY_SUBJECT_MEAN_GRAY_VALUE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ComputedPropertySubjects> {
        match str {
            "COMPUTED_PROPERTY_SUBJECT_MEAN_GRAY_VALUE" => ::std::option::Option::Some(ComputedPropertySubjects::COMPUTED_PROPERTY_SUBJECT_MEAN_GRAY_VALUE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ComputedPropertySubjects] = &[
        ComputedPropertySubjects::COMPUTED_PROPERTY_SUBJECT_MEAN_GRAY_VALUE,
    ];
}

impl ::std::default::Default for ComputedPropertySubjects {
    fn default() -> Self {
        ComputedPropertySubjects::COMPUTED_PROPERTY_SUBJECT_MEAN_GRAY_VALUE
    }
}

